{
  "version": 3,
  "sources": ["package-external:@wordpress/data", "package-external:@wordpress/url", "package-external:@wordpress/i18n", "package-external:@wordpress/blob", "package-external:@wordpress/private-apis", "package-external:@wordpress/element", "package-external:@wordpress/compose", "vendor-external:react/jsx-runtime", "../../../packages/upload-media/src/store/index.ts", "../../../packages/upload-media/src/store/types.ts", "../../../packages/upload-media/src/store/constants.ts", "../../../packages/upload-media/src/store/reducer.ts", "../../../packages/upload-media/src/store/selectors.ts", "../../../packages/upload-media/src/store/private-selectors.ts", "../../../node_modules/uuid/dist/esm-browser/rng.js", "../../../node_modules/uuid/dist/esm-browser/stringify.js", "../../../node_modules/uuid/dist/esm-browser/native.js", "../../../node_modules/uuid/dist/esm-browser/v4.js", "../../../packages/upload-media/src/image-file.ts", "../../../packages/upload-media/src/utils.ts", "../../../packages/upload-media/src/store/utils/index.ts", "../../../packages/upload-media/src/validate-mime-type.ts", "../../../packages/upload-media/src/upload-error.ts", "../../../packages/upload-media/src/validate-mime-type-for-user.ts", "../../../packages/upload-media/src/get-mime-types-array.ts", "../../../packages/upload-media/src/validate-file-size.ts", "../../../packages/upload-media/src/store/actions.ts", "../../../packages/upload-media/src/store/private-actions.ts", "../../../packages/upload-media/src/stub-file.ts", "../../../packages/upload-media/src/lock-unlock.ts", "../../../packages/upload-media/src/components/provider/index.tsx", "../../../packages/upload-media/src/components/provider/with-registry-provider.tsx", "../../../packages/upload-media/src/feature-detection.ts"],
  "sourcesContent": ["module.exports = window.wp.data;", "module.exports = window.wp.url;", "module.exports = window.wp.i18n;", "module.exports = window.wp.blob;", "module.exports = window.wp.privateApis;", "module.exports = window.wp.element;", "module.exports = window.wp.compose;", "module.exports = window.ReactJSXRuntime;", "/**\n * WordPress dependencies\n */\nimport { createReduxStore, register, select } from '@wordpress/data';\n\n/**\n * Internal dependencies\n */\nimport reducer from './reducer';\nimport * as selectors from './selectors';\nimport * as privateSelectors from './private-selectors';\nimport * as actions from './actions';\nimport * as privateActions from './private-actions';\nimport { unlock } from '../lock-unlock';\nimport { STORE_NAME } from './constants';\n\n/**\n * Media upload data store configuration.\n *\n * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/data/README.md#registerStore\n */\nexport const storeConfig = {\n\treducer,\n\tselectors,\n\tactions,\n};\n\n/**\n * Store definition for the media upload namespace.\n *\n * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/data/README.md#createReduxStore\n */\nexport const store = createReduxStore( STORE_NAME, {\n\treducer,\n\tselectors,\n\tactions,\n} );\n\n// The upload-media package is bundled into multiple packages (block-editor, editor).\n// Guard against duplicate registration when both bundles are loaded on the same page.\nif ( ! select( store ) ) {\n\tregister( store );\n}\n// @ts-ignore\nunlock( store ).registerPrivateActions( privateActions );\n// @ts-ignore\nunlock( store ).registerPrivateSelectors( privateSelectors );\n", "export type QueueItemId = string;\n\nexport type QueueStatus = 'active' | 'paused';\n\nexport type BatchId = string;\n\nexport interface QueueItem {\n\tid: QueueItemId;\n\tsourceFile: File;\n\tfile: File;\n\tposter?: File;\n\tattachment?: Partial< Attachment >;\n\tstatus: ItemStatus;\n\tadditionalData: AdditionalData;\n\tonChange?: OnChangeHandler;\n\tonSuccess?: OnSuccessHandler;\n\tonError?: OnErrorHandler;\n\tonBatchSuccess?: OnBatchSuccessHandler;\n\tcurrentOperation?: OperationType;\n\toperations?: Operation[];\n\terror?: Error;\n\tretryCount?: number;\n\tprogress?: number;\n\tbatchId?: string;\n\tsourceUrl?: string;\n\tsourceAttachmentId?: number;\n\tabortController?: AbortController;\n\tparentId?: QueueItemId;\n}\n\nexport interface State {\n\tqueue: QueueItem[];\n\tqueueStatus: QueueStatus;\n\tblobUrls: Record< QueueItemId, string[] >;\n\tsettings: Settings;\n}\n\nexport enum Type {\n\tUnknown = 'REDUX_UNKNOWN',\n\tAdd = 'ADD_ITEM',\n\tPrepare = 'PREPARE_ITEM',\n\tCancel = 'CANCEL_ITEM',\n\tRemove = 'REMOVE_ITEM',\n\tRetryItem = 'RETRY_ITEM',\n\tPauseItem = 'PAUSE_ITEM',\n\tResumeItem = 'RESUME_ITEM',\n\tPauseQueue = 'PAUSE_QUEUE',\n\tResumeQueue = 'RESUME_QUEUE',\n\tOperationStart = 'OPERATION_START',\n\tOperationFinish = 'OPERATION_FINISH',\n\tAddOperations = 'ADD_OPERATIONS',\n\tCacheBlobUrl = 'CACHE_BLOB_URL',\n\tRevokeBlobUrls = 'REVOKE_BLOB_URLS',\n\tUpdateProgress = 'UPDATE_PROGRESS',\n\tUpdateSettings = 'UPDATE_SETTINGS',\n}\n\ntype Action< T = Type, Payload = Record< string, unknown > > = {\n\ttype: T;\n} & Payload;\n\nexport type UnknownAction = Action< Type.Unknown >;\nexport type AddAction = Action<\n\tType.Add,\n\t{\n\t\titem: Omit< QueueItem, 'operations' > &\n\t\t\tPartial< Pick< QueueItem, 'operations' > >;\n\t}\n>;\nexport type OperationStartAction = Action<\n\tType.OperationStart,\n\t{ id: QueueItemId; operation: OperationType }\n>;\nexport type OperationFinishAction = Action<\n\tType.OperationFinish,\n\t{\n\t\tid: QueueItemId;\n\t\titem: Partial< QueueItem >;\n\t}\n>;\nexport type AddOperationsAction = Action<\n\tType.AddOperations,\n\t{ id: QueueItemId; operations: Operation[] }\n>;\nexport type CancelAction = Action<\n\tType.Cancel,\n\t{ id: QueueItemId; error: Error }\n>;\nexport type RetryItemAction = Action< Type.RetryItem, { id: QueueItemId } >;\nexport type PauseItemAction = Action< Type.PauseItem, { id: QueueItemId } >;\nexport type ResumeItemAction = Action< Type.ResumeItem, { id: QueueItemId } >;\nexport type PauseQueueAction = Action< Type.PauseQueue >;\nexport type ResumeQueueAction = Action< Type.ResumeQueue >;\nexport type RemoveAction = Action< Type.Remove, { id: QueueItemId } >;\nexport type CacheBlobUrlAction = Action<\n\tType.CacheBlobUrl,\n\t{ id: QueueItemId; blobUrl: string }\n>;\nexport type RevokeBlobUrlsAction = Action<\n\tType.RevokeBlobUrls,\n\t{ id: QueueItemId }\n>;\nexport type UpdateProgressAction = Action<\n\tType.UpdateProgress,\n\t{ id: QueueItemId; progress: number }\n>;\nexport type UpdateSettingsAction = Action<\n\tType.UpdateSettings,\n\t{ settings: Partial< Settings > }\n>;\n\ninterface UploadMediaArgs {\n\t// Additional data to include in the request.\n\tadditionalData?: AdditionalData;\n\t// Array with the types of media that can be uploaded, if unset all types are allowed.\n\tallowedTypes?: string[];\n\t// List of files.\n\tfilesList: File[];\n\t// Maximum upload size in bytes allowed for the site.\n\tmaxUploadFileSize?: number;\n\t// Function called when an error happens.\n\tonError?: OnErrorHandler;\n\t// Function called each time a file or a temporary representation of the file is available.\n\tonFileChange?: OnChangeHandler;\n\t// Function called once a file has completely finished uploading, including thumbnails.\n\tonSuccess?: OnSuccessHandler;\n\t// List of allowed mime types and file extensions.\n\twpAllowedMimeTypes?: Record< string, string > | null;\n\t// Abort signal.\n\tsignal?: AbortSignal;\n}\n\n/**\n * Arguments for sideloading a file to an existing attachment.\n *\n * Sideloading adds additional image sizes (thumbnails) to an already\n * uploaded attachment without creating a new attachment.\n */\nexport interface SideloadMediaArgs {\n\t/** File to sideload (typically a resized version of the original). */\n\tfile: File;\n\t/** Attachment ID to add the sideloaded file to. */\n\tattachmentId: number;\n\t/** Additional data to include in the request. */\n\tadditionalData?: AdditionalData;\n\t/** Function called when an error happens. */\n\tonError?: OnErrorHandler;\n\t/** Function called when the file or a temporary representation is available. */\n\tonFileChange?: OnChangeHandler;\n\t/** Abort signal to cancel the sideload operation. */\n\tsignal?: AbortSignal;\n}\n\nexport interface Settings {\n\t// Registered image sizes from the server.\n\tallImageSizes?: Record< string, ImageSizeCrop >;\n\t// Function for uploading files to the server.\n\tmediaUpload: ( args: UploadMediaArgs ) => void;\n\t// Function for sideloading files to existing attachments.\n\tmediaSideload?: ( args: SideloadMediaArgs ) => void;\n\t// List of allowed mime types and file extensions.\n\tallowedMimeTypes?: Record< string, string > | null;\n\t// Maximum upload file size.\n\tmaxUploadFileSize?: number;\n\t// Maximum number of concurrent uploads.\n\tmaxConcurrentUploads: number;\n\t// Maximum number of concurrent image processing operations (resize, crop, rotate).\n\tmaxConcurrentImageProcessing: number;\n\t// Big image size threshold in pixels.\n\t// Images larger than this will be scaled down.\n\t// Default is 2560 (matching WordPress core).\n\tbigImageSizeThreshold?: number;\n\t// Map of source MIME types to output MIME types for transcoding.\n\timageOutputFormats?: Record< string, string >;\n\t// Whether to use progressive/interlaced encoding for JPEG.\n\tjpegInterlaced?: boolean;\n\t// Whether to use interlaced encoding for PNG.\n\tpngInterlaced?: boolean;\n\t// Whether to use interlaced encoding for GIF.\n\tgifInterlaced?: boolean;\n}\n\n// Matches the Attachment type from the media-utils package.\nexport interface Attachment {\n\tid: number;\n\talt: string;\n\tcaption: string;\n\ttitle: string;\n\turl: string;\n\tfilename: string | null;\n\tfilesize: number | null;\n\tmedia_type: 'image' | 'file';\n\tmime_type: string;\n\tfeatured_media?: number;\n\tmissing_image_sizes?: string[];\n\tmedia_filename?: string;\n\tposter?: string;\n\t/**\n\t * EXIF orientation value from the original image.\n\t * Values 1-8 follow the EXIF specification.\n\t * A value other than 1 indicates the image needs rotation.\n\t *\n\t * Orientation values:\n\t * 1 = Normal (no rotation needed)\n\t * 2 = Flipped horizontally\n\t * 3 = Rotated 180\u00B0\n\t * 4 = Flipped vertically\n\t * 5 = Rotated 90\u00B0 CCW and flipped horizontally\n\t * 6 = Rotated 90\u00B0 CW\n\t * 7 = Rotated 90\u00B0 CW and flipped horizontally\n\t * 8 = Rotated 90\u00B0 CCW\n\t */\n\texif_orientation?: number;\n}\n\nexport type OnChangeHandler = ( attachments: Partial< Attachment >[] ) => void;\nexport type OnSuccessHandler = ( attachments: Partial< Attachment >[] ) => void;\nexport type OnErrorHandler = ( error: Error ) => void;\nexport type OnBatchSuccessHandler = () => void;\n\nexport enum ItemStatus {\n\tQueued = 'QUEUED',\n\tProcessing = 'PROCESSING',\n\tPaused = 'PAUSED',\n\tUploaded = 'UPLOADED',\n\tError = 'ERROR',\n}\n\nexport enum OperationType {\n\tPrepare = 'PREPARE',\n\tUpload = 'UPLOAD',\n\tResizeCrop = 'RESIZE_CROP',\n\tRotate = 'ROTATE',\n\tTranscodeImage = 'TRANSCODE_IMAGE',\n\tThumbnailGeneration = 'THUMBNAIL_GENERATION',\n}\n\n/**\n * Defines the dimensions and cropping behavior for an image size.\n */\nexport interface ImageSizeCrop {\n\t/** Target width in pixels. */\n\twidth: number;\n\t/** Target height in pixels. */\n\theight: number;\n\t/**\n\t * Crop behavior.\n\t * - `true` for hard crop centered.\n\t * - Positional array like `['left', 'top']` for specific crop anchor.\n\t * - `false` or undefined for soft proportional resize.\n\t */\n\tcrop?:\n\t\t| boolean\n\t\t| [ 'left' | 'center' | 'right', 'top' | 'center' | 'bottom' ];\n\t/** Size name identifier (e.g., 'thumbnail', 'medium'). */\n\tname?: string;\n}\n\nexport interface OperationArgs {\n\t[ OperationType.ResizeCrop ]: {\n\t\tresize: ImageSizeCrop;\n\t\t/**\n\t\t * Whether this resize is for the big image size threshold.\n\t\t * If true, uses '-scaled' suffix instead of dimension suffix.\n\t\t */\n\t\tisThresholdResize?: boolean;\n\t};\n\t[ OperationType.Rotate ]: {\n\t\t/**\n\t\t * EXIF orientation value (1-8) indicating the required rotation.\n\t\t * Used to apply the correct rotation/flip transformation.\n\t\t */\n\t\torientation: number;\n\t};\n\t[ OperationType.TranscodeImage ]: {\n\t\t/** Target output format. */\n\t\toutputFormat: ImageFormat;\n\t\t/** Quality setting (0-1). */\n\t\toutputQuality: number;\n\t\t/** Whether to use interlaced encoding. */\n\t\tinterlaced: boolean;\n\t};\n}\n\ntype OperationWithArgs< T extends keyof OperationArgs = keyof OperationArgs > =\n\t[ T, OperationArgs[ T ] ];\n\nexport type Operation = OperationType | OperationWithArgs;\n\nexport type AdditionalData = Record< string, unknown >;\n\n/**\n * Additional data specific to sideload operations.\n *\n * This extends the base AdditionalData with fields required for\n * sideloading image sizes to an existing attachment.\n */\nexport interface SideloadAdditionalData extends AdditionalData {\n\t/** The attachment ID to add the image size to. */\n\tpost: number;\n\t/** The name of the image size being generated (e.g., 'thumbnail', 'medium'). */\n\timage_size: string;\n}\n\nexport type ImageFormat = 'jpeg' | 'webp' | 'avif' | 'png' | 'gif';\n", "export const STORE_NAME = 'core/upload-media';\n\n/**\n * Default maximum number of concurrent uploads.\n */\nexport const DEFAULT_MAX_CONCURRENT_UPLOADS = 5;\n\n/**\n * Default maximum number of concurrent image processing operations.\n *\n * Image processing (VIPS WASM) is significantly more memory-intensive\n * than network uploads. Each operation can consume 50-100MB+ of memory\n * for large images. A lower limit prevents out-of-memory crashes when\n * uploading many images at once.\n */\nexport const DEFAULT_MAX_CONCURRENT_IMAGE_PROCESSING = 2;\n\n/**\n * MIME types supported by client-side media processing.\n *\n * These are the image formats that can be processed using\n * WebAssembly-based vips in the browser.\n */\nexport const CLIENT_SIDE_SUPPORTED_MIME_TYPES: readonly string[] = [\n\t'image/jpeg',\n\t'image/png',\n\t'image/gif',\n\t'image/webp',\n\t'image/avif',\n] as const;\n", "/**\n * Internal dependencies\n */\nimport {\n\ttype AddAction,\n\ttype AddOperationsAction,\n\ttype CacheBlobUrlAction,\n\ttype CancelAction,\n\tItemStatus,\n\ttype OperationFinishAction,\n\ttype OperationStartAction,\n\ttype PauseItemAction,\n\ttype PauseQueueAction,\n\ttype QueueItem,\n\ttype RemoveAction,\n\ttype ResumeItemAction,\n\ttype ResumeQueueAction,\n\ttype RetryItemAction,\n\ttype RevokeBlobUrlsAction,\n\ttype State,\n\tType,\n\ttype UnknownAction,\n\ttype UpdateProgressAction,\n\ttype UpdateSettingsAction,\n} from './types';\nimport {\n\tDEFAULT_MAX_CONCURRENT_UPLOADS,\n\tDEFAULT_MAX_CONCURRENT_IMAGE_PROCESSING,\n} from './constants';\n\nconst noop = () => {};\n\nconst DEFAULT_STATE: State = {\n\tqueue: [],\n\tqueueStatus: 'active',\n\tblobUrls: {},\n\tsettings: {\n\t\tmediaUpload: noop,\n\t\tmaxConcurrentUploads: DEFAULT_MAX_CONCURRENT_UPLOADS,\n\t\tmaxConcurrentImageProcessing: DEFAULT_MAX_CONCURRENT_IMAGE_PROCESSING,\n\t},\n};\n\ntype Action =\n\t| AddAction\n\t| RemoveAction\n\t| CancelAction\n\t| RetryItemAction\n\t| PauseItemAction\n\t| ResumeItemAction\n\t| PauseQueueAction\n\t| ResumeQueueAction\n\t| AddOperationsAction\n\t| OperationFinishAction\n\t| OperationStartAction\n\t| CacheBlobUrlAction\n\t| RevokeBlobUrlsAction\n\t| UpdateProgressAction\n\t| UpdateSettingsAction\n\t| UnknownAction;\n\nfunction reducer(\n\tstate = DEFAULT_STATE,\n\taction: Action = { type: Type.Unknown }\n) {\n\tswitch ( action.type ) {\n\t\tcase Type.PauseQueue: {\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tqueueStatus: 'paused',\n\t\t\t};\n\t\t}\n\n\t\tcase Type.ResumeQueue: {\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tqueueStatus: 'active',\n\t\t\t};\n\t\t}\n\n\t\tcase Type.PauseItem:\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tqueue: state.queue.map(\n\t\t\t\t\t( item ): QueueItem =>\n\t\t\t\t\t\titem.id === action.id\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t...item,\n\t\t\t\t\t\t\t\t\tstatus: ItemStatus.Paused,\n\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t: item\n\t\t\t\t),\n\t\t\t};\n\n\t\tcase Type.ResumeItem:\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tqueue: state.queue.map(\n\t\t\t\t\t( item ): QueueItem =>\n\t\t\t\t\t\titem.id === action.id\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t...item,\n\t\t\t\t\t\t\t\t\tstatus: ItemStatus.Processing,\n\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t: item\n\t\t\t\t),\n\t\t\t};\n\n\t\tcase Type.Add:\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tqueue: [ ...state.queue, action.item ],\n\t\t\t};\n\n\t\tcase Type.Cancel:\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tqueue: state.queue.map(\n\t\t\t\t\t( item ): QueueItem =>\n\t\t\t\t\t\titem.id === action.id\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t...item,\n\t\t\t\t\t\t\t\t\terror: action.error,\n\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t: item\n\t\t\t\t),\n\t\t\t};\n\n\t\tcase Type.RetryItem:\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tqueue: state.queue.map(\n\t\t\t\t\t( item ): QueueItem =>\n\t\t\t\t\t\titem.id === action.id\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t...item,\n\t\t\t\t\t\t\t\t\tstatus: ItemStatus.Processing,\n\t\t\t\t\t\t\t\t\terror: undefined,\n\t\t\t\t\t\t\t\t\tretryCount: ( item.retryCount ?? 0 ) + 1,\n\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t: item\n\t\t\t\t),\n\t\t\t};\n\n\t\tcase Type.Remove:\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tqueue: state.queue.filter( ( item ) => item.id !== action.id ),\n\t\t\t};\n\n\t\tcase Type.OperationStart: {\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tqueue: state.queue.map(\n\t\t\t\t\t( item ): QueueItem =>\n\t\t\t\t\t\titem.id === action.id\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t...item,\n\t\t\t\t\t\t\t\t\tcurrentOperation: action.operation,\n\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t: item\n\t\t\t\t),\n\t\t\t};\n\t\t}\n\n\t\tcase Type.AddOperations:\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tqueue: state.queue.map( ( item ): QueueItem => {\n\t\t\t\t\tif ( item.id !== action.id ) {\n\t\t\t\t\t\treturn item;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\t...item,\n\t\t\t\t\t\toperations: [\n\t\t\t\t\t\t\t...( item.operations || [] ),\n\t\t\t\t\t\t\t...action.operations,\n\t\t\t\t\t\t],\n\t\t\t\t\t};\n\t\t\t\t} ),\n\t\t\t};\n\n\t\tcase Type.OperationFinish:\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tqueue: state.queue.map( ( item ): QueueItem => {\n\t\t\t\t\tif ( item.id !== action.id ) {\n\t\t\t\t\t\treturn item;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst operations = item.operations\n\t\t\t\t\t\t? item.operations.slice( 1 )\n\t\t\t\t\t\t: [];\n\n\t\t\t\t\t// Prevent an empty object if there's no attachment data.\n\t\t\t\t\tconst attachment =\n\t\t\t\t\t\titem.attachment || action.item.attachment\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t...item.attachment,\n\t\t\t\t\t\t\t\t\t...action.item.attachment,\n\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t: undefined;\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\t...item,\n\t\t\t\t\t\tcurrentOperation: undefined,\n\t\t\t\t\t\toperations,\n\t\t\t\t\t\t...action.item,\n\t\t\t\t\t\tattachment,\n\t\t\t\t\t\tadditionalData: {\n\t\t\t\t\t\t\t...item.additionalData,\n\t\t\t\t\t\t\t...action.item.additionalData,\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t} ),\n\t\t\t};\n\n\t\tcase Type.CacheBlobUrl: {\n\t\t\tconst blobUrls = state.blobUrls[ action.id ] || [];\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tblobUrls: {\n\t\t\t\t\t...state.blobUrls,\n\t\t\t\t\t[ action.id ]: [ ...blobUrls, action.blobUrl ],\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\n\t\tcase Type.RevokeBlobUrls: {\n\t\t\tconst newBlobUrls = { ...state.blobUrls };\n\t\t\tdelete newBlobUrls[ action.id ];\n\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tblobUrls: newBlobUrls,\n\t\t\t};\n\t\t}\n\n\t\tcase Type.UpdateProgress:\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tqueue: state.queue.map(\n\t\t\t\t\t( item ): QueueItem =>\n\t\t\t\t\t\titem.id === action.id\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t...item,\n\t\t\t\t\t\t\t\t\tprogress: action.progress,\n\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t: item\n\t\t\t\t),\n\t\t\t};\n\n\t\tcase Type.UpdateSettings: {\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tsettings: {\n\t\t\t\t\t...state.settings,\n\t\t\t\t\t...action.settings,\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t}\n\n\treturn state;\n}\n\nexport default reducer;\n", "/**\n * Internal dependencies\n */\nimport type { QueueItem, Settings, State } from './types';\n\n/**\n * Returns all items currently being uploaded.\n *\n * @param state Upload state.\n *\n * @return Queue items.\n */\nexport function getItems( state: State ): QueueItem[] {\n\treturn state.queue;\n}\n\n/**\n * Determines whether any upload is currently in progress.\n *\n * @param state Upload state.\n *\n * @return Whether any upload is currently in progress.\n */\nexport function isUploading( state: State ): boolean {\n\treturn state.queue.length >= 1;\n}\n\n/**\n * Determines whether an upload is currently in progress given an attachment URL.\n *\n * @param state Upload state.\n * @param url   Attachment URL.\n *\n * @return Whether upload is currently in progress for the given attachment.\n */\nexport function isUploadingByUrl( state: State, url: string ): boolean {\n\treturn state.queue.some(\n\t\t( item ) => item.attachment?.url === url || item.sourceUrl === url\n\t);\n}\n\n/**\n * Determines whether an upload is currently in progress given an attachment ID.\n *\n * @param state        Upload state.\n * @param attachmentId Attachment ID.\n *\n * @return Whether upload is currently in progress for the given attachment.\n */\nexport function isUploadingById( state: State, attachmentId: number ): boolean {\n\treturn state.queue.some(\n\t\t( item ) =>\n\t\t\titem.attachment?.id === attachmentId ||\n\t\t\titem.sourceAttachmentId === attachmentId\n\t);\n}\n\n/**\n * Returns the media upload settings.\n *\n * @param state Upload state.\n *\n * @return Settings\n */\nexport function getSettings( state: State ): Settings {\n\treturn state.settings;\n}\n", "/**\n * Internal dependencies\n */\nimport {\n\ttype BatchId,\n\tItemStatus,\n\tOperationType,\n\ttype QueueItem,\n\ttype QueueItemId,\n\ttype State,\n} from './types';\n\n/**\n * Returns all items currently being uploaded.\n *\n * @param state Upload state.\n *\n * @return Queue items.\n */\nexport function getAllItems( state: State ): QueueItem[] {\n\treturn state.queue;\n}\n\n/**\n * Returns a specific item given its unique ID.\n *\n * @param state Upload state.\n * @param id    Item ID.\n *\n * @return Queue item.\n */\nexport function getItem(\n\tstate: State,\n\tid: QueueItemId\n): QueueItem | undefined {\n\treturn state.queue.find( ( item ) => item.id === id );\n}\n\n/**\n * Determines whether a batch has been successfully uploaded, given its unique ID.\n *\n * @param state   Upload state.\n * @param batchId Batch ID.\n *\n * @return Whether a batch has been uploaded.\n */\nexport function isBatchUploaded( state: State, batchId: BatchId ): boolean {\n\tconst batchItems = state.queue.filter(\n\t\t( item ) => batchId === item.batchId\n\t);\n\treturn batchItems.length === 0;\n}\n\n/**\n * Determines whether an upload is currently in progress given a post or attachment ID.\n *\n * @param state              Upload state.\n * @param postOrAttachmentId Post ID or attachment ID.\n *\n * @return Whether upload is currently in progress for the given post or attachment.\n */\nexport function isUploadingToPost(\n\tstate: State,\n\tpostOrAttachmentId: number\n): boolean {\n\treturn state.queue.some(\n\t\t( item ) =>\n\t\t\titem.currentOperation === OperationType.Upload &&\n\t\t\titem.additionalData.post === postOrAttachmentId\n\t);\n}\n\n/**\n * Returns the next paused upload for a given post or attachment ID.\n *\n * @param state              Upload state.\n * @param postOrAttachmentId Post ID or attachment ID.\n *\n * @return Paused item.\n */\nexport function getPausedUploadForPost(\n\tstate: State,\n\tpostOrAttachmentId: number\n): QueueItem | undefined {\n\treturn state.queue.find(\n\t\t( item ) =>\n\t\t\titem.status === ItemStatus.Paused &&\n\t\t\titem.additionalData.post === postOrAttachmentId\n\t);\n}\n\n/**\n * Determines whether uploading is currently paused.\n *\n * @param state Upload state.\n *\n * @return Whether uploading is currently paused.\n */\nexport function isPaused( state: State ): boolean {\n\treturn state.queueStatus === 'paused';\n}\n\n/**\n * Returns all cached blob URLs for a given item ID.\n *\n * @param state Upload state.\n * @param id    Item ID\n *\n * @return List of blob URLs.\n */\nexport function getBlobUrls( state: State, id: QueueItemId ): string[] {\n\treturn state.blobUrls[ id ] || [];\n}\n\n/**\n * Returns the number of items currently uploading.\n *\n * @param state Upload state.\n *\n * @return Number of items currently uploading.\n */\nexport function getActiveUploadCount( state: State ): number {\n\treturn state.queue.filter(\n\t\t( item ) => item.currentOperation === OperationType.Upload\n\t).length;\n}\n\n/**\n * Returns items that are waiting for upload (next operation is Upload but not yet started).\n *\n * @param state Upload state.\n *\n * @return Items pending upload.\n */\nexport function getPendingUploads( state: State ): QueueItem[] {\n\treturn state.queue.filter( ( item ) => {\n\t\tconst nextOperation = Array.isArray( item.operations?.[ 0 ] )\n\t\t\t? item.operations[ 0 ][ 0 ]\n\t\t\t: item.operations?.[ 0 ];\n\t\treturn (\n\t\t\tnextOperation === OperationType.Upload &&\n\t\t\titem.currentOperation !== OperationType.Upload\n\t\t);\n\t} );\n}\n\n/**\n * Returns the number of items currently performing image processing operations.\n *\n * This counts items whose current operation is ResizeCrop or Rotate,\n * used to enforce the image processing concurrency limit.\n *\n * @param state Upload state.\n *\n * @return Number of items currently processing images.\n */\nexport function getActiveImageProcessingCount( state: State ): number {\n\treturn state.queue.filter(\n\t\t( item ) =>\n\t\t\titem.currentOperation === OperationType.ResizeCrop ||\n\t\t\titem.currentOperation === OperationType.Rotate\n\t).length;\n}\n\n/**\n * Returns items waiting for image processing (next operation is ResizeCrop\n * or Rotate but not yet started).\n *\n * @param state Upload state.\n *\n * @return Items pending image processing.\n */\nexport function getPendingImageProcessing( state: State ): QueueItem[] {\n\treturn state.queue.filter( ( item ) => {\n\t\tconst nextOperation = Array.isArray( item.operations?.[ 0 ] )\n\t\t\t? item.operations[ 0 ][ 0 ]\n\t\t\t: item.operations?.[ 0 ];\n\t\treturn (\n\t\t\t( nextOperation === OperationType.ResizeCrop ||\n\t\t\t\tnextOperation === OperationType.Rotate ) &&\n\t\t\titem.currentOperation !== OperationType.ResizeCrop &&\n\t\t\titem.currentOperation !== OperationType.Rotate\n\t\t);\n\t} );\n}\n\n/**\n * Returns items that failed with an error.\n *\n * @param state Upload state.\n *\n * @return Failed items.\n */\nexport function getFailedItems( state: State ): QueueItem[] {\n\treturn state.queue.filter( ( item ) => item.error !== undefined );\n}\n\n/**\n * Returns true if any child items with the given parentId exist in the queue.\n *\n * @param state    Upload state.\n * @param parentId Parent item ID.\n *\n * @return Whether any child items with the given parentId exist in the queue.\n */\nexport function hasPendingItemsByParentId(\n\tstate: State,\n\tparentId: QueueItemId\n): boolean {\n\treturn state.queue.some( ( item ) => item.parentId === parentId );\n}\n\n/**\n * Returns the progress of a specific item.\n *\n * @param state Upload state.\n * @param id    Item ID.\n *\n * @return Progress value (0-100), or undefined if item not found.\n */\nexport function getItemProgress(\n\tstate: State,\n\tid: QueueItemId\n): number | undefined {\n\tconst item = state.queue.find( ( i ) => i.id === id );\n\treturn item?.progress;\n}\n", "// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nlet getRandomValues;\nconst rnds8 = new Uint8Array(16);\nexport default function rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}", "import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\n\nexport function unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];\n}\n\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;", "const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nexport default {\n  randomUUID\n};", "import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\n\nfunction v4(options, buf, offset) {\n  if (native.randomUUID && !buf && !options) {\n    return native.randomUUID();\n  }\n\n  options = options || {};\n  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return unsafeStringify(rnds);\n}\n\nexport default v4;", "/**\n * ImageFile class.\n *\n * Small wrapper around the `File` class to hold\n * information about current dimensions and original\n * dimensions, in case the image was resized.\n */\nexport class ImageFile extends File {\n\twidth = 0;\n\theight = 0;\n\toriginalWidth? = 0;\n\toriginalHeight? = 0;\n\n\tget wasResized() {\n\t\treturn (\n\t\t\t( this.originalWidth || 0 ) > this.width ||\n\t\t\t( this.originalHeight || 0 ) > this.height\n\t\t);\n\t}\n\n\tconstructor(\n\t\tfile: File,\n\t\twidth: number,\n\t\theight: number,\n\t\toriginalWidth?: number,\n\t\toriginalHeight?: number\n\t) {\n\t\tsuper( [ file ], file.name, {\n\t\t\ttype: file.type,\n\t\t\tlastModified: file.lastModified,\n\t\t} );\n\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t\tthis.originalWidth = originalWidth;\n\t\tthis.originalHeight = originalHeight;\n\t}\n}\n", "/**\n * WordPress dependencies\n */\nimport { getFilename } from '@wordpress/url';\nimport { _x } from '@wordpress/i18n';\n\n/**\n * Converts a Blob to a File with a default name like \"image.png\".\n *\n * If it is already a File object, it is returned unchanged.\n *\n * @param fileOrBlob Blob object.\n * @return File object.\n */\nexport function convertBlobToFile( fileOrBlob: Blob | File ): File {\n\tif ( fileOrBlob instanceof File ) {\n\t\treturn fileOrBlob;\n\t}\n\n\t// Extension is only an approximation.\n\t// The server will override it if incorrect.\n\tconst ext = fileOrBlob.type.split( '/' )[ 1 ];\n\tconst mediaType =\n\t\t'application/pdf' === fileOrBlob.type\n\t\t\t? 'document'\n\t\t\t: fileOrBlob.type.split( '/' )[ 0 ];\n\treturn new File( [ fileOrBlob ], `${ mediaType }.${ ext }`, {\n\t\ttype: fileOrBlob.type,\n\t} );\n}\n\n/**\n * Renames a given file and returns a new file.\n *\n * Copies over the last modified time.\n *\n * @param file File object.\n * @param name File name.\n * @return Renamed file object.\n */\nexport function renameFile( file: File, name: string ): File {\n\treturn new File( [ file ], name, {\n\t\ttype: file.type,\n\t\tlastModified: file.lastModified,\n\t} );\n}\n\n/**\n * Clones a given file object.\n *\n * @param file File object.\n * @return New file object.\n */\nexport function cloneFile( file: File ): File {\n\treturn renameFile( file, file.name );\n}\n\n/**\n * Returns the file extension from a given file name or URL.\n *\n * @param file File URL.\n * @return File extension or null if it does not have one.\n */\nexport function getFileExtension( file: string ): string | null {\n\treturn file.includes( '.' ) ? file.split( '.' ).pop() || null : null;\n}\n\n/**\n * Returns file basename without extension.\n *\n * For example, turns \"my-awesome-file.jpeg\" into \"my-awesome-file\".\n *\n * @param name File name.\n * @return File basename.\n */\nexport function getFileBasename( name: string ): string {\n\treturn name.includes( '.' )\n\t\t? name.split( '.' ).slice( 0, -1 ).join( '.' )\n\t\t: name;\n}\n\n/**\n * Returns the file name including extension from a URL.\n *\n * @param url File URL.\n * @return File name.\n */\nexport function getFileNameFromUrl( url: string ) {\n\treturn getFilename( url ) || _x( 'unnamed', 'file name' );\n}\n", "/**\n * Internal dependencies\n */\nimport { ImageFile } from '../../image-file';\nimport { getFileBasename } from '../../utils';\nimport type { ImageSizeCrop, QueueItemId } from '../types';\n\n/**\n * Cached dynamic import promise for @wordpress/vips/worker.\n *\n * The module contains ~10MB of inlined WASM code. By using a dynamic import,\n * the WASM is only loaded when vips functions are actually called at image\n * processing time, rather than at module parse time.\n *\n * The promise is cached so the module is only resolved once.\n */\nlet vipsModulePromise:\n\t| Promise< typeof import('@wordpress/vips/worker') >\n\t| undefined;\n\n/**\n * The resolved module reference, available synchronously after the first\n * load completes. Used by terminateVipsWorker() and vipsCancelOperations().\n */\nlet vipsModule: typeof import('@wordpress/vips/worker') | undefined;\n\n/**\n * Lazily loads and caches the @wordpress/vips/worker module.\n *\n * @return The vips worker module.\n */\nfunction loadVipsModule(): Promise< typeof import('@wordpress/vips/worker') > {\n\tif ( ! vipsModulePromise ) {\n\t\tvipsModulePromise = import( '@wordpress/vips/worker' ).then(\n\t\t\t( mod ) => {\n\t\t\t\tvipsModule = mod;\n\t\t\t\treturn mod;\n\t\t\t}\n\t\t);\n\t}\n\treturn vipsModulePromise;\n}\n\n/**\n * Converts an image to a different format using vips in a web worker.\n *\n * @param id         Queue item ID.\n * @param file       File object.\n * @param type       Output mime type.\n * @param quality    Desired quality (0-1).\n * @param interlaced Whether to use interlaced/progressive mode.\n * @return Converted file.\n */\nexport async function vipsConvertImageFormat(\n\tid: QueueItemId,\n\tfile: File,\n\ttype:\n\t\t| 'image/jpeg'\n\t\t| 'image/png'\n\t\t| 'image/webp'\n\t\t| 'image/avif'\n\t\t| 'image/gif',\n\tquality: number,\n\tinterlaced?: boolean\n) {\n\tconst { vipsConvertImageFormat: convertImageFormat } =\n\t\tawait loadVipsModule();\n\tconst buffer = await convertImageFormat(\n\t\tid,\n\t\tawait file.arrayBuffer(),\n\t\tfile.type,\n\t\ttype,\n\t\tquality,\n\t\tinterlaced\n\t);\n\tconst ext = type.split( '/' )[ 1 ];\n\tconst fileName = `${ getFileBasename( file.name ) }.${ ext }`;\n\treturn new File( [ new Blob( [ buffer as ArrayBuffer ] ) ], fileName, {\n\t\ttype,\n\t} );\n}\n\n/**\n * Compresses an image using vips in a web worker.\n *\n * @param id         Queue item ID.\n * @param file       File object.\n * @param quality    Desired quality (0-1).\n * @param interlaced Whether to use interlaced/progressive mode.\n * @return Compressed file.\n */\nexport async function vipsCompressImage(\n\tid: QueueItemId,\n\tfile: File,\n\tquality: number,\n\tinterlaced?: boolean\n) {\n\tconst { vipsCompressImage: compressImage } = await loadVipsModule();\n\tconst buffer = await compressImage(\n\t\tid,\n\t\tawait file.arrayBuffer(),\n\t\tfile.type,\n\t\tquality,\n\t\tinterlaced\n\t);\n\treturn new File(\n\t\t[ new Blob( [ buffer as ArrayBuffer ], { type: file.type } ) ],\n\t\tfile.name,\n\t\t{ type: file.type }\n\t);\n}\n\n/**\n * Checks whether an image has transparency using vips in a web worker.\n *\n * @param url Image URL.\n * @return Whether the image has transparency.\n */\nexport async function vipsHasTransparency( url: string ) {\n\tconst { vipsHasTransparency: hasTransparency } = await loadVipsModule();\n\tconst response = await fetch( url );\n\tif ( ! response.ok ) {\n\t\tthrow new Error( `Failed to fetch image: ${ response.status }` );\n\t}\n\treturn hasTransparency( await response.arrayBuffer() );\n}\n\n/**\n * Resizes an image using vips in a web worker.\n *\n * @param id           Queue item ID.\n * @param file         File object.\n * @param resize       Resize options (width, height, crop).\n * @param smartCrop    Whether to use smart cropping (saliency-aware).\n * @param addSuffix    Whether to add dimension suffix to filename.\n * @param signal       Optional abort signal to cancel the operation.\n * @param scaledSuffix Whether to add '-scaled' suffix instead of dimensions (for big image threshold).\n * @return Resized ImageFile with dimension metadata.\n */\nexport async function vipsResizeImage(\n\tid: QueueItemId,\n\tfile: File,\n\tresize: ImageSizeCrop,\n\tsmartCrop: boolean,\n\taddSuffix: boolean,\n\tsignal?: AbortSignal,\n\tscaledSuffix?: boolean\n) {\n\tif ( signal?.aborted ) {\n\t\tthrow new Error( 'Operation aborted' );\n\t}\n\n\tconst { vipsResizeImage: resizeImage } = await loadVipsModule();\n\tconst { buffer, width, height, originalWidth, originalHeight } =\n\t\tawait resizeImage(\n\t\t\tid,\n\t\t\tawait file.arrayBuffer(),\n\t\t\tfile.type,\n\t\t\tresize,\n\t\t\tsmartCrop\n\t\t);\n\n\tlet fileName = file.name;\n\tconst wasResized = originalWidth > width || originalHeight > height;\n\n\tif ( wasResized ) {\n\t\tconst basename = getFileBasename( file.name );\n\t\tif ( scaledSuffix ) {\n\t\t\t// Add '-scaled' suffix for big image threshold resizing.\n\t\t\t// This matches WordPress core's behavior in wp_create_image_subsizes().\n\t\t\tfileName = file.name.replace( basename, `${ basename }-scaled` );\n\t\t} else if ( addSuffix ) {\n\t\t\t// Add dimension suffix for thumbnails.\n\t\t\tfileName = file.name.replace(\n\t\t\t\tbasename,\n\t\t\t\t`${ basename }-${ width }x${ height }`\n\t\t\t);\n\t\t}\n\t}\n\n\tconst resultFile = new ImageFile(\n\t\tnew File(\n\t\t\t[ new Blob( [ buffer as ArrayBuffer ], { type: file.type } ) ],\n\t\t\tfileName,\n\t\t\t{\n\t\t\t\ttype: file.type,\n\t\t\t}\n\t\t),\n\t\twidth,\n\t\theight,\n\t\toriginalWidth,\n\t\toriginalHeight\n\t);\n\n\treturn resultFile;\n}\n\n/**\n * Rotates an image based on EXIF orientation using vips in a web worker.\n *\n * This applies the correct rotation/flip transformation based on the EXIF\n * orientation value (1-8), and adds a '-rotated' suffix to the filename.\n * This matches WordPress core's behavior when rotating images based on EXIF.\n *\n * @param id          Queue item ID.\n * @param file        File object.\n * @param orientation EXIF orientation value (1-8).\n * @param signal      Optional abort signal to cancel the operation.\n * @return Rotated ImageFile with updated dimensions.\n */\nexport async function vipsRotateImage(\n\tid: QueueItemId,\n\tfile: File,\n\torientation: number,\n\tsignal?: AbortSignal\n) {\n\tif ( signal?.aborted ) {\n\t\tthrow new Error( 'Operation aborted' );\n\t}\n\n\t// If orientation is 1 (normal), no rotation needed.\n\tif ( orientation === 1 ) {\n\t\treturn file;\n\t}\n\n\tconst { vipsRotateImage: rotateImage } = await loadVipsModule();\n\tconst { buffer, width, height } = await rotateImage(\n\t\tid,\n\t\tawait file.arrayBuffer(),\n\t\tfile.type,\n\t\torientation\n\t);\n\n\t// Add '-rotated' suffix to filename, matching WordPress core behavior.\n\tconst basename = getFileBasename( file.name );\n\tconst fileName = file.name.replace( basename, `${ basename }-rotated` );\n\n\tconst resultFile = new ImageFile(\n\t\tnew File(\n\t\t\t[ new Blob( [ buffer as ArrayBuffer ], { type: file.type } ) ],\n\t\t\tfileName,\n\t\t\t{\n\t\t\t\ttype: file.type,\n\t\t\t}\n\t\t),\n\t\twidth,\n\t\theight\n\t);\n\n\treturn resultFile;\n}\n\n/**\n * Cancels all ongoing image operations for the given item.\n *\n * If the vips module has not been loaded yet, there can be no active\n * operations to cancel.\n *\n * @param id Queue item ID to cancel operations for.\n * @return Whether any operation was cancelled.\n */\nexport async function vipsCancelOperations( id: QueueItemId ) {\n\tif ( ! vipsModule ) {\n\t\treturn false;\n\t}\n\treturn vipsModule.vipsCancelOperations( id );\n}\n\n/**\n * Terminates the vips worker if it has been loaded.\n *\n * If the vips module has not been loaded yet (i.e., no image processing\n * has occurred), this is a no-op since there is no worker to terminate.\n */\nexport function terminateVipsWorker(): void {\n\tif ( vipsModule ) {\n\t\tvipsModule.terminateVipsWorker();\n\t}\n}\n", "/**\n * WordPress dependencies\n */\nimport { __, sprintf } from '@wordpress/i18n';\n\n/**\n * Internal dependencies\n */\nimport { UploadError } from './upload-error';\n\n/**\n * Verifies if the caller (e.g. a block) supports this mime type.\n *\n * @param file         File object.\n * @param allowedTypes List of allowed mime types.\n */\nexport function validateMimeType( file: File, allowedTypes?: string[] ) {\n\tif ( ! allowedTypes ) {\n\t\treturn;\n\t}\n\n\t// Allowed type specified by consumer.\n\tconst isAllowedType = allowedTypes.some( ( allowedType ) => {\n\t\t// If a complete mimetype is specified verify if it matches exactly the mime type of the file.\n\t\tif ( allowedType.includes( '/' ) ) {\n\t\t\treturn allowedType === file.type;\n\t\t}\n\t\t// Otherwise a general mime type is used, and we should verify if the file mimetype starts with it.\n\t\treturn file.type.startsWith( `${ allowedType }/` );\n\t} );\n\n\tif ( file.type && ! isAllowedType ) {\n\t\tthrow new UploadError( {\n\t\t\tcode: 'MIME_TYPE_NOT_SUPPORTED',\n\t\t\tmessage: sprintf(\n\t\t\t\t// translators: %s: file name.\n\t\t\t\t__( '%s: Sorry, this file type is not supported here.' ),\n\t\t\t\tfile.name\n\t\t\t),\n\t\t\tfile,\n\t\t} );\n\t}\n}\n", "interface UploadErrorArgs {\n\tcode: string;\n\tmessage: string;\n\tfile: File;\n\tcause?: Error;\n}\n\n/**\n * MediaError class.\n *\n * Small wrapper around the `Error` class\n * to hold an error code and a reference to a file object.\n */\nexport class UploadError extends Error {\n\tcode: string;\n\tfile: File;\n\n\tconstructor( { code, message, file, cause }: UploadErrorArgs ) {\n\t\tsuper( message, { cause } );\n\n\t\tObject.setPrototypeOf( this, new.target.prototype );\n\n\t\tthis.code = code;\n\t\tthis.file = file;\n\t}\n}\n", "/**\n * WordPress dependencies\n */\nimport { __, sprintf } from '@wordpress/i18n';\n\n/**\n * Internal dependencies\n */\nimport { UploadError } from './upload-error';\nimport { getMimeTypesArray } from './get-mime-types-array';\n\n/**\n * Verifies if the user is allowed to upload this mime type.\n *\n * @param file               File object.\n * @param wpAllowedMimeTypes List of allowed mime types and file extensions.\n */\nexport function validateMimeTypeForUser(\n\tfile: File,\n\twpAllowedMimeTypes?: Record< string, string > | null\n) {\n\t// Allowed types for the current WP_User.\n\tconst allowedMimeTypesForUser = getMimeTypesArray( wpAllowedMimeTypes );\n\n\tif ( ! allowedMimeTypesForUser ) {\n\t\treturn;\n\t}\n\n\tconst isAllowedMimeTypeForUser = allowedMimeTypesForUser.includes(\n\t\tfile.type\n\t);\n\n\tif ( file.type && ! isAllowedMimeTypeForUser ) {\n\t\tthrow new UploadError( {\n\t\t\tcode: 'MIME_TYPE_NOT_ALLOWED_FOR_USER',\n\t\t\tmessage: sprintf(\n\t\t\t\t// translators: %s: file name.\n\t\t\t\t__(\n\t\t\t\t\t'%s: Sorry, you are not allowed to upload this file type.'\n\t\t\t\t),\n\t\t\t\tfile.name\n\t\t\t),\n\t\t\tfile,\n\t\t} );\n\t}\n}\n", "/**\n * Browsers may use unexpected mime types, and they differ from browser to browser.\n * This function computes a flexible array of mime types from the mime type structured provided by the server.\n * Converts { jpg|jpeg|jpe: \"image/jpeg\" } into [ \"image/jpeg\", \"image/jpg\", \"image/jpeg\", \"image/jpe\" ]\n *\n * @param {?Object} wpMimeTypesObject Mime type object received from the server.\n *                                    Extensions are keys separated by '|' and values are mime types associated with an extension.\n *\n * @return An array of mime types or null\n */\nexport function getMimeTypesArray(\n\twpMimeTypesObject?: Record< string, string > | null\n) {\n\tif ( ! wpMimeTypesObject ) {\n\t\treturn null;\n\t}\n\treturn Object.entries( wpMimeTypesObject ).flatMap(\n\t\t( [ extensionsString, mime ] ) => {\n\t\t\tconst [ type ] = mime.split( '/' );\n\t\t\tconst extensions = extensionsString.split( '|' );\n\t\t\treturn [\n\t\t\t\tmime,\n\t\t\t\t...extensions.map(\n\t\t\t\t\t( extension ) => `${ type }/${ extension }`\n\t\t\t\t),\n\t\t\t];\n\t\t}\n\t);\n}\n", "/**\n * WordPress dependencies\n */\nimport { __, sprintf } from '@wordpress/i18n';\n\n/**\n * Internal dependencies\n */\nimport { UploadError } from './upload-error';\n\n/**\n * Verifies whether the file is within the file upload size limits for the site.\n *\n * @param file              File object.\n * @param maxUploadFileSize Maximum upload size in bytes allowed for the site.\n */\nexport function validateFileSize( file: File, maxUploadFileSize?: number ) {\n\t// Don't allow empty files to be uploaded.\n\tif ( file.size <= 0 ) {\n\t\tthrow new UploadError( {\n\t\t\tcode: 'EMPTY_FILE',\n\t\t\tmessage: sprintf(\n\t\t\t\t// translators: %s: file name.\n\t\t\t\t__( '%s: This file is empty.' ),\n\t\t\t\tfile.name\n\t\t\t),\n\t\t\tfile,\n\t\t} );\n\t}\n\n\tif ( maxUploadFileSize && file.size > maxUploadFileSize ) {\n\t\tthrow new UploadError( {\n\t\t\tcode: 'SIZE_ABOVE_LIMIT',\n\t\t\tmessage: sprintf(\n\t\t\t\t// translators: %s: file name.\n\t\t\t\t__(\n\t\t\t\t\t'%s: This file exceeds the maximum upload size for this site.'\n\t\t\t\t),\n\t\t\t\tfile.name\n\t\t\t),\n\t\t\tfile,\n\t\t} );\n\t}\n}\n", "/**\n * External dependencies\n */\nimport { v4 as uuidv4 } from 'uuid';\n\n/**\n * WordPress dependencies\n */\nimport type { createRegistry } from '@wordpress/data';\n\ntype WPDataRegistry = ReturnType< typeof createRegistry >;\n\n/**\n * Internal dependencies\n */\nimport type {\n\tAdditionalData,\n\tCancelAction,\n\tOnBatchSuccessHandler,\n\tOnChangeHandler,\n\tOnErrorHandler,\n\tOnSuccessHandler,\n\tQueueItemId,\n\tRetryItemAction,\n\tState,\n} from './types';\nimport { Type } from './types';\nimport type {\n\taddItem,\n\tprocessItem,\n\tremoveItem,\n\trevokeBlobUrls,\n} from './private-actions';\nimport { vipsCancelOperations } from './utils';\nimport { validateMimeType } from '../validate-mime-type';\nimport { validateMimeTypeForUser } from '../validate-mime-type-for-user';\nimport { validateFileSize } from '../validate-file-size';\n\ntype ActionCreators = {\n\taddItem: typeof addItem;\n\taddItems: typeof addItems;\n\tremoveItem: typeof removeItem;\n\tprocessItem: typeof processItem;\n\tcancelItem: typeof cancelItem;\n\tretryItem: typeof retryItem;\n\trevokeBlobUrls: typeof revokeBlobUrls;\n\t< T = Record< string, unknown > >( args: T ): void;\n};\n\ntype AllSelectors = typeof import('./selectors') &\n\ttypeof import('./private-selectors');\ntype CurriedState< F > = F extends ( state: State, ...args: infer P ) => infer R\n\t? ( ...args: P ) => R\n\t: F;\ntype Selectors = {\n\t[ key in keyof AllSelectors ]: CurriedState< AllSelectors[ key ] >;\n};\n\ntype ThunkArgs = {\n\tselect: Selectors;\n\tdispatch: ActionCreators;\n\tregistry: WPDataRegistry;\n};\n\ninterface AddItemsArgs {\n\tfiles: File[];\n\tonChange?: OnChangeHandler;\n\tonSuccess?: OnSuccessHandler;\n\tonBatchSuccess?: OnBatchSuccessHandler;\n\tonError?: OnErrorHandler;\n\tadditionalData?: AdditionalData;\n\tallowedTypes?: string[];\n}\n\n/**\n * Adds a new item to the upload queue.\n *\n * @param $0\n * @param $0.files            Files\n * @param [$0.onChange]       Function called each time a file or a temporary representation of the file is available.\n * @param [$0.onSuccess]      Function called after the file is uploaded.\n * @param [$0.onBatchSuccess] Function called after a batch of files is uploaded.\n * @param [$0.onError]        Function called when an error happens.\n * @param [$0.additionalData] Additional data to include in the request.\n * @param [$0.allowedTypes]   Array with the types of media that can be uploaded, if unset all types are allowed.\n */\nexport function addItems( {\n\tfiles,\n\tonChange,\n\tonSuccess,\n\tonError,\n\tonBatchSuccess,\n\tadditionalData,\n\tallowedTypes,\n}: AddItemsArgs ) {\n\treturn async ( { select, dispatch }: ThunkArgs ) => {\n\t\tconst batchId = uuidv4();\n\t\tfor ( const file of files ) {\n\t\t\t/*\n\t\t\t Check if the caller (e.g. a block) supports this mime type.\n\t\t\t Special case for file types such as HEIC which will be converted before upload anyway.\n\t\t\t Another check will be done before upload.\n\t\t\t*/\n\t\t\ttry {\n\t\t\t\tvalidateMimeType( file, allowedTypes );\n\t\t\t\tvalidateMimeTypeForUser(\n\t\t\t\t\tfile,\n\t\t\t\t\tselect.getSettings().allowedMimeTypes\n\t\t\t\t);\n\t\t\t} catch ( error: unknown ) {\n\t\t\t\tonError?.( error as Error );\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tvalidateFileSize(\n\t\t\t\t\tfile,\n\t\t\t\t\tselect.getSettings().maxUploadFileSize\n\t\t\t\t);\n\t\t\t} catch ( error: unknown ) {\n\t\t\t\tonError?.( error as Error );\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdispatch.addItem( {\n\t\t\t\tfile,\n\t\t\t\tbatchId,\n\t\t\t\tonChange,\n\t\t\t\tonSuccess,\n\t\t\t\tonBatchSuccess,\n\t\t\t\tonError,\n\t\t\t\tadditionalData,\n\t\t\t} );\n\t\t}\n\t};\n}\n\n/**\n * Cancels an item in the queue based on an error.\n *\n * @param id     Item ID.\n * @param error  Error instance.\n * @param silent Whether to cancel the item silently,\n *               without invoking its `onError` callback.\n */\nexport function cancelItem( id: QueueItemId, error: Error, silent = false ) {\n\treturn async ( { select, dispatch }: ThunkArgs ) => {\n\t\tconst item = select.getItem( id );\n\n\t\tif ( ! item ) {\n\t\t\t/*\n\t\t\t * Do nothing if item has already been removed.\n\t\t\t * This can happen if an upload is cancelled manually\n\t\t\t * while transcoding with vips is still in progress.\n\t\t\t * Then, cancelItem() is once invoked manually and once\n\t\t\t * by the error handler in optimizeImageItem().\n\t\t\t */\n\t\t\treturn;\n\t\t}\n\n\t\titem.abortController?.abort();\n\n\t\t// Cancel any ongoing vips operations for this item.\n\t\tawait vipsCancelOperations( id );\n\n\t\tif ( ! silent ) {\n\t\t\tconst { onError } = item;\n\t\t\tonError?.( error ?? new Error( 'Upload cancelled' ) );\n\t\t\tif ( ! onError && error ) {\n\t\t\t\t// TODO: Find better way to surface errors with sideloads etc.\n\t\t\t\t// eslint-disable-next-line no-console -- Deliberately log errors here.\n\t\t\t\tconsole.error( 'Upload cancelled', error );\n\t\t\t}\n\t\t}\n\n\t\tdispatch< CancelAction >( {\n\t\t\ttype: Type.Cancel,\n\t\t\tid,\n\t\t\terror,\n\t\t} );\n\t\tdispatch.removeItem( id );\n\t\tdispatch.revokeBlobUrls( id );\n\n\t\t// All items of this batch were cancelled or finished.\n\t\tif ( item.batchId && select.isBatchUploaded( item.batchId ) ) {\n\t\t\titem.onBatchSuccess?.();\n\t\t}\n\t};\n}\n\n/**\n * Retries a failed item in the queue.\n *\n * @param id Item ID.\n */\nexport function retryItem( id: QueueItemId ) {\n\treturn async ( { select, dispatch }: ThunkArgs ) => {\n\t\tconst item = select.getItem( id );\n\n\t\tif ( ! item ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Only retry items that have an error.\n\t\tif ( ! item.error ) {\n\t\t\treturn;\n\t\t}\n\n\t\tdispatch< RetryItemAction >( {\n\t\t\ttype: Type.RetryItem,\n\t\t\tid,\n\t\t} );\n\n\t\tdispatch.processItem( id );\n\t};\n}\n", "/**\n * External dependencies\n */\nimport { v4 as uuidv4 } from 'uuid';\n\n/**\n * WordPress dependencies\n */\nimport { createBlobURL, isBlobURL, revokeBlobURL } from '@wordpress/blob';\nimport type { createRegistry } from '@wordpress/data';\n\ntype WPDataRegistry = ReturnType< typeof createRegistry >;\n\n/**\n * Internal dependencies\n */\nimport { cloneFile, convertBlobToFile, renameFile } from '../utils';\nimport { CLIENT_SIDE_SUPPORTED_MIME_TYPES } from './constants';\nimport { StubFile } from '../stub-file';\nimport { UploadError } from '../upload-error';\nimport {\n\tvipsResizeImage,\n\tvipsRotateImage,\n\tvipsConvertImageFormat,\n\tvipsHasTransparency,\n\tterminateVipsWorker,\n} from './utils';\nimport type {\n\tAddAction,\n\tAdditionalData,\n\tAddOperationsAction,\n\tBatchId,\n\tCacheBlobUrlAction,\n\tImageFormat,\n\tOnBatchSuccessHandler,\n\tOnChangeHandler,\n\tOnErrorHandler,\n\tOnSuccessHandler,\n\tOperation,\n\tOperationArgs,\n\tOperationFinishAction,\n\tOperationStartAction,\n\tPauseItemAction,\n\tPauseQueueAction,\n\tQueueItem,\n\tQueueItemId,\n\tResumeItemAction,\n\tResumeQueueAction,\n\tRevokeBlobUrlsAction,\n\tSideloadAdditionalData,\n\tSettings,\n\tState,\n\tUpdateProgressAction,\n\tUpdateSettingsAction,\n} from './types';\nimport { ItemStatus, OperationType, Type } from './types';\nimport type { cancelItem } from './actions';\n\nconst DEFAULT_OUTPUT_QUALITY = 0.82;\n\ntype ActionCreators = {\n\tcancelItem: typeof cancelItem;\n\taddItem: typeof addItem;\n\taddSideloadItem: typeof addSideloadItem;\n\tremoveItem: typeof removeItem;\n\tpauseItem: typeof pauseItem;\n\tresumeItemByPostId: typeof resumeItemByPostId;\n\tprepareItem: typeof prepareItem;\n\tprocessItem: typeof processItem;\n\tfinishOperation: typeof finishOperation;\n\tuploadItem: typeof uploadItem;\n\tsideloadItem: typeof sideloadItem;\n\tresizeCropItem: typeof resizeCropItem;\n\trotateItem: typeof rotateItem;\n\ttranscodeImageItem: typeof transcodeImageItem;\n\tgenerateThumbnails: typeof generateThumbnails;\n\tupdateItemProgress: typeof updateItemProgress;\n\trevokeBlobUrls: typeof revokeBlobUrls;\n\t< T = Record< string, unknown > >( args: T ): void;\n};\n\ntype AllSelectors = typeof import('./selectors') &\n\ttypeof import('./private-selectors');\ntype CurriedState< F > = F extends ( state: State, ...args: infer P ) => infer R\n\t? ( ...args: P ) => R\n\t: F;\ntype Selectors = {\n\t[ key in keyof AllSelectors ]: CurriedState< AllSelectors[ key ] >;\n};\n\ntype ThunkArgs = {\n\tselect: Selectors;\n\tdispatch: ActionCreators;\n\tregistry: WPDataRegistry;\n};\n\n/**\n * Determines if an upload should be paused to avoid race conditions.\n *\n * When sideloading thumbnails, we need to pause uploads if another\n * upload to the same post is already in progress.\n *\n * @param item      Queue item to check.\n * @param operation Current operation type.\n * @param select    Store selectors.\n * @return Whether the upload should be paused.\n */\nfunction shouldPauseForSideload(\n\titem: QueueItem,\n\toperation: OperationType | undefined,\n\tselect: Selectors\n): boolean {\n\tif (\n\t\toperation !== OperationType.Upload ||\n\t\t! item.parentId ||\n\t\t! item.additionalData.post\n\t) {\n\t\treturn false;\n\t}\n\treturn select.isUploadingToPost( item.additionalData.post as number );\n}\n\ninterface AddItemArgs {\n\t// It should always be a File, but some consumers might still pass Blobs only.\n\tfile: File | Blob;\n\tbatchId?: BatchId;\n\tonChange?: OnChangeHandler;\n\tonSuccess?: OnSuccessHandler;\n\tonError?: OnErrorHandler;\n\tonBatchSuccess?: OnBatchSuccessHandler;\n\tadditionalData?: AdditionalData;\n\tsourceUrl?: string;\n\tsourceAttachmentId?: number;\n\tabortController?: AbortController;\n\toperations?: Operation[];\n}\n\n/**\n * Adds a new item to the upload queue.\n *\n * @param $0\n * @param $0.file                 File\n * @param [$0.batchId]            Batch ID.\n * @param [$0.onChange]           Function called each time a file or a temporary representation of the file is available.\n * @param [$0.onSuccess]          Function called after the file is uploaded.\n * @param [$0.onBatchSuccess]     Function called after a batch of files is uploaded.\n * @param [$0.onError]            Function called when an error happens.\n * @param [$0.additionalData]     Additional data to include in the request.\n * @param [$0.sourceUrl]          Source URL. Used when importing a file from a URL or optimizing an existing file.\n * @param [$0.sourceAttachmentId] Source attachment ID. Used when optimizing an existing file for example.\n * @param [$0.abortController]    Abort controller for upload cancellation.\n * @param [$0.operations]         List of operations to perform. Defaults to automatically determined list, based on the file.\n */\nexport function addItem( {\n\tfile: fileOrBlob,\n\tbatchId,\n\tonChange,\n\tonSuccess,\n\tonBatchSuccess,\n\tonError,\n\tadditionalData = {} as AdditionalData,\n\tsourceUrl,\n\tsourceAttachmentId,\n\tabortController,\n\toperations,\n}: AddItemArgs ) {\n\treturn async ( { dispatch }: ThunkArgs ) => {\n\t\tconst itemId = uuidv4();\n\n\t\t// Hardening in case a Blob is passed instead of a File.\n\t\t// See https://github.com/WordPress/gutenberg/pull/65693 for an example.\n\t\tconst file = convertBlobToFile( fileOrBlob );\n\n\t\tlet blobUrl;\n\n\t\t// StubFile could be coming from addItemFromUrl().\n\t\tif ( ! ( file instanceof StubFile ) ) {\n\t\t\tblobUrl = createBlobURL( file );\n\t\t\tdispatch< CacheBlobUrlAction >( {\n\t\t\t\ttype: Type.CacheBlobUrl,\n\t\t\t\tid: itemId,\n\t\t\t\tblobUrl,\n\t\t\t} );\n\t\t}\n\n\t\tdispatch< AddAction >( {\n\t\t\ttype: Type.Add,\n\t\t\titem: {\n\t\t\t\tid: itemId,\n\t\t\t\tbatchId,\n\t\t\t\tstatus: ItemStatus.Processing,\n\t\t\t\tsourceFile: cloneFile( file ),\n\t\t\t\tfile,\n\t\t\t\tattachment: {\n\t\t\t\t\turl: blobUrl,\n\t\t\t\t},\n\t\t\t\tadditionalData: {\n\t\t\t\t\tconvert_format: false,\n\t\t\t\t\tgenerate_sub_sizes: false,\n\t\t\t\t\t...additionalData,\n\t\t\t\t},\n\t\t\t\tonChange,\n\t\t\t\tonSuccess,\n\t\t\t\tonBatchSuccess,\n\t\t\t\tonError,\n\t\t\t\tsourceUrl,\n\t\t\t\tsourceAttachmentId,\n\t\t\t\tabortController: abortController || new AbortController(),\n\t\t\t\toperations: Array.isArray( operations )\n\t\t\t\t\t? operations\n\t\t\t\t\t: [ OperationType.Prepare ],\n\t\t\t},\n\t\t} );\n\n\t\tdispatch.processItem( itemId );\n\t};\n}\n\ninterface AddSideloadItemArgs {\n\tfile: File;\n\tonChange?: OnChangeHandler;\n\tadditionalData?: AdditionalData;\n\toperations?: Operation[];\n\tbatchId?: BatchId;\n\tparentId?: QueueItemId;\n}\n\n/**\n * Adds a new item to the upload queue for sideloading.\n *\n * This is typically a client-side generated thumbnail.\n *\n * @param $0\n * @param $0.file             File\n * @param [$0.batchId]        Batch ID.\n * @param [$0.parentId]       Parent ID.\n * @param [$0.onChange]       Function called each time a file or a temporary representation of the file is available.\n * @param [$0.additionalData] Additional data to include in the request.\n * @param [$0.operations]     List of operations to perform. Defaults to automatically determined list, based on the file.\n */\nexport function addSideloadItem( {\n\tfile,\n\tonChange,\n\tadditionalData,\n\toperations,\n\tbatchId,\n\tparentId,\n}: AddSideloadItemArgs ) {\n\treturn ( { dispatch }: ThunkArgs ) => {\n\t\tconst itemId = uuidv4();\n\t\tdispatch< AddAction >( {\n\t\t\ttype: Type.Add,\n\t\t\titem: {\n\t\t\t\tid: itemId,\n\t\t\t\tbatchId,\n\t\t\t\tstatus: ItemStatus.Processing,\n\t\t\t\tsourceFile: cloneFile( file ),\n\t\t\t\tfile,\n\t\t\t\tonChange,\n\t\t\t\tadditionalData: {\n\t\t\t\t\t...additionalData,\n\t\t\t\t},\n\t\t\t\tparentId,\n\t\t\t\toperations: Array.isArray( operations )\n\t\t\t\t\t? operations\n\t\t\t\t\t: [ OperationType.Prepare ],\n\t\t\t\tabortController: new AbortController(),\n\t\t\t},\n\t\t} );\n\n\t\tdispatch.processItem( itemId );\n\t};\n}\n\n/**\n * Processes a single item in the queue.\n *\n * Runs the next operation in line and invokes any callbacks.\n *\n * @param id Item ID.\n */\nexport function processItem( id: QueueItemId ) {\n\treturn async ( { select, dispatch }: ThunkArgs ) => {\n\t\tif ( select.isPaused() ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst item = select.getItem( id );\n\t\tif ( ! item ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst {\n\t\t\tattachment,\n\t\t\tonChange,\n\t\t\tonSuccess,\n\t\t\tonBatchSuccess,\n\t\t\tbatchId,\n\t\t\tparentId,\n\t\t} = item;\n\n\t\tconst operation = Array.isArray( item.operations?.[ 0 ] )\n\t\t\t? item.operations[ 0 ][ 0 ]\n\t\t\t: item.operations?.[ 0 ];\n\t\tconst operationArgs = Array.isArray( item.operations?.[ 0 ] )\n\t\t\t? item.operations[ 0 ][ 1 ]\n\t\t\t: undefined;\n\n\t\t// If we're sideloading a thumbnail, pause upload to avoid race conditions.\n\t\t// It will be resumed after the previous upload finishes.\n\t\tif ( shouldPauseForSideload( item, operation, select ) ) {\n\t\t\tdispatch< PauseItemAction >( {\n\t\t\t\ttype: Type.PauseItem,\n\t\t\t\tid,\n\t\t\t} );\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * If the next operation is an upload, check concurrency limit.\n\t\t * If at capacity, the item remains queued and will be processed\n\t\t * when another upload completes.\n\t\t */\n\t\tif ( operation === OperationType.Upload ) {\n\t\t\tconst settings = select.getSettings();\n\t\t\tconst activeCount = select.getActiveUploadCount();\n\t\t\tif ( activeCount >= settings.maxConcurrentUploads ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If the next operation is image processing (resize/crop/rotate),\n\t\t * check the image processing concurrency limit.\n\t\t * If at capacity, the item remains queued and will be processed\n\t\t * when another image processing operation completes.\n\t\t */\n\t\tif (\n\t\t\toperation === OperationType.ResizeCrop ||\n\t\t\toperation === OperationType.Rotate\n\t\t) {\n\t\t\tconst settings = select.getSettings();\n\t\t\tconst activeCount = select.getActiveImageProcessingCount();\n\t\t\tif ( activeCount >= settings.maxConcurrentImageProcessing ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif ( attachment ) {\n\t\t\tonChange?.( [ attachment ] );\n\t\t}\n\n\t\t/*\n\t\t If there are no more operations, the item can be removed from the queue,\n\t\t but only if there are no thumbnails still being side-loaded,\n\t\t or if itself is a side-loaded item.\n\t\t*/\n\n\t\tif ( ! operation ) {\n\t\t\tif (\n\t\t\t\tparentId ||\n\t\t\t\t( ! parentId && ! select.hasPendingItemsByParentId( id ) )\n\t\t\t) {\n\t\t\t\tif ( attachment ) {\n\t\t\t\t\tonSuccess?.( [ attachment ] );\n\t\t\t\t}\n\n\t\t\t\tdispatch.removeItem( id );\n\t\t\t\tdispatch.revokeBlobUrls( id );\n\n\t\t\t\tif ( batchId && select.isBatchUploaded( batchId ) ) {\n\t\t\t\t\tonBatchSuccess?.();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// All other side-loaded items have been removed, so remove the parent too.\n\t\t\tif ( parentId && batchId && select.isBatchUploaded( batchId ) ) {\n\t\t\t\tconst parentItem = select.getItem( parentId ) as QueueItem;\n\t\t\t\tif ( ! parentItem ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif ( attachment ) {\n\t\t\t\t\tparentItem.onSuccess?.( [ attachment ] );\n\t\t\t\t}\n\n\t\t\t\tdispatch.removeItem( parentId );\n\t\t\t\tdispatch.revokeBlobUrls( parentId );\n\n\t\t\t\tif (\n\t\t\t\t\tparentItem.batchId &&\n\t\t\t\t\tselect.isBatchUploaded( parentItem.batchId )\n\t\t\t\t) {\n\t\t\t\t\tparentItem.onBatchSuccess?.();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t At this point we are dealing with a parent whose children haven't fully uploaded yet.\n\t\t\t Do nothing and let the removal happen once the last side-loaded item finishes.\n\t\t\t */\n\n\t\t\treturn;\n\t\t}\n\n\t\tdispatch< OperationStartAction >( {\n\t\t\ttype: Type.OperationStart,\n\t\t\tid,\n\t\t\toperation,\n\t\t} );\n\n\t\tswitch ( operation ) {\n\t\t\tcase OperationType.Prepare:\n\t\t\t\tdispatch.prepareItem( item.id );\n\t\t\t\tbreak;\n\n\t\t\tcase OperationType.ResizeCrop:\n\t\t\t\tdispatch.resizeCropItem(\n\t\t\t\t\titem.id,\n\t\t\t\t\toperationArgs as OperationArgs[ OperationType.ResizeCrop ]\n\t\t\t\t);\n\t\t\t\tbreak;\n\n\t\t\tcase OperationType.Rotate:\n\t\t\t\tdispatch.rotateItem(\n\t\t\t\t\titem.id,\n\t\t\t\t\toperationArgs as OperationArgs[ OperationType.Rotate ]\n\t\t\t\t);\n\t\t\t\tbreak;\n\n\t\t\tcase OperationType.TranscodeImage:\n\t\t\t\tdispatch.transcodeImageItem(\n\t\t\t\t\titem.id,\n\t\t\t\t\toperationArgs as OperationArgs[ OperationType.TranscodeImage ]\n\t\t\t\t);\n\t\t\t\tbreak;\n\n\t\t\tcase OperationType.Upload:\n\t\t\t\tif ( item.parentId ) {\n\t\t\t\t\tdispatch.sideloadItem( id );\n\t\t\t\t} else {\n\t\t\t\t\tdispatch.uploadItem( id );\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase OperationType.ThumbnailGeneration:\n\t\t\t\tdispatch.generateThumbnails( id );\n\t\t\t\tbreak;\n\t\t}\n\t};\n}\n\n/**\n * Returns an action object that pauses all processing in the queue.\n *\n * Useful for testing purposes.\n *\n * @return Action object.\n */\nexport function pauseQueue(): PauseQueueAction {\n\treturn {\n\t\ttype: Type.PauseQueue,\n\t};\n}\n\n/**\n * Resumes all processing in the queue.\n *\n * Dispatches an action object for resuming the queue itself,\n * and triggers processing for each remaining item in the queue individually.\n */\nexport function resumeQueue() {\n\treturn async ( { select, dispatch }: ThunkArgs ) => {\n\t\tdispatch< ResumeQueueAction >( {\n\t\t\ttype: Type.ResumeQueue,\n\t\t} );\n\n\t\tfor ( const item of select.getAllItems() ) {\n\t\t\tdispatch.processItem( item.id );\n\t\t}\n\t};\n}\n\n/**\n * Pauses a specific item in the queue.\n *\n * @param id Item ID.\n */\nexport function pauseItem( id: QueueItemId ) {\n\treturn async ( { dispatch }: ThunkArgs ) => {\n\t\tdispatch< PauseItemAction >( {\n\t\t\ttype: Type.PauseItem,\n\t\t\tid,\n\t\t} );\n\t};\n}\n\n/**\n * Resumes processing for a given post/attachment ID.\n *\n * This function looks up paused uploads by post ID and resumes them.\n * It's typically called after a sideload completes to resume paused\n * thumbnail uploads.\n *\n * @param postOrAttachmentId Post or attachment ID.\n */\nexport function resumeItemByPostId( postOrAttachmentId: number ) {\n\treturn async ( { select, dispatch }: ThunkArgs ) => {\n\t\tconst item = select.getPausedUploadForPost( postOrAttachmentId );\n\t\tif ( item ) {\n\t\t\tdispatch< ResumeItemAction >( {\n\t\t\t\ttype: Type.ResumeItem,\n\t\t\t\tid: item.id,\n\t\t\t} );\n\t\t\tdispatch.processItem( item.id );\n\t\t}\n\t};\n}\n\n/**\n * Removes a specific item from the queue.\n *\n * @param id Item ID.\n */\nexport function removeItem( id: QueueItemId ) {\n\treturn async ( { select, dispatch }: ThunkArgs ) => {\n\t\tconst item = select.getItem( id );\n\t\tif ( ! item ) {\n\t\t\treturn;\n\t\t}\n\n\t\tdispatch( {\n\t\t\ttype: Type.Remove,\n\t\t\tid,\n\t\t} );\n\n\t\t/*\n\t\t * If the queue is now empty, terminate the VIPS worker to free\n\t\t * WASM memory. The worker will be lazily re-created if needed.\n\t\t */\n\t\tif ( select.getAllItems().length === 0 ) {\n\t\t\tterminateVipsWorker();\n\t\t}\n\t};\n}\n\n/**\n * Finishes an operation for a given item ID and immediately triggers processing the next one.\n *\n * @param id      Item ID.\n * @param updates Updated item data.\n */\nexport function finishOperation(\n\tid: QueueItemId,\n\tupdates: Partial< QueueItem >\n) {\n\treturn async ( { select, dispatch }: ThunkArgs ) => {\n\t\tconst item = select.getItem( id );\n\t\tconst previousOperation = item?.currentOperation;\n\n\t\tdispatch< OperationFinishAction >( {\n\t\t\ttype: Type.OperationFinish,\n\t\t\tid,\n\t\t\titem: updates,\n\t\t} );\n\n\t\tdispatch.processItem( id );\n\n\t\t/*\n\t\t * If an upload just finished, there may be items waiting in the queue\n\t\t * due to concurrency limits. Trigger processing for them.\n\t\t */\n\t\tif ( previousOperation === OperationType.Upload ) {\n\t\t\tconst pendingUploads = select.getPendingUploads();\n\t\t\tfor ( const pendingItem of pendingUploads ) {\n\t\t\t\tdispatch.processItem( pendingItem.id );\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If an image processing operation just finished, there may be items\n\t\t * waiting in the queue due to the image processing concurrency limit.\n\t\t * Trigger processing for them.\n\t\t */\n\t\tif (\n\t\t\tpreviousOperation === OperationType.ResizeCrop ||\n\t\t\tpreviousOperation === OperationType.Rotate\n\t\t) {\n\t\t\tconst pendingItems = select.getPendingImageProcessing();\n\t\t\tfor ( const pendingItem of pendingItems ) {\n\t\t\t\tdispatch.processItem( pendingItem.id );\n\t\t\t}\n\t\t}\n\t};\n}\n\nconst VALID_IMAGE_FORMATS = [ 'jpeg', 'webp', 'avif', 'png', 'gif' ] as const;\n\n/**\n * Checks if a format string is a valid ImageFormat.\n *\n * @param format The format string to validate.\n * @return Whether the format is valid.\n */\nfunction isValidImageFormat( format: string ): format is ImageFormat {\n\treturn VALID_IMAGE_FORMATS.includes( format as ImageFormat );\n}\n\n/**\n * Gets the appropriate interlace setting for the given output format.\n *\n * @param outputMimeType The output mime type.\n * @param settings       The upload settings.\n * @return Whether to use interlaced encoding.\n */\nfunction getInterlacedSetting(\n\toutputMimeType: string,\n\tsettings: Settings\n): boolean {\n\tswitch ( outputMimeType ) {\n\t\tcase 'image/jpeg':\n\t\t\treturn settings.jpegInterlaced ?? false;\n\t\tcase 'image/png':\n\t\t\treturn settings.pngInterlaced ?? false;\n\t\tcase 'image/gif':\n\t\t\treturn settings.gifInterlaced ?? false;\n\t\tdefault:\n\t\t\treturn false;\n\t}\n}\n\n/**\n * Determines if an image should be transcoded to a different format.\n *\n * Handles PNG to JPEG conversion carefully by checking for transparency\n * to preserve the alpha channel when needed.\n *\n * @param file           The image file.\n * @param outputMimeType The target output MIME type.\n * @param settings       Media settings.\n * @return The transcode operation tuple if transcoding is needed, null otherwise.\n */\nexport async function getTranscodeImageOperation(\n\tfile: File,\n\toutputMimeType: string,\n\tsettings: Settings\n): Promise<\n\t| [\n\t\t\tOperationType.TranscodeImage,\n\t\t\tOperationArgs[ OperationType.TranscodeImage ],\n\t  ]\n\t| null\n> {\n\t// For PNG -> JPEG conversion, check if the image has transparency.\n\t// If it does, skip transcoding to preserve the alpha channel.\n\tif ( file.type === 'image/png' && outputMimeType === 'image/jpeg' ) {\n\t\tconst blobUrl = createBlobURL( file );\n\t\ttry {\n\t\t\tconst hasAlpha = await vipsHasTransparency( blobUrl );\n\t\t\tif ( hasAlpha ) {\n\t\t\t\t// Image has transparency, skip conversion to JPEG.\n\t\t\t\treturn null;\n\t\t\t}\n\t\t} catch {\n\t\t\t// If transparency check fails, err on the side of caution.\n\t\t\treturn null;\n\t\t} finally {\n\t\t\trevokeBlobURL( blobUrl );\n\t\t}\n\t}\n\n\tconst formatPart = outputMimeType.split( '/' )[ 1 ];\n\tif ( ! isValidImageFormat( formatPart ) ) {\n\t\t// Unknown format, skip transcoding.\n\t\treturn null;\n\t}\n\n\treturn [\n\t\tOperationType.TranscodeImage,\n\t\t{\n\t\t\toutputFormat: formatPart,\n\t\t\toutputQuality: DEFAULT_OUTPUT_QUALITY,\n\t\t\tinterlaced: getInterlacedSetting( outputMimeType, settings ),\n\t\t},\n\t];\n}\n\n/**\n * Prepares an item for initial processing.\n *\n * Determines the list of operations to perform for a given image,\n * depending on its media type.\n *\n * For example, HEIF images first need to be converted, resized,\n * compressed, and then uploaded.\n *\n * Or videos need to be compressed, and then need poster generation\n * before upload.\n *\n * @param id Item ID.\n */\nexport function prepareItem( id: QueueItemId ) {\n\treturn async ( { select, dispatch }: ThunkArgs ) => {\n\t\tconst item = select.getItem( id );\n\t\tif ( ! item ) {\n\t\t\treturn;\n\t\t}\n\t\tconst { file } = item;\n\n\t\tconst operations: Operation[] = [];\n\t\tconst settings = select.getSettings();\n\n\t\tconst isImage = file.type.startsWith( 'image/' );\n\t\tconst isVipsSupported = CLIENT_SIDE_SUPPORTED_MIME_TYPES.includes(\n\t\t\tfile.type\n\t\t);\n\n\t\t// For images that can be processed by vips, check if we need to scale down based on threshold.\n\t\tif ( isImage && isVipsSupported ) {\n\t\t\tconst { bigImageSizeThreshold, imageOutputFormats } = settings;\n\n\t\t\t// If a threshold is set, add a resize operation to scale down large images.\n\t\t\t// This matches WordPress core's behavior in wp_create_image_subsizes().\n\t\t\tif ( bigImageSizeThreshold ) {\n\t\t\t\toperations.push( [\n\t\t\t\t\tOperationType.ResizeCrop,\n\t\t\t\t\t{\n\t\t\t\t\t\tresize: {\n\t\t\t\t\t\t\twidth: bigImageSizeThreshold,\n\t\t\t\t\t\t\theight: bigImageSizeThreshold,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tisThresholdResize: true,\n\t\t\t\t\t},\n\t\t\t\t] );\n\t\t\t}\n\n\t\t\t// Check if we need to transcode to a different format.\n\t\t\t// Uses WordPress image_editor_output_format filter settings.\n\t\t\tconst outputMimeType = imageOutputFormats?.[ file.type ];\n\t\t\tif ( outputMimeType && outputMimeType !== file.type ) {\n\t\t\t\tconst transcodeOperation = await getTranscodeImageOperation(\n\t\t\t\t\tfile,\n\t\t\t\t\toutputMimeType,\n\t\t\t\t\tsettings\n\t\t\t\t);\n\t\t\t\tif ( transcodeOperation ) {\n\t\t\t\t\toperations.push( transcodeOperation );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\toperations.push(\n\t\t\t\tOperationType.Upload,\n\t\t\t\tOperationType.ThumbnailGeneration\n\t\t\t);\n\t\t} else {\n\t\t\toperations.push( OperationType.Upload );\n\t\t}\n\n\t\tdispatch< AddOperationsAction >( {\n\t\t\ttype: Type.AddOperations,\n\t\t\tid,\n\t\t\toperations,\n\t\t} );\n\n\t\t// If the file is not processed by vips, tell the server to\n\t\t// generate sub-sizes since they won't be created client-side.\n\t\tconst updates =\n\t\t\t! isVipsSupported || ! isImage\n\t\t\t\t? {\n\t\t\t\t\t\tadditionalData: {\n\t\t\t\t\t\t\t...item.additionalData,\n\t\t\t\t\t\t\tgenerate_sub_sizes: true,\n\t\t\t\t\t\t},\n\t\t\t\t  }\n\t\t\t\t: {};\n\n\t\tdispatch.finishOperation( id, updates );\n\t};\n}\n\n/**\n * Uploads an item to the server.\n *\n * @param id Item ID.\n */\nexport function uploadItem( id: QueueItemId ) {\n\treturn async ( { select, dispatch }: ThunkArgs ) => {\n\t\tconst item = select.getItem( id );\n\t\tif ( ! item ) {\n\t\t\treturn;\n\t\t}\n\n\t\tselect.getSettings().mediaUpload( {\n\t\t\tfilesList: [ item.file ],\n\t\t\tadditionalData: item.additionalData,\n\t\t\tsignal: item.abortController?.signal,\n\t\t\tonFileChange: ( [ attachment ] ) => {\n\t\t\t\tif ( ! isBlobURL( attachment.url ) ) {\n\t\t\t\t\tdispatch.finishOperation( id, {\n\t\t\t\t\t\tattachment,\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t},\n\t\t\tonSuccess: ( [ attachment ] ) => {\n\t\t\t\tdispatch.finishOperation( id, {\n\t\t\t\t\tattachment,\n\t\t\t\t} );\n\t\t\t},\n\t\t\tonError: ( error ) => {\n\t\t\t\tdispatch.cancelItem( id, error );\n\t\t\t},\n\t\t} );\n\t};\n}\n\n/**\n * Sideloads an item to the server.\n *\n * @param id Item ID.\n */\nexport function sideloadItem( id: QueueItemId ) {\n\treturn async ( { select, dispatch }: ThunkArgs ) => {\n\t\tconst item = select.getItem( id );\n\t\tif ( ! item ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst { post, ...additionalData } =\n\t\t\titem.additionalData as SideloadAdditionalData;\n\n\t\tconst mediaSideload = select.getSettings().mediaSideload;\n\t\tif ( ! mediaSideload ) {\n\t\t\t// If sideloading is not supported, skip this operation.\n\t\t\tdispatch.finishOperation( id, {} );\n\t\t\treturn;\n\t\t}\n\n\t\tmediaSideload( {\n\t\t\tfile: item.file,\n\t\t\tattachmentId: post as number,\n\t\t\tadditionalData,\n\t\t\tsignal: item.abortController?.signal,\n\t\t\tonFileChange: ( [ attachment ] ) => {\n\t\t\t\tdispatch.finishOperation( id, { attachment } );\n\t\t\t\tdispatch.resumeItemByPostId( post as number );\n\t\t\t},\n\t\t\tonError: ( error ) => {\n\t\t\t\tdispatch.cancelItem( id, error );\n\t\t\t\tdispatch.resumeItemByPostId( post as number );\n\t\t\t},\n\t\t} );\n\t};\n}\n\ntype ResizeCropItemArgs = OperationArgs[ OperationType.ResizeCrop ];\n\n/**\n * Resizes and crops an existing image item.\n *\n * @param id     Item ID.\n * @param [args] Additional arguments for the operation.\n */\nexport function resizeCropItem( id: QueueItemId, args?: ResizeCropItemArgs ) {\n\treturn async ( { select, dispatch }: ThunkArgs ) => {\n\t\tconst item = select.getItem( id );\n\t\tif ( ! item ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( ! args?.resize ) {\n\t\t\tdispatch.finishOperation( id, {\n\t\t\t\tfile: item.file,\n\t\t\t} );\n\t\t\treturn;\n\t\t}\n\n\t\t// Add dimension suffix for sub-sizes (thumbnails).\n\t\tconst addSuffix = Boolean( item.parentId );\n\t\t// Add '-scaled' suffix for big image threshold resizing.\n\t\tconst scaledSuffix = Boolean( args.isThresholdResize );\n\n\t\ttry {\n\t\t\tconst file = await vipsResizeImage(\n\t\t\t\titem.id,\n\t\t\t\titem.file,\n\t\t\t\targs.resize,\n\t\t\t\tfalse, // smartCrop\n\t\t\t\taddSuffix,\n\t\t\t\titem.abortController?.signal,\n\t\t\t\tscaledSuffix\n\t\t\t);\n\n\t\t\tconst blobUrl = createBlobURL( file );\n\t\t\tdispatch< CacheBlobUrlAction >( {\n\t\t\t\ttype: Type.CacheBlobUrl,\n\t\t\t\tid,\n\t\t\t\tblobUrl,\n\t\t\t} );\n\n\t\t\tdispatch.finishOperation( id, {\n\t\t\t\tfile,\n\t\t\t\tattachment: {\n\t\t\t\t\turl: blobUrl,\n\t\t\t\t},\n\t\t\t} );\n\t\t} catch ( error ) {\n\t\t\tdispatch.cancelItem(\n\t\t\t\tid,\n\t\t\t\tnew UploadError( {\n\t\t\t\t\tcode: 'IMAGE_TRANSCODING_ERROR',\n\t\t\t\t\tmessage: 'File could not be uploaded',\n\t\t\t\t\tfile: item.file,\n\t\t\t\t\tcause: error instanceof Error ? error : undefined,\n\t\t\t\t} )\n\t\t\t);\n\t\t}\n\t};\n}\n\ntype RotateItemArgs = OperationArgs[ OperationType.Rotate ];\n\n/**\n * Rotates an image based on EXIF orientation.\n *\n * This is used for images that need rotation but don't need resizing\n * (i.e., smaller than the big image size threshold).\n * Matches WordPress core's behavior of creating a '-rotated' version.\n *\n * @param id     Item ID.\n * @param [args] Rotation arguments including EXIF orientation value.\n */\nexport function rotateItem( id: QueueItemId, args?: RotateItemArgs ) {\n\treturn async ( { select, dispatch }: ThunkArgs ) => {\n\t\tconst item = select.getItem( id );\n\t\tif ( ! item ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If no orientation provided or orientation is 1 (normal), skip rotation.\n\t\tif ( ! args?.orientation || args.orientation === 1 ) {\n\t\t\tdispatch.finishOperation( id, {\n\t\t\t\tfile: item.file,\n\t\t\t} );\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tconst file = await vipsRotateImage(\n\t\t\t\titem.id,\n\t\t\t\titem.file,\n\t\t\t\targs.orientation,\n\t\t\t\titem.abortController?.signal\n\t\t\t);\n\n\t\t\tconst blobUrl = createBlobURL( file );\n\t\t\tdispatch< CacheBlobUrlAction >( {\n\t\t\t\ttype: Type.CacheBlobUrl,\n\t\t\t\tid,\n\t\t\t\tblobUrl,\n\t\t\t} );\n\n\t\t\tdispatch.finishOperation( id, {\n\t\t\t\tfile,\n\t\t\t\tattachment: {\n\t\t\t\t\turl: blobUrl,\n\t\t\t\t},\n\t\t\t} );\n\t\t} catch ( error ) {\n\t\t\tdispatch.cancelItem(\n\t\t\t\tid,\n\t\t\t\tnew UploadError( {\n\t\t\t\t\tcode: 'IMAGE_ROTATION_ERROR',\n\t\t\t\t\tmessage: 'Image could not be rotated',\n\t\t\t\t\tfile: item.file,\n\t\t\t\t\tcause: error instanceof Error ? error : undefined,\n\t\t\t\t} )\n\t\t\t);\n\t\t}\n\t};\n}\n\ntype TranscodeImageItemArgs = OperationArgs[ OperationType.TranscodeImage ];\n\n/**\n * Transcodes an image to a different format.\n *\n * This operation converts images between formats (e.g., PNG to WebP, JPEG to AVIF)\n * based on the WordPress image_editor_output_format filter settings.\n *\n * @param id     Item ID.\n * @param [args] Transcode arguments including output format, quality, and interlace settings.\n */\nexport function transcodeImageItem(\n\tid: QueueItemId,\n\targs?: TranscodeImageItemArgs\n) {\n\treturn async ( { select, dispatch }: ThunkArgs ) => {\n\t\tconst item = select.getItem( id );\n\t\tif ( ! item ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If no output format specified, skip transcoding.\n\t\tif ( ! args?.outputFormat ) {\n\t\t\tdispatch.finishOperation( id, {\n\t\t\t\tfile: item.file,\n\t\t\t} );\n\t\t\treturn;\n\t\t}\n\n\t\tconst outputMimeType = `image/${ args.outputFormat }` as\n\t\t\t| 'image/jpeg'\n\t\t\t| 'image/png'\n\t\t\t| 'image/webp'\n\t\t\t| 'image/avif'\n\t\t\t| 'image/gif';\n\t\tconst quality = args.outputQuality ?? DEFAULT_OUTPUT_QUALITY;\n\t\tconst interlaced = args.interlaced ?? false;\n\n\t\ttry {\n\t\t\tconst file = await vipsConvertImageFormat(\n\t\t\t\titem.id,\n\t\t\t\titem.file,\n\t\t\t\toutputMimeType,\n\t\t\t\tquality,\n\t\t\t\tinterlaced\n\t\t\t);\n\n\t\t\tconst blobUrl = createBlobURL( file );\n\t\t\tdispatch< CacheBlobUrlAction >( {\n\t\t\t\ttype: Type.CacheBlobUrl,\n\t\t\t\tid,\n\t\t\t\tblobUrl,\n\t\t\t} );\n\n\t\t\tdispatch.finishOperation( id, {\n\t\t\t\tfile,\n\t\t\t\tattachment: {\n\t\t\t\t\turl: blobUrl,\n\t\t\t\t},\n\t\t\t} );\n\t\t} catch ( error ) {\n\t\t\tdispatch.cancelItem(\n\t\t\t\tid,\n\t\t\t\tnew UploadError( {\n\t\t\t\t\tcode: 'MEDIA_TRANSCODING_ERROR',\n\t\t\t\t\tmessage:\n\t\t\t\t\t\t'Image could not be transcoded to the target format',\n\t\t\t\t\tfile: item.file,\n\t\t\t\t\tcause: error instanceof Error ? error : undefined,\n\t\t\t\t} )\n\t\t\t);\n\t\t}\n\t};\n}\n\n/**\n * Adds thumbnail versions to the queue for sideloading.\n *\n * Also handles image rotation for images that need EXIF-based rotation\n * but weren't scaled down (and thus weren't auto-rotated by vips).\n *\n * @param id Item ID.\n */\nexport function generateThumbnails( id: QueueItemId ) {\n\treturn async ( { select, dispatch }: ThunkArgs ) => {\n\t\tconst item = select.getItem( id );\n\t\tif ( ! item ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( ! item.attachment ) {\n\t\t\tdispatch.finishOperation( id, {} );\n\t\t\treturn;\n\t\t}\n\t\tconst attachment = item.attachment;\n\n\t\t// Check if image needs rotation.\n\t\t// If exif_orientation is not 1, the image needs rotation.\n\t\t// Images that were scaled (bigImageSizeThreshold) are already rotated by vips.\n\t\tconst needsRotation =\n\t\t\tattachment.exif_orientation &&\n\t\t\tattachment.exif_orientation !== 1 &&\n\t\t\t! item.file.name.includes( '-scaled' );\n\n\t\t// If rotation is needed for a non-scaled image, sideload the rotated version.\n\t\t// This matches WordPress core's behavior of creating a -rotated version.\n\t\tif ( needsRotation && attachment.id ) {\n\t\t\ttry {\n\t\t\t\tconst rotatedFile = await vipsRotateImage(\n\t\t\t\t\titem.id,\n\t\t\t\t\titem.sourceFile,\n\t\t\t\t\tattachment.exif_orientation as number,\n\t\t\t\t\titem.abortController?.signal\n\t\t\t\t);\n\n\t\t\t\t// Sideload the rotated file as the \"original\" to set original_image metadata.\n\t\t\t\t// The server will store this in $metadata['original_image'].\n\t\t\t\tdispatch.addSideloadItem( {\n\t\t\t\t\tfile: rotatedFile,\n\t\t\t\t\tbatchId: uuidv4(),\n\t\t\t\t\tparentId: item.id,\n\t\t\t\t\tadditionalData: {\n\t\t\t\t\t\tpost: attachment.id,\n\t\t\t\t\t\timage_size: 'original',\n\t\t\t\t\t\tconvert_format: false,\n\t\t\t\t\t},\n\t\t\t\t\toperations: [ OperationType.Upload ],\n\t\t\t\t} );\n\t\t\t} catch {\n\t\t\t\t// If rotation fails, continue with thumbnail generation.\n\t\t\t\t// Thumbnails will still be rotated correctly by vips.\n\t\t\t\t// eslint-disable-next-line no-console\n\t\t\t\tconsole.warn(\n\t\t\t\t\t'Failed to rotate image, continuing with thumbnails'\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// Client-side thumbnail generation for images.\n\t\tif (\n\t\t\t! item.parentId &&\n\t\t\tattachment.missing_image_sizes &&\n\t\t\tattachment.missing_image_sizes.length > 0\n\t\t) {\n\t\t\t// Use sourceFile for thumbnail generation to preserve quality.\n\t\t\t// WordPress core generates thumbnails from the original (unscaled) image.\n\t\t\t// Vips will auto-rotate based on EXIF orientation during thumbnail generation.\n\t\t\tconst file = attachment.media_filename\n\t\t\t\t? renameFile( item.sourceFile, attachment.media_filename )\n\t\t\t\t: item.sourceFile;\n\t\t\tconst batchId = uuidv4();\n\n\t\t\tconst settings = select.getSettings();\n\t\t\tconst allImageSizes = settings.allImageSizes || {};\n\t\t\tconst { imageOutputFormats } = settings;\n\n\t\t\t// Check if thumbnails should be transcoded to a different format.\n\t\t\t// Uses the same transparency-aware logic as the main image\n\t\t\t// to avoid converting transparent PNGs to JPEG.\n\t\t\tconst sourceType = item.sourceFile.type;\n\t\t\tconst outputMimeType = imageOutputFormats?.[ sourceType ];\n\n\t\t\tlet thumbnailTranscodeOperation:\n\t\t\t\t| [\n\t\t\t\t\t\tOperationType.TranscodeImage,\n\t\t\t\t\t\tOperationArgs[ OperationType.TranscodeImage ],\n\t\t\t\t  ]\n\t\t\t\t| null = null;\n\n\t\t\tif ( outputMimeType && outputMimeType !== sourceType ) {\n\t\t\t\tthumbnailTranscodeOperation = await getTranscodeImageOperation(\n\t\t\t\t\titem.sourceFile,\n\t\t\t\t\toutputMimeType,\n\t\t\t\t\tsettings\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tfor ( const name of attachment.missing_image_sizes ) {\n\t\t\t\tconst imageSize = allImageSizes[ name ];\n\t\t\t\tif ( ! imageSize ) {\n\t\t\t\t\t// eslint-disable-next-line no-console\n\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t`Image size \"${ name }\" not found in configuration`\n\t\t\t\t\t);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Build operations list for this thumbnail.\n\t\t\t\tconst thumbnailOperations: Operation[] = [\n\t\t\t\t\t[ OperationType.ResizeCrop, { resize: imageSize } ],\n\t\t\t\t];\n\n\t\t\t\t// Add transcoding if format conversion is configured and\n\t\t\t\t// the transparency check passed.\n\t\t\t\tif ( thumbnailTranscodeOperation ) {\n\t\t\t\t\tthumbnailOperations.push( thumbnailTranscodeOperation );\n\t\t\t\t}\n\n\t\t\t\tthumbnailOperations.push( OperationType.Upload );\n\n\t\t\t\tdispatch.addSideloadItem( {\n\t\t\t\t\tfile,\n\t\t\t\t\tonChange: ( [ updatedAttachment ] ) => {\n\t\t\t\t\t\t// If the sub-size is still being generated, there is no need\n\t\t\t\t\t\t// to invoke the callback below. It would just override\n\t\t\t\t\t\t// the main image in the editor with the sub-size.\n\t\t\t\t\t\tif ( isBlobURL( updatedAttachment.url ) ) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// This might be confusing, but the idea is to update the original\n\t\t\t\t\t\t// image item in the editor with the new one with the added sub-size.\n\t\t\t\t\t\titem.onChange?.( [ updatedAttachment ] );\n\t\t\t\t\t},\n\t\t\t\t\tbatchId,\n\t\t\t\t\tparentId: item.id,\n\t\t\t\t\tadditionalData: {\n\t\t\t\t\t\t// Sideloading does not use the parent post ID but the\n\t\t\t\t\t\t// attachment ID as the image sizes need to be added to it.\n\t\t\t\t\t\tpost: attachment.id,\n\t\t\t\t\t\timage_size: name,\n\t\t\t\t\t\tconvert_format: false,\n\t\t\t\t\t},\n\t\t\t\t\toperations: thumbnailOperations,\n\t\t\t\t} );\n\t\t\t}\n\t\t}\n\n\t\tdispatch.finishOperation( id, {} );\n\t};\n}\n\n/**\n * Revokes all blob URLs for a given item, freeing up memory.\n *\n * @param id Item ID.\n */\nexport function revokeBlobUrls( id: QueueItemId ) {\n\treturn async ( { select, dispatch }: ThunkArgs ) => {\n\t\tconst blobUrls = select.getBlobUrls( id );\n\n\t\tfor ( const blobUrl of blobUrls ) {\n\t\t\trevokeBlobURL( blobUrl );\n\t\t}\n\n\t\tdispatch< RevokeBlobUrlsAction >( {\n\t\t\ttype: Type.RevokeBlobUrls,\n\t\t\tid,\n\t\t} );\n\t};\n}\n\n/**\n * Updates the progress of an item.\n *\n * @param id       Item ID.\n * @param progress Progress value (0-100).\n */\nexport function updateItemProgress( id: QueueItemId, progress: number ) {\n\treturn async ( { dispatch }: ThunkArgs ) => {\n\t\tdispatch< UpdateProgressAction >( {\n\t\t\ttype: Type.UpdateProgress,\n\t\t\tid,\n\t\t\tprogress,\n\t\t} );\n\t};\n}\n\n/**\n * Returns an action object that updates the store settings.\n *\n * Useful for testing purposes.\n *\n * @param settings\n * @return Action object.\n */\nexport function updateSettings(\n\tsettings: Partial< Settings >\n): UpdateSettingsAction {\n\treturn {\n\t\ttype: Type.UpdateSettings,\n\t\tsettings,\n\t};\n}\n", "export class StubFile extends File {\n\tconstructor( fileName = 'stub-file' ) {\n\t\tsuper( [], fileName );\n\t}\n}\n", "/**\n * WordPress dependencies\n */\nimport { __dangerousOptInToUnstableAPIsOnlyForCoreModules } from '@wordpress/private-apis';\n\nexport const { lock, unlock } =\n\t__dangerousOptInToUnstableAPIsOnlyForCoreModules(\n\t\t'I acknowledge private features are not for use in themes or plugins and doing so will break in the next version of WordPress.',\n\t\t'@wordpress/upload-media'\n\t);\n", "/**\n * WordPress dependencies\n */\nimport { useEffect } from '@wordpress/element';\nimport { useDispatch } from '@wordpress/data';\n\n/**\n * Internal dependencies\n */\nimport withRegistryProvider from './with-registry-provider';\nimport { unlock } from '../../lock-unlock';\nimport { store as uploadStore } from '../../store';\n\nconst MediaUploadProvider = withRegistryProvider( ( props: any ) => {\n\tconst { children, settings } = props;\n\tconst { updateSettings } = unlock( useDispatch( uploadStore ) );\n\n\tuseEffect( () => {\n\t\tupdateSettings( settings );\n\t}, [ settings, updateSettings ] );\n\n\treturn <>{ children }</>;\n} );\n\nexport default MediaUploadProvider;\n", "/**\n * WordPress dependencies\n */\nimport { useState } from '@wordpress/element';\nimport { useRegistry, createRegistry, RegistryProvider } from '@wordpress/data';\nimport { createHigherOrderComponent } from '@wordpress/compose';\n\n/**\n * Internal dependencies\n */\nimport { storeConfig } from '../../store';\nimport { STORE_NAME as mediaUploadStoreName } from '../../store/constants';\n\ntype WPDataRegistry = ReturnType< typeof createRegistry >;\n\nfunction getSubRegistry(\n\tsubRegistries: WeakMap< WPDataRegistry, WPDataRegistry >,\n\tregistry: WPDataRegistry,\n\tuseSubRegistry: boolean\n) {\n\tif ( ! useSubRegistry ) {\n\t\treturn registry;\n\t}\n\tlet subRegistry = subRegistries.get( registry );\n\tif ( ! subRegistry ) {\n\t\tsubRegistry = createRegistry( {}, registry );\n\t\tsubRegistry.registerStore( mediaUploadStoreName, storeConfig );\n\t\tsubRegistries.set( registry, subRegistry );\n\t}\n\treturn subRegistry;\n}\n\nconst withRegistryProvider = createHigherOrderComponent(\n\t( WrappedComponent ) =>\n\t\t( { useSubRegistry = true, ...props } ) => {\n\t\t\tconst registry = useRegistry() as unknown as WPDataRegistry;\n\t\t\tconst [ subRegistries ] = useState<\n\t\t\t\tWeakMap< WPDataRegistry, WPDataRegistry >\n\t\t\t>( () => new WeakMap() );\n\t\t\tconst subRegistry = getSubRegistry(\n\t\t\t\tsubRegistries,\n\t\t\t\tregistry,\n\t\t\t\tuseSubRegistry\n\t\t\t);\n\n\t\t\tif ( subRegistry === registry ) {\n\t\t\t\treturn <WrappedComponent registry={ registry } { ...props } />;\n\t\t\t}\n\n\t\t\treturn (\n\t\t\t\t<RegistryProvider value={ subRegistry }>\n\t\t\t\t\t<WrappedComponent registry={ subRegistry } { ...props } />\n\t\t\t\t</RegistryProvider>\n\t\t\t);\n\t\t},\n\t'withRegistryProvider'\n);\n\nexport default withRegistryProvider;\n", "/**\n * Result of client-side media processing support detection.\n */\nexport interface FeatureDetectionResult {\n\t/**\n\t * Whether client-side media processing is supported.\n\t */\n\tsupported: boolean;\n\t/**\n\t * Reason why client-side media processing is not supported (if applicable).\n\t */\n\treason?: string;\n}\n\n/**\n * Cached result of feature detection.\n */\nlet cachedResult: FeatureDetectionResult | null = null;\n\n/**\n * Detects whether the browser supports client-side media processing.\n *\n * This checks for:\n * 1. WebAssembly support (required for wasm-vips)\n * 2. SharedArrayBuffer support (required for WASM threading)\n * 3. CSP compatibility for blob URL workers (required for inline worker creation)\n *\n * @return Feature detection result with supported status and reason if not supported.\n */\nexport function detectClientSideMediaSupport(): FeatureDetectionResult {\n\t// Return cached result if available.\n\tif ( cachedResult !== null ) {\n\t\treturn cachedResult;\n\t}\n\n\t// Check WebAssembly support.\n\tif ( typeof WebAssembly === 'undefined' ) {\n\t\tcachedResult = {\n\t\t\tsupported: false,\n\t\t\treason: 'WebAssembly is not supported in this browser',\n\t\t};\n\t\treturn cachedResult;\n\t}\n\n\t// Check SharedArrayBuffer support (required for WASM threading).\n\tif ( typeof SharedArrayBuffer === 'undefined' ) {\n\t\tcachedResult = {\n\t\t\tsupported: false,\n\t\t\treason: 'SharedArrayBuffer is not available. This may be due to missing cross-origin isolation headers.',\n\t\t};\n\t\treturn cachedResult;\n\t}\n\n\t// Check that blob URL workers are allowed by CSP.\n\t// Security plugins often set a strict worker-src directive that blocks blob: URLs,\n\t// which would prevent creating the WASM processing worker at runtime.\n\tif ( typeof window !== 'undefined' && typeof Worker !== 'undefined' ) {\n\t\ttry {\n\t\t\tconst testBlob = new Blob( [ '' ], {\n\t\t\t\ttype: 'application/javascript',\n\t\t\t} );\n\t\t\tconst testUrl = URL.createObjectURL( testBlob );\n\t\t\ttry {\n\t\t\t\tconst testWorker = new Worker( testUrl );\n\t\t\t\ttestWorker.terminate();\n\t\t\t} finally {\n\t\t\t\tURL.revokeObjectURL( testUrl );\n\t\t\t}\n\t\t} catch {\n\t\t\tcachedResult = {\n\t\t\t\tsupported: false,\n\t\t\t\treason: \"The site's Content Security Policy (CSP) does not allow blob: workers. The worker-src directive must include blob: to enable client-side media processing.\",\n\t\t\t};\n\t\t\treturn cachedResult;\n\t\t}\n\t}\n\n\tcachedResult = { supported: true };\n\treturn cachedResult;\n}\n\n/**\n * Returns whether client-side media processing is supported.\n *\n * This is a convenience function that returns just the boolean result.\n *\n * @return Whether client-side media processing is supported.\n */\nexport function isClientSideMediaSupported(): boolean {\n\treturn detectClientSideMediaSupport().supported;\n}\n\n/**\n * Clears the cached feature detection result.\n *\n * This is primarily useful for testing purposes.\n */\nexport function clearFeatureDetectionCache(): void {\n\tcachedResult = null;\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA,aAAO,UAAU,OAAO,GAAG;AAAA;AAAA;;;ACA3B;AAAA;AAAA,aAAO,UAAU,OAAO,GAAG;AAAA;AAAA;;;ACA3B;AAAA;AAAA,aAAO,UAAU,OAAO,GAAG;AAAA;AAAA;;;ACA3B;AAAA;AAAA,aAAO,UAAU,OAAO,GAAG;AAAA;AAAA;;;ACA3B;AAAA;AAAA,aAAO,UAAU,OAAO,GAAG;AAAA;AAAA;;;ACA3B;AAAA;AAAA,aAAO,UAAU,OAAO,GAAG;AAAA;AAAA;;;ACA3B;AAAA;AAAA,aAAO,UAAU,OAAO,GAAG;AAAA;AAAA;;;ACA3B;AAAA;AAAA,aAAO,UAAU,OAAO;AAAA;AAAA;A;;;;;;;;;;;;;ACGxB,oBAAmD;;;ACkC5C,MAAK,OAAL,kBAAKA,UAAL;AACNA,UAAA,SAAA,IAAU;AACVA,UAAA,KAAA,IAAM;AACNA,UAAA,SAAA,IAAU;AACVA,UAAA,QAAA,IAAS;AACTA,UAAA,QAAA,IAAS;AACTA,UAAA,WAAA,IAAY;AACZA,UAAA,WAAA,IAAY;AACZA,UAAA,YAAA,IAAa;AACbA,UAAA,YAAA,IAAa;AACbA,UAAA,aAAA,IAAc;AACdA,UAAA,gBAAA,IAAiB;AACjBA,UAAA,iBAAA,IAAkB;AAClBA,UAAA,eAAA,IAAgB;AAChBA,UAAA,cAAA,IAAe;AACfA,UAAA,gBAAA,IAAiB;AACjBA,UAAA,gBAAA,IAAiB;AACjBA,UAAA,gBAAA,IAAiB;AAjBN,WAAAA;EAAA,GAAA,QAAA,CAAA,CAAA;AAuLL,MAAK,aAAL,kBAAKC,gBAAL;AACNA,gBAAA,QAAA,IAAS;AACTA,gBAAA,YAAA,IAAa;AACbA,gBAAA,QAAA,IAAS;AACTA,gBAAA,UAAA,IAAW;AACXA,gBAAA,OAAA,IAAQ;AALG,WAAAA;EAAA,GAAA,cAAA,CAAA,CAAA;AAQL,MAAK,gBAAL,kBAAKC,mBAAL;AACNA,mBAAA,SAAA,IAAU;AACVA,mBAAA,QAAA,IAAS;AACTA,mBAAA,YAAA,IAAa;AACbA,mBAAA,QAAA,IAAS;AACTA,mBAAA,gBAAA,IAAiB;AACjBA,mBAAA,qBAAA,IAAsB;AANX,WAAAA;EAAA,GAAA,iBAAA,CAAA,CAAA;;;ACpOL,MAAM,aAAa;AAKnB,MAAM,iCAAiC;AAUvC,MAAM,0CAA0C;AAQhD,MAAM,mCAAsD;IAClE;IACA;IACA;IACA;IACA;EACD;;;ACCA,MAAM,OAAO,MAAM;EAAC;AAEpB,MAAM,gBAAuB;IAC5B,OAAO,CAAC;IACR,aAAa;IACb,UAAU,CAAC;IACX,UAAU;MACT,aAAa;MACb,sBAAsB;MACtB,8BAA8B;IAC/B;EACD;AAoBA,WAAS,QACR,QAAQ,eACR,SAAiB,EAAE,MAAM,KAAK,QAAQ,GACrC;AACD,YAAS,OAAO,MAAO;MACtB,KAAK,KAAK,YAAY;AACrB,eAAO;UACN,GAAG;UACH,aAAa;QACd;MACD;MAEA,KAAK,KAAK,aAAa;AACtB,eAAO;UACN,GAAG;UACH,aAAa;QACd;MACD;MAEA,KAAK,KAAK;AACT,eAAO;UACN,GAAG;UACH,OAAO,MAAM,MAAM;YAClB,CAAE,SACD,KAAK,OAAO,OAAO,KAChB;cACA,GAAG;cACH,QAAQ,WAAW;YACnB,IACA;UACL;QACD;MAED,KAAK,KAAK;AACT,eAAO;UACN,GAAG;UACH,OAAO,MAAM,MAAM;YAClB,CAAE,SACD,KAAK,OAAO,OAAO,KAChB;cACA,GAAG;cACH,QAAQ,WAAW;YACnB,IACA;UACL;QACD;MAED,KAAK,KAAK;AACT,eAAO;UACN,GAAG;UACH,OAAO,CAAE,GAAG,MAAM,OAAO,OAAO,IAAK;QACtC;MAED,KAAK,KAAK;AACT,eAAO;UACN,GAAG;UACH,OAAO,MAAM,MAAM;YAClB,CAAE,SACD,KAAK,OAAO,OAAO,KAChB;cACA,GAAG;cACH,OAAO,OAAO;YACd,IACA;UACL;QACD;MAED,KAAK,KAAK;AACT,eAAO;UACN,GAAG;UACH,OAAO,MAAM,MAAM;YAClB,CAAE,SACD,KAAK,OAAO,OAAO,KAChB;cACA,GAAG;cACH,QAAQ,WAAW;cACnB,OAAO;cACP,aAAc,KAAK,cAAc,KAAM;YACvC,IACA;UACL;QACD;MAED,KAAK,KAAK;AACT,eAAO;UACN,GAAG;UACH,OAAO,MAAM,MAAM,OAAQ,CAAE,SAAU,KAAK,OAAO,OAAO,EAAG;QAC9D;MAED,KAAK,KAAK,gBAAgB;AACzB,eAAO;UACN,GAAG;UACH,OAAO,MAAM,MAAM;YAClB,CAAE,SACD,KAAK,OAAO,OAAO,KAChB;cACA,GAAG;cACH,kBAAkB,OAAO;YACzB,IACA;UACL;QACD;MACD;MAEA,KAAK,KAAK;AACT,eAAO;UACN,GAAG;UACH,OAAO,MAAM,MAAM,IAAK,CAAE,SAAqB;AAC9C,gBAAK,KAAK,OAAO,OAAO,IAAK;AAC5B,qBAAO;YACR;AAEA,mBAAO;cACN,GAAG;cACH,YAAY;gBACX,GAAK,KAAK,cAAc,CAAC;gBACzB,GAAG,OAAO;cACX;YACD;UACD,CAAE;QACH;MAED,KAAK,KAAK;AACT,eAAO;UACN,GAAG;UACH,OAAO,MAAM,MAAM,IAAK,CAAE,SAAqB;AAC9C,gBAAK,KAAK,OAAO,OAAO,IAAK;AAC5B,qBAAO;YACR;AAEA,kBAAM,aAAa,KAAK,aACrB,KAAK,WAAW,MAAO,CAAE,IACzB,CAAC;AAGJ,kBAAM,aACL,KAAK,cAAc,OAAO,KAAK,aAC5B;cACA,GAAG,KAAK;cACR,GAAG,OAAO,KAAK;YACf,IACA;AAEJ,mBAAO;cACN,GAAG;cACH,kBAAkB;cAClB;cACA,GAAG,OAAO;cACV;cACA,gBAAgB;gBACf,GAAG,KAAK;gBACR,GAAG,OAAO,KAAK;cAChB;YACD;UACD,CAAE;QACH;MAED,KAAK,KAAK,cAAc;AACvB,cAAM,WAAW,MAAM,SAAU,OAAO,EAAG,KAAK,CAAC;AACjD,eAAO;UACN,GAAG;UACH,UAAU;YACT,GAAG,MAAM;YACT,CAAE,OAAO,EAAG,GAAG,CAAE,GAAG,UAAU,OAAO,OAAQ;UAC9C;QACD;MACD;MAEA,KAAK,KAAK,gBAAgB;AACzB,cAAM,cAAc,EAAE,GAAG,MAAM,SAAS;AACxC,eAAO,YAAa,OAAO,EAAG;AAE9B,eAAO;UACN,GAAG;UACH,UAAU;QACX;MACD;MAEA,KAAK,KAAK;AACT,eAAO;UACN,GAAG;UACH,OAAO,MAAM,MAAM;YAClB,CAAE,SACD,KAAK,OAAO,OAAO,KAChB;cACA,GAAG;cACH,UAAU,OAAO;YACjB,IACA;UACL;QACD;MAED,KAAK,KAAK,gBAAgB;AACzB,eAAO;UACN,GAAG;UACH,UAAU;YACT,GAAG,MAAM;YACT,GAAG,OAAO;UACX;QACD;MACD;IACD;AAEA,WAAO;EACR;AAEA,MAAO,kBAAQ;;;;;;;;;;;AC/PR,WAAS,SAAU,OAA4B;AACrD,WAAO,MAAM;EACd;AASO,WAAS,YAAa,OAAwB;AACpD,WAAO,MAAM,MAAM,UAAU;EAC9B;AAUO,WAAS,iBAAkB,OAAc,KAAuB;AACtE,WAAO,MAAM,MAAM;MAClB,CAAE,SAAU,KAAK,YAAY,QAAQ,OAAO,KAAK,cAAc;IAChE;EACD;AAUO,WAAS,gBAAiB,OAAc,cAAgC;AAC9E,WAAO,MAAM,MAAM;MAClB,CAAE,SACD,KAAK,YAAY,OAAO,gBACxB,KAAK,uBAAuB;IAC9B;EACD;AASO,WAAS,YAAa,OAAyB;AACrD,WAAO,MAAM;EACd;A;;;;;;;;;;;;;;;;;;;AC/CO,WAAS,YAAa,OAA4B;AACxD,WAAO,MAAM;EACd;AAUO,WAAS,QACf,OACA,IACwB;AACxB,WAAO,MAAM,MAAM,KAAM,CAAE,SAAU,KAAK,OAAO,EAAG;EACrD;AAUO,WAAS,gBAAiB,OAAc,SAA4B;AAC1E,UAAM,aAAa,MAAM,MAAM;MAC9B,CAAE,SAAU,YAAY,KAAK;IAC9B;AACA,WAAO,WAAW,WAAW;EAC9B;AAUO,WAAS,kBACf,OACA,oBACU;AACV,WAAO,MAAM,MAAM;MAClB,CAAE,SACD,KAAK,qBAAqB,cAAc,UACxC,KAAK,eAAe,SAAS;IAC/B;EACD;AAUO,WAAS,uBACf,OACA,oBACwB;AACxB,WAAO,MAAM,MAAM;MAClB,CAAE,SACD,KAAK,WAAW,WAAW,UAC3B,KAAK,eAAe,SAAS;IAC/B;EACD;AASO,WAAS,SAAU,OAAwB;AACjD,WAAO,MAAM,gBAAgB;EAC9B;AAUO,WAAS,YAAa,OAAc,IAA4B;AACtE,WAAO,MAAM,SAAU,EAAG,KAAK,CAAC;EACjC;AASO,WAAS,qBAAsB,OAAuB;AAC5D,WAAO,MAAM,MAAM;MAClB,CAAE,SAAU,KAAK,qBAAqB,cAAc;IACrD,EAAE;EACH;AASO,WAAS,kBAAmB,OAA4B;AAC9D,WAAO,MAAM,MAAM,OAAQ,CAAE,SAAU;AACtC,YAAM,gBAAgB,MAAM,QAAS,KAAK,aAAc,CAAE,CAAE,IACzD,KAAK,WAAY,CAAE,EAAG,CAAE,IACxB,KAAK,aAAc,CAAE;AACxB,aACC,kBAAkB,cAAc,UAChC,KAAK,qBAAqB,cAAc;IAE1C,CAAE;EACH;AAYO,WAAS,8BAA+B,OAAuB;AACrE,WAAO,MAAM,MAAM;MAClB,CAAE,SACD,KAAK,qBAAqB,cAAc,cACxC,KAAK,qBAAqB,cAAc;IAC1C,EAAE;EACH;AAUO,WAAS,0BAA2B,OAA4B;AACtE,WAAO,MAAM,MAAM,OAAQ,CAAE,SAAU;AACtC,YAAM,gBAAgB,MAAM,QAAS,KAAK,aAAc,CAAE,CAAE,IACzD,KAAK,WAAY,CAAE,EAAG,CAAE,IACxB,KAAK,aAAc,CAAE;AACxB,cACG,kBAAkB,cAAc,cACjC,kBAAkB,cAAc,WACjC,KAAK,qBAAqB,cAAc,cACxC,KAAK,qBAAqB,cAAc;IAE1C,CAAE;EACH;AASO,WAAS,eAAgB,OAA4B;AAC3D,WAAO,MAAM,MAAM,OAAQ,CAAE,SAAU,KAAK,UAAU,MAAU;EACjE;AAUO,WAAS,0BACf,OACA,UACU;AACV,WAAO,MAAM,MAAM,KAAM,CAAE,SAAU,KAAK,aAAa,QAAS;EACjE;AAUO,WAAS,gBACf,OACA,IACqB;AACrB,UAAM,OAAO,MAAM,MAAM,KAAM,CAAE,MAAO,EAAE,OAAO,EAAG;AACpD,WAAO,MAAM;EACd;A;;;;;;;;;;AC/NA,MAAI;AACJ,MAAM,QAAQ,IAAI,WAAW,EAAE;AAChB,WAAR,MAAuB;AAE5B,QAAI,CAAC,iBAAiB;AAEpB,wBAAkB,OAAO,WAAW,eAAe,OAAO,mBAAmB,OAAO,gBAAgB,KAAK,MAAM;AAE/G,UAAI,CAAC,iBAAiB;AACpB,cAAM,IAAI,MAAM,0GAA0G;AAAA,MAC5H;AAAA,IACF;AAEA,WAAO,gBAAgB,KAAK;AAAA,EAC9B;;;ACXA,MAAM,YAAY,CAAC;AAEnB,WAAS,IAAI,GAAG,IAAI,KAAK,EAAE,GAAG;AAC5B,cAAU,MAAM,IAAI,KAAO,SAAS,EAAE,EAAE,MAAM,CAAC,CAAC;AAAA,EAClD;AAEO,WAAS,gBAAgB,KAAK,SAAS,GAAG;AAG/C,WAAO,UAAU,IAAI,SAAS,CAAC,CAAC,IAAI,UAAU,IAAI,SAAS,CAAC,CAAC,IAAI,UAAU,IAAI,SAAS,CAAC,CAAC,IAAI,UAAU,IAAI,SAAS,CAAC,CAAC,IAAI,MAAM,UAAU,IAAI,SAAS,CAAC,CAAC,IAAI,UAAU,IAAI,SAAS,CAAC,CAAC,IAAI,MAAM,UAAU,IAAI,SAAS,CAAC,CAAC,IAAI,UAAU,IAAI,SAAS,CAAC,CAAC,IAAI,MAAM,UAAU,IAAI,SAAS,CAAC,CAAC,IAAI,UAAU,IAAI,SAAS,CAAC,CAAC,IAAI,MAAM,UAAU,IAAI,SAAS,EAAE,CAAC,IAAI,UAAU,IAAI,SAAS,EAAE,CAAC,IAAI,UAAU,IAAI,SAAS,EAAE,CAAC,IAAI,UAAU,IAAI,SAAS,EAAE,CAAC,IAAI,UAAU,IAAI,SAAS,EAAE,CAAC,IAAI,UAAU,IAAI,SAAS,EAAE,CAAC;AAAA,EACnf;;;AChBA,MAAM,aAAa,OAAO,WAAW,eAAe,OAAO,cAAc,OAAO,WAAW,KAAK,MAAM;AACtG,MAAO,iBAAQ;AAAA,IACb;AAAA,EACF;;;ACCA,WAAS,GAAG,SAAS,KAAK,QAAQ;AAChC,QAAI,eAAO,cAAc,CAAC,OAAO,CAAC,SAAS;AACzC,aAAO,eAAO,WAAW;AAAA,IAC3B;AAEA,cAAU,WAAW,CAAC;AACtB,UAAM,OAAO,QAAQ,WAAW,QAAQ,OAAO,KAAK;AAEpD,SAAK,CAAC,IAAI,KAAK,CAAC,IAAI,KAAO;AAC3B,SAAK,CAAC,IAAI,KAAK,CAAC,IAAI,KAAO;AAE3B,QAAI,KAAK;AACP,eAAS,UAAU;AAEnB,eAAS,IAAI,GAAG,IAAI,IAAI,EAAE,GAAG;AAC3B,YAAI,SAAS,CAAC,IAAI,KAAK,CAAC;AAAA,MAC1B;AAEA,aAAO;AAAA,IACT;AAEA,WAAO,gBAAgB,IAAI;AAAA,EAC7B;AAEA,MAAO,aAAQ;;;ACrBR,MAAM,YAAN,cAAwB,KAAK;IACnC,QAAQ;IACR,SAAS;IACT,gBAAiB;IACjB,iBAAkB;IAElB,IAAI,aAAa;AAChB,cACG,KAAK,iBAAiB,KAAM,KAAK,UACjC,KAAK,kBAAkB,KAAM,KAAK;IAEtC;IAEA,YACC,MACA,OACA,QACA,eACA,gBACC;AACD,YAAO,CAAE,IAAK,GAAG,KAAK,MAAM;QAC3B,MAAM,KAAK;QACX,cAAc,KAAK;MACpB,CAAE;AAEF,WAAK,QAAQ;AACb,WAAK,SAAS;AACd,WAAK,gBAAgB;AACrB,WAAK,iBAAiB;IACvB;EACD;;;AClCA,mBAA4B;AAC5B,oBAAmB;AAUZ,WAAS,kBAAmB,YAAgC;AAClE,QAAK,sBAAsB,MAAO;AACjC,aAAO;IACR;AAIA,UAAM,MAAM,WAAW,KAAK,MAAO,GAAI,EAAG,CAAE;AAC5C,UAAM,YACL,sBAAsB,WAAW,OAC9B,aACA,WAAW,KAAK,MAAO,GAAI,EAAG,CAAE;AACpC,WAAO,IAAI,KAAM,CAAE,UAAW,GAAG,GAAI,SAAU,IAAK,GAAI,IAAI;MAC3D,MAAM,WAAW;IAClB,CAAE;EACH;AAWO,WAAS,WAAY,MAAY,MAAqB;AAC5D,WAAO,IAAI,KAAM,CAAE,IAAK,GAAG,MAAM;MAChC,MAAM,KAAK;MACX,cAAc,KAAK;IACpB,CAAE;EACH;AAQO,WAAS,UAAW,MAAmB;AAC7C,WAAO,WAAY,MAAM,KAAK,IAAK;EACpC;AAoBO,WAAS,gBAAiB,MAAuB;AACvD,WAAO,KAAK,SAAU,GAAI,IACvB,KAAK,MAAO,GAAI,EAAE,MAAO,GAAG,EAAG,EAAE,KAAM,GAAI,IAC3C;EACJ;;;AC/DA,MAAI;AAQJ,MAAI;AAOJ,WAAS,iBAAqE;AAC7E,QAAK,CAAE,mBAAoB;AAC1B,0BAAoB,OAAQ,wBAAyB,EAAE;QACtD,CAAE,QAAS;AACV,uBAAa;AACb,iBAAO;QACR;MACD;IACD;AACA,WAAO;EACR;AAYA,iBAAsB,uBACrB,IACA,MACA,MAMA,SACA,YACC;AACD,UAAM,EAAE,wBAAwB,mBAAmB,IAClD,MAAM,eAAe;AACtB,UAAM,SAAS,MAAM;MACpB;MACA,MAAM,KAAK,YAAY;MACvB,KAAK;MACL;MACA;MACA;IACD;AACA,UAAM,MAAM,KAAK,MAAO,GAAI,EAAG,CAAE;AACjC,UAAM,WAAW,GAAI,gBAAiB,KAAK,IAAK,CAAE,IAAK,GAAI;AAC3D,WAAO,IAAI,KAAM,CAAE,IAAI,KAAM,CAAE,MAAsB,CAAE,CAAE,GAAG,UAAU;MACrE;IACD,CAAE;EACH;AAsCA,iBAAsB,oBAAqB,KAAc;AACxD,UAAM,EAAE,qBAAqB,gBAAgB,IAAI,MAAM,eAAe;AACtE,UAAM,WAAW,MAAM,MAAO,GAAI;AAClC,QAAK,CAAE,SAAS,IAAK;AACpB,YAAM,IAAI,MAAO,0BAA2B,SAAS,MAAO,EAAG;IAChE;AACA,WAAO,gBAAiB,MAAM,SAAS,YAAY,CAAE;EACtD;AAcA,iBAAsB,gBACrB,IACA,MACA,QACA,WACA,WACA,QACA,cACC;AACD,QAAK,QAAQ,SAAU;AACtB,YAAM,IAAI,MAAO,mBAAoB;IACtC;AAEA,UAAM,EAAE,iBAAiB,YAAY,IAAI,MAAM,eAAe;AAC9D,UAAM,EAAE,QAAQ,OAAO,QAAQ,eAAe,eAAe,IAC5D,MAAM;MACL;MACA,MAAM,KAAK,YAAY;MACvB,KAAK;MACL;MACA;IACD;AAED,QAAI,WAAW,KAAK;AACpB,UAAM,aAAa,gBAAgB,SAAS,iBAAiB;AAE7D,QAAK,YAAa;AACjB,YAAM,WAAW,gBAAiB,KAAK,IAAK;AAC5C,UAAK,cAAe;AAGnB,mBAAW,KAAK,KAAK,QAAS,UAAU,GAAI,QAAS,SAAU;MAChE,WAAY,WAAY;AAEvB,mBAAW,KAAK,KAAK;UACpB;UACA,GAAI,QAAS,IAAK,KAAM,IAAK,MAAO;QACrC;MACD;IACD;AAEA,UAAM,aAAa,IAAI;MACtB,IAAI;QACH,CAAE,IAAI,KAAM,CAAE,MAAsB,GAAG,EAAE,MAAM,KAAK,KAAK,CAAE,CAAE;QAC7D;QACA;UACC,MAAM,KAAK;QACZ;MACD;MACA;MACA;MACA;MACA;IACD;AAEA,WAAO;EACR;AAeA,iBAAsB,gBACrB,IACA,MACA,aACA,QACC;AACD,QAAK,QAAQ,SAAU;AACtB,YAAM,IAAI,MAAO,mBAAoB;IACtC;AAGA,QAAK,gBAAgB,GAAI;AACxB,aAAO;IACR;AAEA,UAAM,EAAE,iBAAiB,YAAY,IAAI,MAAM,eAAe;AAC9D,UAAM,EAAE,QAAQ,OAAO,OAAO,IAAI,MAAM;MACvC;MACA,MAAM,KAAK,YAAY;MACvB,KAAK;MACL;IACD;AAGA,UAAM,WAAW,gBAAiB,KAAK,IAAK;AAC5C,UAAM,WAAW,KAAK,KAAK,QAAS,UAAU,GAAI,QAAS,UAAW;AAEtE,UAAM,aAAa,IAAI;MACtB,IAAI;QACH,CAAE,IAAI,KAAM,CAAE,MAAsB,GAAG,EAAE,MAAM,KAAK,KAAK,CAAE,CAAE;QAC7D;QACA;UACC,MAAM,KAAK;QACZ;MACD;MACA;MACA;IACD;AAEA,WAAO;EACR;AAWA,iBAAsB,qBAAsB,IAAkB;AAC7D,QAAK,CAAE,YAAa;AACnB,aAAO;IACR;AACA,WAAO,WAAW,qBAAsB,EAAG;EAC5C;AAQO,WAAS,sBAA4B;AAC3C,QAAK,YAAa;AACjB,iBAAW,oBAAoB;IAChC;EACD;;;ACnRA,MAAAC,eAA4B;;;ACUrB,MAAM,cAAN,cAA0B,MAAM;IACtC;IACA;IAEA,YAAa,EAAE,MAAM,SAAS,MAAM,MAAM,GAAqB;AAC9D,YAAO,SAAS,EAAE,MAAM,CAAE;AAE1B,aAAO,eAAgB,MAAM,WAAW,SAAU;AAElD,WAAK,OAAO;AACZ,WAAK,OAAO;IACb;EACD;;;ADTO,WAAS,iBAAkB,MAAY,cAA0B;AACvE,QAAK,CAAE,cAAe;AACrB;IACD;AAGA,UAAM,gBAAgB,aAAa,KAAM,CAAE,gBAAiB;AAE3D,UAAK,YAAY,SAAU,GAAI,GAAI;AAClC,eAAO,gBAAgB,KAAK;MAC7B;AAEA,aAAO,KAAK,KAAK,WAAY,GAAI,WAAY,GAAI;IAClD,CAAE;AAEF,QAAK,KAAK,QAAQ,CAAE,eAAgB;AACnC,YAAM,IAAI,YAAa;QACtB,MAAM;QACN,aAAS;;cAER,iBAAI,kDAAmD;UACvD,KAAK;QACN;QACA;MACD,CAAE;IACH;EACD;;;AEvCA,MAAAC,eAA4B;;;ACOrB,WAAS,kBACf,mBACC;AACD,QAAK,CAAE,mBAAoB;AAC1B,aAAO;IACR;AACA,WAAO,OAAO,QAAS,iBAAkB,EAAE;MAC1C,CAAE,CAAE,kBAAkB,IAAK,MAAO;AACjC,cAAM,CAAE,IAAK,IAAI,KAAK,MAAO,GAAI;AACjC,cAAM,aAAa,iBAAiB,MAAO,GAAI;AAC/C,eAAO;UACN;UACA,GAAG,WAAW;YACb,CAAE,cAAe,GAAI,IAAK,IAAK,SAAU;UAC1C;QACD;MACD;IACD;EACD;;;ADXO,WAAS,wBACf,MACA,oBACC;AAED,UAAM,0BAA0B,kBAAmB,kBAAmB;AAEtE,QAAK,CAAE,yBAA0B;AAChC;IACD;AAEA,UAAM,2BAA2B,wBAAwB;MACxD,KAAK;IACN;AAEA,QAAK,KAAK,QAAQ,CAAE,0BAA2B;AAC9C,YAAM,IAAI,YAAa;QACtB,MAAM;QACN,aAAS;;cAER;YACC;UACD;UACA,KAAK;QACN;QACA;MACD,CAAE;IACH;EACD;;;AE1CA,MAAAC,eAA4B;AAarB,WAAS,iBAAkB,MAAY,mBAA6B;AAE1E,QAAK,KAAK,QAAQ,GAAI;AACrB,YAAM,IAAI,YAAa;QACtB,MAAM;QACN,aAAS;;cAER,iBAAI,yBAA0B;UAC9B,KAAK;QACN;QACA;MACD,CAAE;IACH;AAEA,QAAK,qBAAqB,KAAK,OAAO,mBAAoB;AACzD,YAAM,IAAI,YAAa;QACtB,MAAM;QACN,aAAS;;cAER;YACC;UACD;UACA,KAAK;QACN;QACA;MACD,CAAE;IACH;EACD;;;AC2CO,WAAS,SAAU;IACzB;IACA;IACA;IACA;IACA;IACA;IACA;EACD,GAAkB;AACjB,WAAO,OAAQ,EAAE,QAAAC,SAAQ,SAAS,MAAkB;AACnD,YAAM,UAAU,WAAO;AACvB,iBAAY,QAAQ,OAAQ;AAM3B,YAAI;AACH,2BAAkB,MAAM,YAAa;AACrC;YACC;YACAA,QAAO,YAAY,EAAE;UACtB;QACD,SAAU,OAAiB;AAC1B,oBAAW,KAAe;AAC1B;QACD;AAEA,YAAI;AACH;YACC;YACAA,QAAO,YAAY,EAAE;UACtB;QACD,SAAU,OAAiB;AAC1B,oBAAW,KAAe;AAC1B;QACD;AAEA,iBAAS,QAAS;UACjB;UACA;UACA;UACA;UACA;UACA;UACA;QACD,CAAE;MACH;IACD;EACD;AAUO,WAAS,WAAY,IAAiB,OAAc,SAAS,OAAQ;AAC3E,WAAO,OAAQ,EAAE,QAAAA,SAAQ,SAAS,MAAkB;AACnD,YAAM,OAAOA,QAAO,QAAS,EAAG;AAEhC,UAAK,CAAE,MAAO;AAQb;MACD;AAEA,WAAK,iBAAiB,MAAM;AAG5B,YAAM,qBAAsB,EAAG;AAE/B,UAAK,CAAE,QAAS;AACf,cAAM,EAAE,QAAQ,IAAI;AACpB,kBAAW,SAAS,IAAI,MAAO,kBAAmB,CAAE;AACpD,YAAK,CAAE,WAAW,OAAQ;AAGzB,kBAAQ,MAAO,oBAAoB,KAAM;QAC1C;MACD;AAEA,eAA0B;QACzB,MAAM,KAAK;QACX;QACA;MACD,CAAE;AACF,eAAS,WAAY,EAAG;AACxB,eAAS,eAAgB,EAAG;AAG5B,UAAK,KAAK,WAAWA,QAAO,gBAAiB,KAAK,OAAQ,GAAI;AAC7D,aAAK,iBAAiB;MACvB;IACD;EACD;AAOO,WAAS,UAAW,IAAkB;AAC5C,WAAO,OAAQ,EAAE,QAAAA,SAAQ,SAAS,MAAkB;AACnD,YAAM,OAAOA,QAAO,QAAS,EAAG;AAEhC,UAAK,CAAE,MAAO;AACb;MACD;AAGA,UAAK,CAAE,KAAK,OAAQ;AACnB;MACD;AAEA,eAA6B;QAC5B,MAAM,KAAK;QACX;MACD,CAAE;AAEF,eAAS,YAAa,EAAG;IAC1B;EACD;A;;;;;;;;;;;;;;;;;;;;;;;;;AC/MA,oBAAwD;;;ACRjD,MAAM,WAAN,cAAuB,KAAK;IAClC,YAAa,WAAW,aAAc;AACrC,YAAO,CAAC,GAAG,QAAS;IACrB;EACD;;;ADsDA,MAAM,yBAAyB;AAiD/B,WAAS,uBACR,MACA,WACAC,SACU;AACV,QACC,cAAc,cAAc,UAC5B,CAAE,KAAK,YACP,CAAE,KAAK,eAAe,MACrB;AACD,aAAO;IACR;AACA,WAAOA,QAAO,kBAAmB,KAAK,eAAe,IAAe;EACrE;AAiCO,WAAS,QAAS;IACxB,MAAM;IACN;IACA;IACA;IACA;IACA;IACA,iBAAiB,CAAC;IAClB;IACA;IACA;IACA;EACD,GAAiB;AAChB,WAAO,OAAQ,EAAE,SAAS,MAAkB;AAC3C,YAAM,SAAS,WAAO;AAItB,YAAM,OAAO,kBAAmB,UAAW;AAE3C,UAAI;AAGJ,UAAK,EAAI,gBAAgB,WAAa;AACrC,sBAAU,2BAAe,IAAK;AAC9B,iBAAgC;UAC/B,MAAM,KAAK;UACX,IAAI;UACJ;QACD,CAAE;MACH;AAEA,eAAuB;QACtB,MAAM,KAAK;QACX,MAAM;UACL,IAAI;UACJ;UACA,QAAQ,WAAW;UACnB,YAAY,UAAW,IAAK;UAC5B;UACA,YAAY;YACX,KAAK;UACN;UACA,gBAAgB;YACf,gBAAgB;YAChB,oBAAoB;YACpB,GAAG;UACJ;UACA;UACA;UACA;UACA;UACA;UACA;UACA,iBAAiB,mBAAmB,IAAI,gBAAgB;UACxD,YAAY,MAAM,QAAS,UAAW,IACnC,aACA,CAAE,cAAc,OAAQ;QAC5B;MACD,CAAE;AAEF,eAAS,YAAa,MAAO;IAC9B;EACD;AAwBO,WAAS,gBAAiB;IAChC;IACA;IACA;IACA;IACA;IACA;EACD,GAAyB;AACxB,WAAO,CAAE,EAAE,SAAS,MAAkB;AACrC,YAAM,SAAS,WAAO;AACtB,eAAuB;QACtB,MAAM,KAAK;QACX,MAAM;UACL,IAAI;UACJ;UACA,QAAQ,WAAW;UACnB,YAAY,UAAW,IAAK;UAC5B;UACA;UACA,gBAAgB;YACf,GAAG;UACJ;UACA;UACA,YAAY,MAAM,QAAS,UAAW,IACnC,aACA,CAAE,cAAc,OAAQ;UAC3B,iBAAiB,IAAI,gBAAgB;QACtC;MACD,CAAE;AAEF,eAAS,YAAa,MAAO;IAC9B;EACD;AASO,WAAS,YAAa,IAAkB;AAC9C,WAAO,OAAQ,EAAE,QAAAA,SAAQ,SAAS,MAAkB;AACnD,UAAKA,QAAO,SAAS,GAAI;AACxB;MACD;AAEA,YAAM,OAAOA,QAAO,QAAS,EAAG;AAChC,UAAK,CAAE,MAAO;AACb;MACD;AAEA,YAAM;QACL;QACA;QACA;QACA;QACA;QACA;MACD,IAAI;AAEJ,YAAM,YAAY,MAAM,QAAS,KAAK,aAAc,CAAE,CAAE,IACrD,KAAK,WAAY,CAAE,EAAG,CAAE,IACxB,KAAK,aAAc,CAAE;AACxB,YAAM,gBAAgB,MAAM,QAAS,KAAK,aAAc,CAAE,CAAE,IACzD,KAAK,WAAY,CAAE,EAAG,CAAE,IACxB;AAIH,UAAK,uBAAwB,MAAM,WAAWA,OAAO,GAAI;AACxD,iBAA6B;UAC5B,MAAM,KAAK;UACX;QACD,CAAE;AACF;MACD;AAOA,UAAK,cAAc,cAAc,QAAS;AACzC,cAAM,WAAWA,QAAO,YAAY;AACpC,cAAM,cAAcA,QAAO,qBAAqB;AAChD,YAAK,eAAe,SAAS,sBAAuB;AACnD;QACD;MACD;AAQA,UACC,cAAc,cAAc,cAC5B,cAAc,cAAc,QAC3B;AACD,cAAM,WAAWA,QAAO,YAAY;AACpC,cAAM,cAAcA,QAAO,8BAA8B;AACzD,YAAK,eAAe,SAAS,8BAA+B;AAC3D;QACD;MACD;AAEA,UAAK,YAAa;AACjB,mBAAY,CAAE,UAAW,CAAE;MAC5B;AAQA,UAAK,CAAE,WAAY;AAClB,YACC,YACE,CAAE,YAAY,CAAEA,QAAO,0BAA2B,EAAG,GACtD;AACD,cAAK,YAAa;AACjB,wBAAa,CAAE,UAAW,CAAE;UAC7B;AAEA,mBAAS,WAAY,EAAG;AACxB,mBAAS,eAAgB,EAAG;AAE5B,cAAK,WAAWA,QAAO,gBAAiB,OAAQ,GAAI;AACnD,6BAAiB;UAClB;QACD;AAGA,YAAK,YAAY,WAAWA,QAAO,gBAAiB,OAAQ,GAAI;AAC/D,gBAAM,aAAaA,QAAO,QAAS,QAAS;AAC5C,cAAK,CAAE,YAAa;AACnB;UACD;AAEA,cAAK,YAAa;AACjB,uBAAW,YAAa,CAAE,UAAW,CAAE;UACxC;AAEA,mBAAS,WAAY,QAAS;AAC9B,mBAAS,eAAgB,QAAS;AAElC,cACC,WAAW,WACXA,QAAO,gBAAiB,WAAW,OAAQ,GAC1C;AACD,uBAAW,iBAAiB;UAC7B;QACD;AAOA;MACD;AAEA,eAAkC;QACjC,MAAM,KAAK;QACX;QACA;MACD,CAAE;AAEF,cAAS,WAAY;QACpB,KAAK,cAAc;AAClB,mBAAS,YAAa,KAAK,EAAG;AAC9B;QAED,KAAK,cAAc;AAClB,mBAAS;YACR,KAAK;YACL;UACD;AACA;QAED,KAAK,cAAc;AAClB,mBAAS;YACR,KAAK;YACL;UACD;AACA;QAED,KAAK,cAAc;AAClB,mBAAS;YACR,KAAK;YACL;UACD;AACA;QAED,KAAK,cAAc;AAClB,cAAK,KAAK,UAAW;AACpB,qBAAS,aAAc,EAAG;UAC3B,OAAO;AACN,qBAAS,WAAY,EAAG;UACzB;AACA;QAED,KAAK,cAAc;AAClB,mBAAS,mBAAoB,EAAG;AAChC;MACF;IACD;EACD;AASO,WAAS,aAA+B;AAC9C,WAAO;MACN,MAAM,KAAK;IACZ;EACD;AAQO,WAAS,cAAc;AAC7B,WAAO,OAAQ,EAAE,QAAAA,SAAQ,SAAS,MAAkB;AACnD,eAA+B;QAC9B,MAAM,KAAK;MACZ,CAAE;AAEF,iBAAY,QAAQA,QAAO,YAAY,GAAI;AAC1C,iBAAS,YAAa,KAAK,EAAG;MAC/B;IACD;EACD;AAOO,WAAS,UAAW,IAAkB;AAC5C,WAAO,OAAQ,EAAE,SAAS,MAAkB;AAC3C,eAA6B;QAC5B,MAAM,KAAK;QACX;MACD,CAAE;IACH;EACD;AAWO,WAAS,mBAAoB,oBAA6B;AAChE,WAAO,OAAQ,EAAE,QAAAA,SAAQ,SAAS,MAAkB;AACnD,YAAM,OAAOA,QAAO,uBAAwB,kBAAmB;AAC/D,UAAK,MAAO;AACX,iBAA8B;UAC7B,MAAM,KAAK;UACX,IAAI,KAAK;QACV,CAAE;AACF,iBAAS,YAAa,KAAK,EAAG;MAC/B;IACD;EACD;AAOO,WAAS,WAAY,IAAkB;AAC7C,WAAO,OAAQ,EAAE,QAAAA,SAAQ,SAAS,MAAkB;AACnD,YAAM,OAAOA,QAAO,QAAS,EAAG;AAChC,UAAK,CAAE,MAAO;AACb;MACD;AAEA,eAAU;QACT,MAAM,KAAK;QACX;MACD,CAAE;AAMF,UAAKA,QAAO,YAAY,EAAE,WAAW,GAAI;AACxC,4BAAoB;MACrB;IACD;EACD;AAQO,WAAS,gBACf,IACA,SACC;AACD,WAAO,OAAQ,EAAE,QAAAA,SAAQ,SAAS,MAAkB;AACnD,YAAM,OAAOA,QAAO,QAAS,EAAG;AAChC,YAAM,oBAAoB,MAAM;AAEhC,eAAmC;QAClC,MAAM,KAAK;QACX;QACA,MAAM;MACP,CAAE;AAEF,eAAS,YAAa,EAAG;AAMzB,UAAK,sBAAsB,cAAc,QAAS;AACjD,cAAM,iBAAiBA,QAAO,kBAAkB;AAChD,mBAAY,eAAe,gBAAiB;AAC3C,mBAAS,YAAa,YAAY,EAAG;QACtC;MACD;AAOA,UACC,sBAAsB,cAAc,cACpC,sBAAsB,cAAc,QACnC;AACD,cAAM,eAAeA,QAAO,0BAA0B;AACtD,mBAAY,eAAe,cAAe;AACzC,mBAAS,YAAa,YAAY,EAAG;QACtC;MACD;IACD;EACD;AAEA,MAAM,sBAAsB,CAAE,QAAQ,QAAQ,QAAQ,OAAO,KAAM;AAQnE,WAAS,mBAAoB,QAAwC;AACpE,WAAO,oBAAoB,SAAU,MAAsB;EAC5D;AASA,WAAS,qBACR,gBACA,UACU;AACV,YAAS,gBAAiB;MACzB,KAAK;AACJ,eAAO,SAAS,kBAAkB;MACnC,KAAK;AACJ,eAAO,SAAS,iBAAiB;MAClC,KAAK;AACJ,eAAO,SAAS,iBAAiB;MAClC;AACC,eAAO;IACT;EACD;AAaA,iBAAsB,2BACrB,MACA,gBACA,UAOC;AAGD,QAAK,KAAK,SAAS,eAAe,mBAAmB,cAAe;AACnE,YAAM,cAAU,2BAAe,IAAK;AACpC,UAAI;AACH,cAAM,WAAW,MAAM,oBAAqB,OAAQ;AACpD,YAAK,UAAW;AAEf,iBAAO;QACR;MACD,QAAQ;AAEP,eAAO;MACR,UAAA;AACC,uCAAe,OAAQ;MACxB;IACD;AAEA,UAAM,aAAa,eAAe,MAAO,GAAI,EAAG,CAAE;AAClD,QAAK,CAAE,mBAAoB,UAAW,GAAI;AAEzC,aAAO;IACR;AAEA,WAAO;MACN,cAAc;MACd;QACC,cAAc;QACd,eAAe;QACf,YAAY,qBAAsB,gBAAgB,QAAS;MAC5D;IACD;EACD;AAgBO,WAAS,YAAa,IAAkB;AAC9C,WAAO,OAAQ,EAAE,QAAAA,SAAQ,SAAS,MAAkB;AACnD,YAAM,OAAOA,QAAO,QAAS,EAAG;AAChC,UAAK,CAAE,MAAO;AACb;MACD;AACA,YAAM,EAAE,KAAK,IAAI;AAEjB,YAAM,aAA0B,CAAC;AACjC,YAAM,WAAWA,QAAO,YAAY;AAEpC,YAAM,UAAU,KAAK,KAAK,WAAY,QAAS;AAC/C,YAAM,kBAAkB,iCAAiC;QACxD,KAAK;MACN;AAGA,UAAK,WAAW,iBAAkB;AACjC,cAAM,EAAE,uBAAuB,mBAAmB,IAAI;AAItD,YAAK,uBAAwB;AAC5B,qBAAW,KAAM;YAChB,cAAc;YACd;cACC,QAAQ;gBACP,OAAO;gBACP,QAAQ;cACT;cACA,mBAAmB;YACpB;UACD,CAAE;QACH;AAIA,cAAM,iBAAiB,qBAAsB,KAAK,IAAK;AACvD,YAAK,kBAAkB,mBAAmB,KAAK,MAAO;AACrD,gBAAM,qBAAqB,MAAM;YAChC;YACA;YACA;UACD;AACA,cAAK,oBAAqB;AACzB,uBAAW,KAAM,kBAAmB;UACrC;QACD;AAEA,mBAAW;UACV,cAAc;UACd,cAAc;QACf;MACD,OAAO;AACN,mBAAW,KAAM,cAAc,MAAO;MACvC;AAEA,eAAiC;QAChC,MAAM,KAAK;QACX;QACA;MACD,CAAE;AAIF,YAAM,UACL,CAAE,mBAAmB,CAAE,UACpB;QACA,gBAAgB;UACf,GAAG,KAAK;UACR,oBAAoB;QACrB;MACA,IACA,CAAC;AAEL,eAAS,gBAAiB,IAAI,OAAQ;IACvC;EACD;AAOO,WAAS,WAAY,IAAkB;AAC7C,WAAO,OAAQ,EAAE,QAAAA,SAAQ,SAAS,MAAkB;AACnD,YAAM,OAAOA,QAAO,QAAS,EAAG;AAChC,UAAK,CAAE,MAAO;AACb;MACD;AAEA,MAAAA,QAAO,YAAY,EAAE,YAAa;QACjC,WAAW,CAAE,KAAK,IAAK;QACvB,gBAAgB,KAAK;QACrB,QAAQ,KAAK,iBAAiB;QAC9B,cAAc,CAAE,CAAE,UAAW,MAAO;AACnC,cAAK,KAAE,uBAAW,WAAW,GAAI,GAAI;AACpC,qBAAS,gBAAiB,IAAI;cAC7B;YACD,CAAE;UACH;QACD;QACA,WAAW,CAAE,CAAE,UAAW,MAAO;AAChC,mBAAS,gBAAiB,IAAI;YAC7B;UACD,CAAE;QACH;QACA,SAAS,CAAE,UAAW;AACrB,mBAAS,WAAY,IAAI,KAAM;QAChC;MACD,CAAE;IACH;EACD;AAOO,WAAS,aAAc,IAAkB;AAC/C,WAAO,OAAQ,EAAE,QAAAA,SAAQ,SAAS,MAAkB;AACnD,YAAM,OAAOA,QAAO,QAAS,EAAG;AAChC,UAAK,CAAE,MAAO;AACb;MACD;AAEA,YAAM,EAAE,MAAM,GAAG,eAAe,IAC/B,KAAK;AAEN,YAAM,gBAAgBA,QAAO,YAAY,EAAE;AAC3C,UAAK,CAAE,eAAgB;AAEtB,iBAAS,gBAAiB,IAAI,CAAC,CAAE;AACjC;MACD;AAEA,oBAAe;QACd,MAAM,KAAK;QACX,cAAc;QACd;QACA,QAAQ,KAAK,iBAAiB;QAC9B,cAAc,CAAE,CAAE,UAAW,MAAO;AACnC,mBAAS,gBAAiB,IAAI,EAAE,WAAW,CAAE;AAC7C,mBAAS,mBAAoB,IAAe;QAC7C;QACA,SAAS,CAAE,UAAW;AACrB,mBAAS,WAAY,IAAI,KAAM;AAC/B,mBAAS,mBAAoB,IAAe;QAC7C;MACD,CAAE;IACH;EACD;AAUO,WAAS,eAAgB,IAAiB,MAA4B;AAC5E,WAAO,OAAQ,EAAE,QAAAA,SAAQ,SAAS,MAAkB;AACnD,YAAM,OAAOA,QAAO,QAAS,EAAG;AAChC,UAAK,CAAE,MAAO;AACb;MACD;AAEA,UAAK,CAAE,MAAM,QAAS;AACrB,iBAAS,gBAAiB,IAAI;UAC7B,MAAM,KAAK;QACZ,CAAE;AACF;MACD;AAGA,YAAM,YAAY,QAAS,KAAK,QAAS;AAEzC,YAAM,eAAe,QAAS,KAAK,iBAAkB;AAErD,UAAI;AACH,cAAM,OAAO,MAAM;UAClB,KAAK;UACL,KAAK;UACL,KAAK;UACL;;UACA;UACA,KAAK,iBAAiB;UACtB;QACD;AAEA,cAAM,cAAU,2BAAe,IAAK;AACpC,iBAAgC;UAC/B,MAAM,KAAK;UACX;UACA;QACD,CAAE;AAEF,iBAAS,gBAAiB,IAAI;UAC7B;UACA,YAAY;YACX,KAAK;UACN;QACD,CAAE;MACH,SAAU,OAAQ;AACjB,iBAAS;UACR;UACA,IAAI,YAAa;YAChB,MAAM;YACN,SAAS;YACT,MAAM,KAAK;YACX,OAAO,iBAAiB,QAAQ,QAAQ;UACzC,CAAE;QACH;MACD;IACD;EACD;AAcO,WAAS,WAAY,IAAiB,MAAwB;AACpE,WAAO,OAAQ,EAAE,QAAAA,SAAQ,SAAS,MAAkB;AACnD,YAAM,OAAOA,QAAO,QAAS,EAAG;AAChC,UAAK,CAAE,MAAO;AACb;MACD;AAGA,UAAK,CAAE,MAAM,eAAe,KAAK,gBAAgB,GAAI;AACpD,iBAAS,gBAAiB,IAAI;UAC7B,MAAM,KAAK;QACZ,CAAE;AACF;MACD;AAEA,UAAI;AACH,cAAM,OAAO,MAAM;UAClB,KAAK;UACL,KAAK;UACL,KAAK;UACL,KAAK,iBAAiB;QACvB;AAEA,cAAM,cAAU,2BAAe,IAAK;AACpC,iBAAgC;UAC/B,MAAM,KAAK;UACX;UACA;QACD,CAAE;AAEF,iBAAS,gBAAiB,IAAI;UAC7B;UACA,YAAY;YACX,KAAK;UACN;QACD,CAAE;MACH,SAAU,OAAQ;AACjB,iBAAS;UACR;UACA,IAAI,YAAa;YAChB,MAAM;YACN,SAAS;YACT,MAAM,KAAK;YACX,OAAO,iBAAiB,QAAQ,QAAQ;UACzC,CAAE;QACH;MACD;IACD;EACD;AAaO,WAAS,mBACf,IACA,MACC;AACD,WAAO,OAAQ,EAAE,QAAAA,SAAQ,SAAS,MAAkB;AACnD,YAAM,OAAOA,QAAO,QAAS,EAAG;AAChC,UAAK,CAAE,MAAO;AACb;MACD;AAGA,UAAK,CAAE,MAAM,cAAe;AAC3B,iBAAS,gBAAiB,IAAI;UAC7B,MAAM,KAAK;QACZ,CAAE;AACF;MACD;AAEA,YAAM,iBAAiB,SAAU,KAAK,YAAa;AAMnD,YAAM,UAAU,KAAK,iBAAiB;AACtC,YAAM,aAAa,KAAK,cAAc;AAEtC,UAAI;AACH,cAAM,OAAO,MAAM;UAClB,KAAK;UACL,KAAK;UACL;UACA;UACA;QACD;AAEA,cAAM,cAAU,2BAAe,IAAK;AACpC,iBAAgC;UAC/B,MAAM,KAAK;UACX;UACA;QACD,CAAE;AAEF,iBAAS,gBAAiB,IAAI;UAC7B;UACA,YAAY;YACX,KAAK;UACN;QACD,CAAE;MACH,SAAU,OAAQ;AACjB,iBAAS;UACR;UACA,IAAI,YAAa;YAChB,MAAM;YACN,SACC;YACD,MAAM,KAAK;YACX,OAAO,iBAAiB,QAAQ,QAAQ;UACzC,CAAE;QACH;MACD;IACD;EACD;AAUO,WAAS,mBAAoB,IAAkB;AACrD,WAAO,OAAQ,EAAE,QAAAA,SAAQ,SAAS,MAAkB;AACnD,YAAM,OAAOA,QAAO,QAAS,EAAG;AAChC,UAAK,CAAE,MAAO;AACb;MACD;AAEA,UAAK,CAAE,KAAK,YAAa;AACxB,iBAAS,gBAAiB,IAAI,CAAC,CAAE;AACjC;MACD;AACA,YAAM,aAAa,KAAK;AAKxB,YAAM,gBACL,WAAW,oBACX,WAAW,qBAAqB,KAChC,CAAE,KAAK,KAAK,KAAK,SAAU,SAAU;AAItC,UAAK,iBAAiB,WAAW,IAAK;AACrC,YAAI;AACH,gBAAM,cAAc,MAAM;YACzB,KAAK;YACL,KAAK;YACL,WAAW;YACX,KAAK,iBAAiB;UACvB;AAIA,mBAAS,gBAAiB;YACzB,MAAM;YACN,SAAS,WAAO;YAChB,UAAU,KAAK;YACf,gBAAgB;cACf,MAAM,WAAW;cACjB,YAAY;cACZ,gBAAgB;YACjB;YACA,YAAY,CAAE,cAAc,MAAO;UACpC,CAAE;QACH,QAAQ;AAIP,kBAAQ;YACP;UACD;QACD;MACD;AAGA,UACC,CAAE,KAAK,YACP,WAAW,uBACX,WAAW,oBAAoB,SAAS,GACvC;AAID,cAAM,OAAO,WAAW,iBACrB,WAAY,KAAK,YAAY,WAAW,cAAe,IACvD,KAAK;AACR,cAAM,UAAU,WAAO;AAEvB,cAAM,WAAWA,QAAO,YAAY;AACpC,cAAM,gBAAgB,SAAS,iBAAiB,CAAC;AACjD,cAAM,EAAE,mBAAmB,IAAI;AAK/B,cAAM,aAAa,KAAK,WAAW;AACnC,cAAM,iBAAiB,qBAAsB,UAAW;AAExD,YAAI,8BAKM;AAEV,YAAK,kBAAkB,mBAAmB,YAAa;AACtD,wCAA8B,MAAM;YACnC,KAAK;YACL;YACA;UACD;QACD;AAEA,mBAAY,QAAQ,WAAW,qBAAsB;AACpD,gBAAM,YAAY,cAAe,IAAK;AACtC,cAAK,CAAE,WAAY;AAElB,oBAAQ;cACP,eAAgB,IAAK;YACtB;AACA;UACD;AAGA,gBAAM,sBAAmC;YACxC,CAAE,cAAc,YAAY,EAAE,QAAQ,UAAU,CAAE;UACnD;AAIA,cAAK,6BAA8B;AAClC,gCAAoB,KAAM,2BAA4B;UACvD;AAEA,8BAAoB,KAAM,cAAc,MAAO;AAE/C,mBAAS,gBAAiB;YACzB;YACA,UAAU,CAAE,CAAE,iBAAkB,MAAO;AAItC,sBAAK,uBAAW,kBAAkB,GAAI,GAAI;AACzC;cACD;AAIA,mBAAK,WAAY,CAAE,iBAAkB,CAAE;YACxC;YACA;YACA,UAAU,KAAK;YACf,gBAAgB;;;cAGf,MAAM,WAAW;cACjB,YAAY;cACZ,gBAAgB;YACjB;YACA,YAAY;UACb,CAAE;QACH;MACD;AAEA,eAAS,gBAAiB,IAAI,CAAC,CAAE;IAClC;EACD;AAOO,WAAS,eAAgB,IAAkB;AACjD,WAAO,OAAQ,EAAE,QAAAA,SAAQ,SAAS,MAAkB;AACnD,YAAM,WAAWA,QAAO,YAAa,EAAG;AAExC,iBAAY,WAAW,UAAW;AACjC,uCAAe,OAAQ;MACxB;AAEA,eAAkC;QACjC,MAAM,KAAK;QACX;MACD,CAAE;IACH;EACD;AAQO,WAAS,mBAAoB,IAAiB,UAAmB;AACvE,WAAO,OAAQ,EAAE,SAAS,MAAkB;AAC3C,eAAkC;QACjC,MAAM,KAAK;QACX;QACA;MACD,CAAE;IACH;EACD;AAUO,WAAS,eACf,UACuB;AACvB,WAAO;MACN,MAAM,KAAK;MACX;IACD;EACD;;;AE7uCA,4BAAiE;AAE1D,MAAM,EAAE,MAAM,OAAO,QAC3B;IACC;IACA;EACD;;;ArBYM,MAAM,cAAc;IAC1B;IACA;IACA;EACD;AAOO,MAAM,YAAQ,8BAAkB,YAAY;IAClD;IACA;IACA;EACD,CAAE;AAIF,MAAK,KAAE,oBAAQ,KAAM,GAAI;AACxB,8BAAU,KAAM;EACjB;AAEA,SAAQ,KAAM,EAAE,uBAAwB,uBAAe;AAEvD,SAAQ,KAAM,EAAE,yBAA0B,yBAAiB;;;AsB3C3D,MAAAC,kBAA0B;AAC1B,MAAAC,eAA4B;;;ACD5B,uBAAyB;AACzB,MAAAC,eAA8D;AAC9D,uBAA2C;AAyChC,2BAAA;AA/BX,WAAS,eACR,eACA,UACA,gBACC;AACD,QAAK,CAAE,gBAAiB;AACvB,aAAO;IACR;AACA,QAAI,cAAc,cAAc,IAAK,QAAS;AAC9C,QAAK,CAAE,aAAc;AACpB,wBAAc,6BAAgB,CAAC,GAAG,QAAS;AAC3C,kBAAY,cAAe,YAAsB,WAAY;AAC7D,oBAAc,IAAK,UAAU,WAAY;IAC1C;AACA,WAAO;EACR;AAEA,MAAM,2BAAuB;IAC5B,CAAE,qBACD,CAAE,EAAE,iBAAiB,MAAM,GAAG,MAAM,MAAO;AAC1C,YAAM,eAAW,0BAAY;AAC7B,YAAM,CAAE,aAAc,QAAI,yBAEvB,MAAM,oBAAI,QAAQ,CAAE;AACvB,YAAM,cAAc;QACnB;QACA;QACA;MACD;AAEA,UAAK,gBAAgB,UAAW;AAC/B,eAAO,4CAAC,kBAAA,EAAiB,UAAwB,GAAG,MAAA,CAAQ;MAC7D;AAEA,aACC,4CAAC,+BAAA,EAAiB,OAAQ,aACzB,UAAA,4CAAC,kBAAA,EAAiB,UAAW,aAAgB,GAAG,MAAA,CAAQ,EAAA,CACzD;IAEF;IACD;EACD;AAEA,MAAO,iCAAQ;;;ADrCP,MAAAC,sBAAA;AARR,MAAM,sBAAsB,+BAAsB,CAAE,UAAgB;AACnE,UAAM,EAAE,UAAU,SAAS,IAAI;AAC/B,UAAM,EAAE,gBAAAC,gBAAe,IAAI,WAAQ,0BAAa,KAAY,CAAE;AAE9D,mCAAW,MAAM;AAChB,MAAAA,gBAAgB,QAAS;IAC1B,GAAG,CAAE,UAAUA,eAAe,CAAE;AAEhC,WAAO,6CAAA,8BAAA,EAAI,SAAA,CAAU;EACtB,CAAE;AAEF,MAAO,mBAAQ;;;AEPf,MAAI,eAA8C;AAY3C,WAAS,+BAAuD;AAEtE,QAAK,iBAAiB,MAAO;AAC5B,aAAO;IACR;AAGA,QAAK,OAAO,gBAAgB,aAAc;AACzC,qBAAe;QACd,WAAW;QACX,QAAQ;MACT;AACA,aAAO;IACR;AAGA,QAAK,OAAO,sBAAsB,aAAc;AAC/C,qBAAe;QACd,WAAW;QACX,QAAQ;MACT;AACA,aAAO;IACR;AAKA,QAAK,OAAO,WAAW,eAAe,OAAO,WAAW,aAAc;AACrE,UAAI;AACH,cAAM,WAAW,IAAI,KAAM,CAAE,EAAG,GAAG;UAClC,MAAM;QACP,CAAE;AACF,cAAM,UAAU,IAAI,gBAAiB,QAAS;AAC9C,YAAI;AACH,gBAAM,aAAa,IAAI,OAAQ,OAAQ;AACvC,qBAAW,UAAU;QACtB,UAAA;AACC,cAAI,gBAAiB,OAAQ;QAC9B;MACD,QAAQ;AACP,uBAAe;UACd,WAAW;UACX,QAAQ;QACT;AACA,eAAO;MACR;IACD;AAEA,mBAAe,EAAE,WAAW,KAAK;AACjC,WAAO;EACR;AASO,WAAS,6BAAsC;AACrD,WAAO,6BAA6B,EAAE;EACvC;AAOO,WAAS,6BAAmC;AAClD,mBAAe;EAChB;",
  "names": ["Type", "ItemStatus", "OperationType", "import_i18n", "import_i18n", "import_i18n", "select", "select", "import_element", "import_data", "import_data", "import_jsx_runtime", "updateSettings"]
}
