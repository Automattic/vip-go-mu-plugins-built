{
  "version": 3,
  "sources": ["package-external:@wordpress/data", "package-external:@wordpress/url", "package-external:@wordpress/i18n", "package-external:@wordpress/blob", "package-external:@wordpress/private-apis", "package-external:@wordpress/element", "package-external:@wordpress/compose", "vendor-external:react/jsx-runtime", "../../../packages/upload-media/src/store/index.ts", "../../../packages/upload-media/src/store/types.ts", "../../../packages/upload-media/src/store/constants.ts", "../../../packages/upload-media/src/store/reducer.ts", "../../../packages/upload-media/src/store/selectors.ts", "../../../packages/upload-media/src/store/private-selectors.ts", "../../../node_modules/uuid/dist/esm-browser/rng.js", "../../../node_modules/uuid/dist/esm-browser/stringify.js", "../../../node_modules/uuid/dist/esm-browser/native.js", "../../../node_modules/uuid/dist/esm-browser/v4.js", "../../../packages/upload-media/src/image-file.ts", "../../../packages/upload-media/src/utils.ts", "../../../packages/upload-media/src/store/utils/index.ts", "../../../packages/upload-media/src/validate-mime-type.ts", "../../../packages/upload-media/src/upload-error.ts", "../../../packages/upload-media/src/validate-mime-type-for-user.ts", "../../../packages/upload-media/src/get-mime-types-array.ts", "../../../packages/upload-media/src/validate-file-size.ts", "../../../packages/upload-media/src/store/actions.ts", "../../../packages/upload-media/src/store/private-actions.ts", "../../../packages/upload-media/src/stub-file.ts", "../../../packages/upload-media/src/lock-unlock.ts", "../../../packages/upload-media/src/components/provider/index.tsx", "../../../packages/upload-media/src/components/provider/with-registry-provider.tsx", "../../../packages/upload-media/src/feature-detection.ts"],
  "sourcesContent": ["module.exports = window.wp.data;", "module.exports = window.wp.url;", "module.exports = window.wp.i18n;", "module.exports = window.wp.blob;", "module.exports = window.wp.privateApis;", "module.exports = window.wp.element;", "module.exports = window.wp.compose;", "module.exports = window.ReactJSXRuntime;", "/**\n * WordPress dependencies\n */\nimport { createReduxStore, register, select } from '@wordpress/data';\n\n/**\n * Internal dependencies\n */\nimport reducer from './reducer';\nimport * as selectors from './selectors';\nimport * as privateSelectors from './private-selectors';\nimport * as actions from './actions';\nimport * as privateActions from './private-actions';\nimport { unlock } from '../lock-unlock';\nimport { STORE_NAME } from './constants';\n\n/**\n * Media upload data store configuration.\n *\n * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/data/README.md#registerStore\n */\nexport const storeConfig = {\n\treducer,\n\tselectors,\n\tactions,\n};\n\n/**\n * Store definition for the media upload namespace.\n *\n * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/data/README.md#createReduxStore\n */\nexport const store = createReduxStore( STORE_NAME, {\n\treducer,\n\tselectors,\n\tactions,\n} );\n\n// The upload-media package is bundled into multiple packages (block-editor, editor).\n// Guard against duplicate registration when both bundles are loaded on the same page.\nif ( ! select( store ) ) {\n\tregister( store );\n}\n// @ts-ignore\nunlock( store ).registerPrivateActions( privateActions );\n// @ts-ignore\nunlock( store ).registerPrivateSelectors( privateSelectors );\n", "export type QueueItemId = string;\n\nexport type QueueStatus = 'active' | 'paused';\n\nexport type BatchId = string;\n\nexport interface QueueItem {\n\tid: QueueItemId;\n\tsourceFile: File;\n\tfile: File;\n\tposter?: File;\n\tattachment?: Partial< Attachment >;\n\tstatus: ItemStatus;\n\tadditionalData: AdditionalData;\n\tonChange?: OnChangeHandler;\n\tonSuccess?: OnSuccessHandler;\n\tonError?: OnErrorHandler;\n\tonBatchSuccess?: OnBatchSuccessHandler;\n\tcurrentOperation?: OperationType;\n\toperations?: Operation[];\n\terror?: Error;\n\tretryCount?: number;\n\tprogress?: number;\n\tbatchId?: string;\n\tsourceUrl?: string;\n\tsourceAttachmentId?: number;\n\tabortController?: AbortController;\n\tparentId?: QueueItemId;\n}\n\nexport interface State {\n\tqueue: QueueItem[];\n\tqueueStatus: QueueStatus;\n\tblobUrls: Record< QueueItemId, string[] >;\n\tsettings: Settings;\n}\n\nexport enum Type {\n\tUnknown = 'REDUX_UNKNOWN',\n\tAdd = 'ADD_ITEM',\n\tPrepare = 'PREPARE_ITEM',\n\tCancel = 'CANCEL_ITEM',\n\tRemove = 'REMOVE_ITEM',\n\tRetryItem = 'RETRY_ITEM',\n\tPauseItem = 'PAUSE_ITEM',\n\tResumeItem = 'RESUME_ITEM',\n\tPauseQueue = 'PAUSE_QUEUE',\n\tResumeQueue = 'RESUME_QUEUE',\n\tOperationStart = 'OPERATION_START',\n\tOperationFinish = 'OPERATION_FINISH',\n\tAddOperations = 'ADD_OPERATIONS',\n\tCacheBlobUrl = 'CACHE_BLOB_URL',\n\tRevokeBlobUrls = 'REVOKE_BLOB_URLS',\n\tUpdateProgress = 'UPDATE_PROGRESS',\n\tUpdateSettings = 'UPDATE_SETTINGS',\n}\n\ntype Action< T = Type, Payload = Record< string, unknown > > = {\n\ttype: T;\n} & Payload;\n\nexport type UnknownAction = Action< Type.Unknown >;\nexport type AddAction = Action<\n\tType.Add,\n\t{\n\t\titem: Omit< QueueItem, 'operations' > &\n\t\t\tPartial< Pick< QueueItem, 'operations' > >;\n\t}\n>;\nexport type OperationStartAction = Action<\n\tType.OperationStart,\n\t{ id: QueueItemId; operation: OperationType }\n>;\nexport type OperationFinishAction = Action<\n\tType.OperationFinish,\n\t{\n\t\tid: QueueItemId;\n\t\titem: Partial< QueueItem >;\n\t}\n>;\nexport type AddOperationsAction = Action<\n\tType.AddOperations,\n\t{ id: QueueItemId; operations: Operation[] }\n>;\nexport type CancelAction = Action<\n\tType.Cancel,\n\t{ id: QueueItemId; error: Error }\n>;\nexport type RetryItemAction = Action< Type.RetryItem, { id: QueueItemId } >;\nexport type PauseItemAction = Action< Type.PauseItem, { id: QueueItemId } >;\nexport type ResumeItemAction = Action< Type.ResumeItem, { id: QueueItemId } >;\nexport type PauseQueueAction = Action< Type.PauseQueue >;\nexport type ResumeQueueAction = Action< Type.ResumeQueue >;\nexport type RemoveAction = Action< Type.Remove, { id: QueueItemId } >;\nexport type CacheBlobUrlAction = Action<\n\tType.CacheBlobUrl,\n\t{ id: QueueItemId; blobUrl: string }\n>;\nexport type RevokeBlobUrlsAction = Action<\n\tType.RevokeBlobUrls,\n\t{ id: QueueItemId }\n>;\nexport type UpdateProgressAction = Action<\n\tType.UpdateProgress,\n\t{ id: QueueItemId; progress: number }\n>;\nexport type UpdateSettingsAction = Action<\n\tType.UpdateSettings,\n\t{ settings: Partial< Settings > }\n>;\n\ninterface UploadMediaArgs {\n\t// Additional data to include in the request.\n\tadditionalData?: AdditionalData;\n\t// Array with the types of media that can be uploaded, if unset all types are allowed.\n\tallowedTypes?: string[];\n\t// List of files.\n\tfilesList: File[];\n\t// Maximum upload size in bytes allowed for the site.\n\tmaxUploadFileSize?: number;\n\t// Function called when an error happens.\n\tonError?: OnErrorHandler;\n\t// Function called each time a file or a temporary representation of the file is available.\n\tonFileChange?: OnChangeHandler;\n\t// Function called once a file has completely finished uploading, including thumbnails.\n\tonSuccess?: OnSuccessHandler;\n\t// List of allowed mime types and file extensions.\n\twpAllowedMimeTypes?: Record< string, string > | null;\n\t// Abort signal.\n\tsignal?: AbortSignal;\n}\n\n/**\n * Arguments for sideloading a file to an existing attachment.\n *\n * Sideloading adds additional image sizes (thumbnails) to an already\n * uploaded attachment without creating a new attachment.\n */\nexport interface SideloadMediaArgs {\n\t/** File to sideload (typically a resized version of the original). */\n\tfile: File;\n\t/** Attachment ID to add the sideloaded file to. */\n\tattachmentId: number;\n\t/** Additional data to include in the request. */\n\tadditionalData?: AdditionalData;\n\t/** Function called when an error happens. */\n\tonError?: OnErrorHandler;\n\t/** Function called when the file or a temporary representation is available. */\n\tonFileChange?: OnChangeHandler;\n\t/** Abort signal to cancel the sideload operation. */\n\tsignal?: AbortSignal;\n}\n\nexport interface Settings {\n\t// Registered image sizes from the server.\n\tallImageSizes?: Record< string, ImageSizeCrop >;\n\t// Function for uploading files to the server.\n\tmediaUpload: ( args: UploadMediaArgs ) => void;\n\t// Function for sideloading files to existing attachments.\n\tmediaSideload?: ( args: SideloadMediaArgs ) => void;\n\t// List of allowed mime types and file extensions.\n\tallowedMimeTypes?: Record< string, string > | null;\n\t// Maximum upload file size.\n\tmaxUploadFileSize?: number;\n\t// Maximum number of concurrent uploads.\n\tmaxConcurrentUploads: number;\n\t// Maximum number of concurrent image processing operations (resize, crop, rotate).\n\tmaxConcurrentImageProcessing: number;\n\t// Big image size threshold in pixels.\n\t// Images larger than this will be scaled down.\n\t// Default is 2560 (matching WordPress core).\n\tbigImageSizeThreshold?: number;\n\t// Map of source MIME types to output MIME types for transcoding.\n\timageOutputFormats?: Record< string, string >;\n\t// Whether to use progressive/interlaced encoding for JPEG.\n\tjpegInterlaced?: boolean;\n\t// Whether to use interlaced encoding for PNG.\n\tpngInterlaced?: boolean;\n\t// Whether to use interlaced encoding for GIF.\n\tgifInterlaced?: boolean;\n}\n\n// Matches the Attachment type from the media-utils package.\nexport interface Attachment {\n\tid: number;\n\talt: string;\n\tcaption: string;\n\ttitle: string;\n\turl: string;\n\tfilename: string | null;\n\tfilesize: number | null;\n\tmedia_type: 'image' | 'file';\n\tmime_type: string;\n\tfeatured_media?: number;\n\tmissing_image_sizes?: string[];\n\tmedia_filename?: string;\n\tposter?: string;\n\t/**\n\t * EXIF orientation value from the original image.\n\t * Values 1-8 follow the EXIF specification.\n\t * A value other than 1 indicates the image needs rotation.\n\t *\n\t * Orientation values:\n\t * 1 = Normal (no rotation needed)\n\t * 2 = Flipped horizontally\n\t * 3 = Rotated 180\u00B0\n\t * 4 = Flipped vertically\n\t * 5 = Rotated 90\u00B0 CCW and flipped horizontally\n\t * 6 = Rotated 90\u00B0 CW\n\t * 7 = Rotated 90\u00B0 CW and flipped horizontally\n\t * 8 = Rotated 90\u00B0 CCW\n\t */\n\texif_orientation?: number;\n}\n\nexport type OnChangeHandler = ( attachments: Partial< Attachment >[] ) => void;\nexport type OnSuccessHandler = ( attachments: Partial< Attachment >[] ) => void;\nexport type OnErrorHandler = ( error: Error ) => void;\nexport type OnBatchSuccessHandler = () => void;\n\nexport enum ItemStatus {\n\tQueued = 'QUEUED',\n\tProcessing = 'PROCESSING',\n\tPaused = 'PAUSED',\n\tUploaded = 'UPLOADED',\n\tError = 'ERROR',\n}\n\nexport enum OperationType {\n\tPrepare = 'PREPARE',\n\tUpload = 'UPLOAD',\n\tResizeCrop = 'RESIZE_CROP',\n\tRotate = 'ROTATE',\n\tTranscodeImage = 'TRANSCODE_IMAGE',\n\tThumbnailGeneration = 'THUMBNAIL_GENERATION',\n}\n\n/**\n * Defines the dimensions and cropping behavior for an image size.\n */\nexport interface ImageSizeCrop {\n\t/** Target width in pixels. */\n\twidth: number;\n\t/** Target height in pixels. */\n\theight: number;\n\t/**\n\t * Crop behavior.\n\t * - `true` for hard crop centered.\n\t * - Positional array like `['left', 'top']` for specific crop anchor.\n\t * - `false` or undefined for soft proportional resize.\n\t */\n\tcrop?:\n\t\t| boolean\n\t\t| [ 'left' | 'center' | 'right', 'top' | 'center' | 'bottom' ];\n\t/** Size name identifier (e.g., 'thumbnail', 'medium'). */\n\tname?: string;\n}\n\nexport interface OperationArgs {\n\t[ OperationType.ResizeCrop ]: {\n\t\tresize: ImageSizeCrop;\n\t\t/**\n\t\t * Whether this resize is for the big image size threshold.\n\t\t * If true, uses '-scaled' suffix instead of dimension suffix.\n\t\t */\n\t\tisThresholdResize?: boolean;\n\t};\n\t[ OperationType.Rotate ]: {\n\t\t/**\n\t\t * EXIF orientation value (1-8) indicating the required rotation.\n\t\t * Used to apply the correct rotation/flip transformation.\n\t\t */\n\t\torientation: number;\n\t};\n\t[ OperationType.TranscodeImage ]: {\n\t\t/** Target output format. */\n\t\toutputFormat: ImageFormat;\n\t\t/** Quality setting (0-1). */\n\t\toutputQuality: number;\n\t\t/** Whether to use interlaced encoding. */\n\t\tinterlaced: boolean;\n\t};\n}\n\ntype OperationWithArgs< T extends keyof OperationArgs = keyof OperationArgs > =\n\t[ T, OperationArgs[ T ] ];\n\nexport type Operation = OperationType | OperationWithArgs;\n\nexport type AdditionalData = Record< string, unknown >;\n\n/**\n * Additional data specific to sideload operations.\n *\n * This extends the base AdditionalData with fields required for\n * sideloading image sizes to an existing attachment.\n */\nexport interface SideloadAdditionalData extends AdditionalData {\n\t/** The attachment ID to add the image size to. */\n\tpost: number;\n\t/** The name of the image size being generated (e.g., 'thumbnail', 'medium'). */\n\timage_size: string;\n}\n\nexport type ImageFormat = 'jpeg' | 'webp' | 'avif' | 'png' | 'gif';\n", "export const STORE_NAME = 'core/upload-media';\n\n/**\n * Default maximum number of concurrent uploads.\n */\nexport const DEFAULT_MAX_CONCURRENT_UPLOADS = 5;\n\n/**\n * Default maximum number of concurrent image processing operations.\n *\n * Image processing (VIPS WASM) is significantly more memory-intensive\n * than network uploads. Each operation can consume 50-100MB+ of memory\n * for large images. A lower limit prevents out-of-memory crashes when\n * uploading many images at once.\n */\nexport const DEFAULT_MAX_CONCURRENT_IMAGE_PROCESSING = 2;\n\n/**\n * MIME types supported by client-side media processing.\n *\n * These are the image formats that can be processed using\n * WebAssembly-based vips in the browser.\n */\nexport const CLIENT_SIDE_SUPPORTED_MIME_TYPES: readonly string[] = [\n\t'image/jpeg',\n\t'image/png',\n\t'image/gif',\n\t'image/webp',\n\t'image/avif',\n] as const;\n", "/**\n * Internal dependencies\n */\nimport {\n\ttype AddAction,\n\ttype AddOperationsAction,\n\ttype CacheBlobUrlAction,\n\ttype CancelAction,\n\tItemStatus,\n\ttype OperationFinishAction,\n\ttype OperationStartAction,\n\ttype PauseItemAction,\n\ttype PauseQueueAction,\n\ttype QueueItem,\n\ttype RemoveAction,\n\ttype ResumeItemAction,\n\ttype ResumeQueueAction,\n\ttype RetryItemAction,\n\ttype RevokeBlobUrlsAction,\n\ttype State,\n\tType,\n\ttype UnknownAction,\n\ttype UpdateProgressAction,\n\ttype UpdateSettingsAction,\n} from './types';\nimport {\n\tDEFAULT_MAX_CONCURRENT_UPLOADS,\n\tDEFAULT_MAX_CONCURRENT_IMAGE_PROCESSING,\n} from './constants';\n\nconst noop = () => {};\n\nconst DEFAULT_STATE: State = {\n\tqueue: [],\n\tqueueStatus: 'active',\n\tblobUrls: {},\n\tsettings: {\n\t\tmediaUpload: noop,\n\t\tmaxConcurrentUploads: DEFAULT_MAX_CONCURRENT_UPLOADS,\n\t\tmaxConcurrentImageProcessing: DEFAULT_MAX_CONCURRENT_IMAGE_PROCESSING,\n\t},\n};\n\ntype Action =\n\t| AddAction\n\t| RemoveAction\n\t| CancelAction\n\t| RetryItemAction\n\t| PauseItemAction\n\t| ResumeItemAction\n\t| PauseQueueAction\n\t| ResumeQueueAction\n\t| AddOperationsAction\n\t| OperationFinishAction\n\t| OperationStartAction\n\t| CacheBlobUrlAction\n\t| RevokeBlobUrlsAction\n\t| UpdateProgressAction\n\t| UpdateSettingsAction\n\t| UnknownAction;\n\nfunction reducer(\n\tstate = DEFAULT_STATE,\n\taction: Action = { type: Type.Unknown }\n) {\n\tswitch ( action.type ) {\n\t\tcase Type.PauseQueue: {\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tqueueStatus: 'paused',\n\t\t\t};\n\t\t}\n\n\t\tcase Type.ResumeQueue: {\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tqueueStatus: 'active',\n\t\t\t};\n\t\t}\n\n\t\tcase Type.PauseItem:\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tqueue: state.queue.map(\n\t\t\t\t\t( item ): QueueItem =>\n\t\t\t\t\t\titem.id === action.id\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t...item,\n\t\t\t\t\t\t\t\t\tstatus: ItemStatus.Paused,\n\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t: item\n\t\t\t\t),\n\t\t\t};\n\n\t\tcase Type.ResumeItem:\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tqueue: state.queue.map(\n\t\t\t\t\t( item ): QueueItem =>\n\t\t\t\t\t\titem.id === action.id\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t...item,\n\t\t\t\t\t\t\t\t\tstatus: ItemStatus.Processing,\n\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t: item\n\t\t\t\t),\n\t\t\t};\n\n\t\tcase Type.Add:\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tqueue: [ ...state.queue, action.item ],\n\t\t\t};\n\n\t\tcase Type.Cancel:\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tqueue: state.queue.map(\n\t\t\t\t\t( item ): QueueItem =>\n\t\t\t\t\t\titem.id === action.id\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t...item,\n\t\t\t\t\t\t\t\t\terror: action.error,\n\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t: item\n\t\t\t\t),\n\t\t\t};\n\n\t\tcase Type.RetryItem:\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tqueue: state.queue.map(\n\t\t\t\t\t( item ): QueueItem =>\n\t\t\t\t\t\titem.id === action.id\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t...item,\n\t\t\t\t\t\t\t\t\tstatus: ItemStatus.Processing,\n\t\t\t\t\t\t\t\t\terror: undefined,\n\t\t\t\t\t\t\t\t\tretryCount: ( item.retryCount ?? 0 ) + 1,\n\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t: item\n\t\t\t\t),\n\t\t\t};\n\n\t\tcase Type.Remove:\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tqueue: state.queue.filter( ( item ) => item.id !== action.id ),\n\t\t\t};\n\n\t\tcase Type.OperationStart: {\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tqueue: state.queue.map(\n\t\t\t\t\t( item ): QueueItem =>\n\t\t\t\t\t\titem.id === action.id\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t...item,\n\t\t\t\t\t\t\t\t\tcurrentOperation: action.operation,\n\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t: item\n\t\t\t\t),\n\t\t\t};\n\t\t}\n\n\t\tcase Type.AddOperations:\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tqueue: state.queue.map( ( item ): QueueItem => {\n\t\t\t\t\tif ( item.id !== action.id ) {\n\t\t\t\t\t\treturn item;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\t...item,\n\t\t\t\t\t\toperations: [\n\t\t\t\t\t\t\t...( item.operations || [] ),\n\t\t\t\t\t\t\t...action.operations,\n\t\t\t\t\t\t],\n\t\t\t\t\t};\n\t\t\t\t} ),\n\t\t\t};\n\n\t\tcase Type.OperationFinish:\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tqueue: state.queue.map( ( item ): QueueItem => {\n\t\t\t\t\tif ( item.id !== action.id ) {\n\t\t\t\t\t\treturn item;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst operations = item.operations\n\t\t\t\t\t\t? item.operations.slice( 1 )\n\t\t\t\t\t\t: [];\n\n\t\t\t\t\t// Prevent an empty object if there's no attachment data.\n\t\t\t\t\tconst attachment =\n\t\t\t\t\t\titem.attachment || action.item.attachment\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t...item.attachment,\n\t\t\t\t\t\t\t\t\t...action.item.attachment,\n\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t: undefined;\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\t...item,\n\t\t\t\t\t\tcurrentOperation: undefined,\n\t\t\t\t\t\toperations,\n\t\t\t\t\t\t...action.item,\n\t\t\t\t\t\tattachment,\n\t\t\t\t\t\tadditionalData: {\n\t\t\t\t\t\t\t...item.additionalData,\n\t\t\t\t\t\t\t...action.item.additionalData,\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t} ),\n\t\t\t};\n\n\t\tcase Type.CacheBlobUrl: {\n\t\t\tconst blobUrls = state.blobUrls[ action.id ] || [];\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tblobUrls: {\n\t\t\t\t\t...state.blobUrls,\n\t\t\t\t\t[ action.id ]: [ ...blobUrls, action.blobUrl ],\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\n\t\tcase Type.RevokeBlobUrls: {\n\t\t\tconst newBlobUrls = { ...state.blobUrls };\n\t\t\tdelete newBlobUrls[ action.id ];\n\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tblobUrls: newBlobUrls,\n\t\t\t};\n\t\t}\n\n\t\tcase Type.UpdateProgress:\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tqueue: state.queue.map(\n\t\t\t\t\t( item ): QueueItem =>\n\t\t\t\t\t\titem.id === action.id\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t...item,\n\t\t\t\t\t\t\t\t\tprogress: action.progress,\n\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t: item\n\t\t\t\t),\n\t\t\t};\n\n\t\tcase Type.UpdateSettings: {\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tsettings: {\n\t\t\t\t\t...state.settings,\n\t\t\t\t\t...action.settings,\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t}\n\n\treturn state;\n}\n\nexport default reducer;\n", "/**\n * Internal dependencies\n */\nimport type { QueueItem, Settings, State } from './types';\n\n/**\n * Returns all items currently being uploaded.\n *\n * @param state Upload state.\n *\n * @return Queue items.\n */\nexport function getItems( state: State ): QueueItem[] {\n\treturn state.queue;\n}\n\n/**\n * Determines whether any upload is currently in progress.\n *\n * @param state Upload state.\n *\n * @return Whether any upload is currently in progress.\n */\nexport function isUploading( state: State ): boolean {\n\treturn state.queue.length >= 1;\n}\n\n/**\n * Determines whether an upload is currently in progress given an attachment URL.\n *\n * @param state Upload state.\n * @param url   Attachment URL.\n *\n * @return Whether upload is currently in progress for the given attachment.\n */\nexport function isUploadingByUrl( state: State, url: string ): boolean {\n\treturn state.queue.some(\n\t\t( item ) => item.attachment?.url === url || item.sourceUrl === url\n\t);\n}\n\n/**\n * Determines whether an upload is currently in progress given an attachment ID.\n *\n * @param state        Upload state.\n * @param attachmentId Attachment ID.\n *\n * @return Whether upload is currently in progress for the given attachment.\n */\nexport function isUploadingById( state: State, attachmentId: number ): boolean {\n\treturn state.queue.some(\n\t\t( item ) =>\n\t\t\titem.attachment?.id === attachmentId ||\n\t\t\titem.sourceAttachmentId === attachmentId\n\t);\n}\n\n/**\n * Returns the media upload settings.\n *\n * @param state Upload state.\n *\n * @return Settings\n */\nexport function getSettings( state: State ): Settings {\n\treturn state.settings;\n}\n", "/**\n * Internal dependencies\n */\nimport {\n\ttype BatchId,\n\tItemStatus,\n\tOperationType,\n\ttype QueueItem,\n\ttype QueueItemId,\n\ttype State,\n} from './types';\n\n/**\n * Returns all items currently being uploaded.\n *\n * @param state Upload state.\n *\n * @return Queue items.\n */\nexport function getAllItems( state: State ): QueueItem[] {\n\treturn state.queue;\n}\n\n/**\n * Returns a specific item given its unique ID.\n *\n * @param state Upload state.\n * @param id    Item ID.\n *\n * @return Queue item.\n */\nexport function getItem(\n\tstate: State,\n\tid: QueueItemId\n): QueueItem | undefined {\n\treturn state.queue.find( ( item ) => item.id === id );\n}\n\n/**\n * Determines whether a batch has been successfully uploaded, given its unique ID.\n *\n * @param state   Upload state.\n * @param batchId Batch ID.\n *\n * @return Whether a batch has been uploaded.\n */\nexport function isBatchUploaded( state: State, batchId: BatchId ): boolean {\n\tconst batchItems = state.queue.filter(\n\t\t( item ) => batchId === item.batchId\n\t);\n\treturn batchItems.length === 0;\n}\n\n/**\n * Determines whether an upload is currently in progress given a post or attachment ID.\n *\n * @param state              Upload state.\n * @param postOrAttachmentId Post ID or attachment ID.\n *\n * @return Whether upload is currently in progress for the given post or attachment.\n */\nexport function isUploadingToPost(\n\tstate: State,\n\tpostOrAttachmentId: number\n): boolean {\n\treturn state.queue.some(\n\t\t( item ) =>\n\t\t\titem.currentOperation === OperationType.Upload &&\n\t\t\titem.additionalData.post === postOrAttachmentId\n\t);\n}\n\n/**\n * Returns the next paused upload for a given post or attachment ID.\n *\n * @param state              Upload state.\n * @param postOrAttachmentId Post ID or attachment ID.\n *\n * @return Paused item.\n */\nexport function getPausedUploadForPost(\n\tstate: State,\n\tpostOrAttachmentId: number\n): QueueItem | undefined {\n\treturn state.queue.find(\n\t\t( item ) =>\n\t\t\titem.status === ItemStatus.Paused &&\n\t\t\titem.additionalData.post === postOrAttachmentId\n\t);\n}\n\n/**\n * Determines whether uploading is currently paused.\n *\n * @param state Upload state.\n *\n * @return Whether uploading is currently paused.\n */\nexport function isPaused( state: State ): boolean {\n\treturn state.queueStatus === 'paused';\n}\n\n/**\n * Returns all cached blob URLs for a given item ID.\n *\n * @param state Upload state.\n * @param id    Item ID\n *\n * @return List of blob URLs.\n */\nexport function getBlobUrls( state: State, id: QueueItemId ): string[] {\n\treturn state.blobUrls[ id ] || [];\n}\n\n/**\n * Returns the number of items currently uploading.\n *\n * @param state Upload state.\n *\n * @return Number of items currently uploading.\n */\nexport function getActiveUploadCount( state: State ): number {\n\treturn state.queue.filter(\n\t\t( item ) => item.currentOperation === OperationType.Upload\n\t).length;\n}\n\n/**\n * Returns items that are waiting for upload (next operation is Upload but not yet started).\n *\n * @param state Upload state.\n *\n * @return Items pending upload.\n */\nexport function getPendingUploads( state: State ): QueueItem[] {\n\treturn state.queue.filter( ( item ) => {\n\t\tconst nextOperation = Array.isArray( item.operations?.[ 0 ] )\n\t\t\t? item.operations[ 0 ][ 0 ]\n\t\t\t: item.operations?.[ 0 ];\n\t\treturn (\n\t\t\tnextOperation === OperationType.Upload &&\n\t\t\titem.currentOperation !== OperationType.Upload\n\t\t);\n\t} );\n}\n\n/**\n * Returns the number of items currently performing image processing operations.\n *\n * This counts items whose current operation is ResizeCrop or Rotate,\n * used to enforce the image processing concurrency limit.\n *\n * @param state Upload state.\n *\n * @return Number of items currently processing images.\n */\nexport function getActiveImageProcessingCount( state: State ): number {\n\treturn state.queue.filter(\n\t\t( item ) =>\n\t\t\titem.currentOperation === OperationType.ResizeCrop ||\n\t\t\titem.currentOperation === OperationType.Rotate\n\t).length;\n}\n\n/**\n * Returns items waiting for image processing (next operation is ResizeCrop\n * or Rotate but not yet started).\n *\n * @param state Upload state.\n *\n * @return Items pending image processing.\n */\nexport function getPendingImageProcessing( state: State ): QueueItem[] {\n\treturn state.queue.filter( ( item ) => {\n\t\tconst nextOperation = Array.isArray( item.operations?.[ 0 ] )\n\t\t\t? item.operations[ 0 ][ 0 ]\n\t\t\t: item.operations?.[ 0 ];\n\t\treturn (\n\t\t\t( nextOperation === OperationType.ResizeCrop ||\n\t\t\t\tnextOperation === OperationType.Rotate ) &&\n\t\t\titem.currentOperation !== OperationType.ResizeCrop &&\n\t\t\titem.currentOperation !== OperationType.Rotate\n\t\t);\n\t} );\n}\n\n/**\n * Returns items that failed with an error.\n *\n * @param state Upload state.\n *\n * @return Failed items.\n */\nexport function getFailedItems( state: State ): QueueItem[] {\n\treturn state.queue.filter( ( item ) => item.error !== undefined );\n}\n\n/**\n * Returns true if any child items with the given parentId exist in the queue.\n *\n * @param state    Upload state.\n * @param parentId Parent item ID.\n *\n * @return Whether any child items with the given parentId exist in the queue.\n */\nexport function hasPendingItemsByParentId(\n\tstate: State,\n\tparentId: QueueItemId\n): boolean {\n\treturn state.queue.some( ( item ) => item.parentId === parentId );\n}\n\n/**\n * Returns the progress of a specific item.\n *\n * @param state Upload state.\n * @param id    Item ID.\n *\n * @return Progress value (0-100), or undefined if item not found.\n */\nexport function getItemProgress(\n\tstate: State,\n\tid: QueueItemId\n): number | undefined {\n\tconst item = state.queue.find( ( i ) => i.id === id );\n\treturn item?.progress;\n}\n", "// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nlet getRandomValues;\nconst rnds8 = new Uint8Array(16);\nexport default function rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}", "import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\n\nexport function unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];\n}\n\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;", "const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nexport default {\n  randomUUID\n};", "import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\n\nfunction v4(options, buf, offset) {\n  if (native.randomUUID && !buf && !options) {\n    return native.randomUUID();\n  }\n\n  options = options || {};\n  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return unsafeStringify(rnds);\n}\n\nexport default v4;", "/**\n * ImageFile class.\n *\n * Small wrapper around the `File` class to hold\n * information about current dimensions and original\n * dimensions, in case the image was resized.\n */\nexport class ImageFile extends File {\n\twidth = 0;\n\theight = 0;\n\toriginalWidth? = 0;\n\toriginalHeight? = 0;\n\n\tget wasResized() {\n\t\treturn (\n\t\t\t( this.originalWidth || 0 ) > this.width ||\n\t\t\t( this.originalHeight || 0 ) > this.height\n\t\t);\n\t}\n\n\tconstructor(\n\t\tfile: File,\n\t\twidth: number,\n\t\theight: number,\n\t\toriginalWidth?: number,\n\t\toriginalHeight?: number\n\t) {\n\t\tsuper( [ file ], file.name, {\n\t\t\ttype: file.type,\n\t\t\tlastModified: file.lastModified,\n\t\t} );\n\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t\tthis.originalWidth = originalWidth;\n\t\tthis.originalHeight = originalHeight;\n\t}\n}\n", "/**\n * WordPress dependencies\n */\nimport { getFilename } from '@wordpress/url';\nimport { _x } from '@wordpress/i18n';\n\n/**\n * Converts a Blob to a File with a default name like \"image.png\".\n *\n * If it is already a File object, it is returned unchanged.\n *\n * @param fileOrBlob Blob object.\n * @return File object.\n */\nexport function convertBlobToFile( fileOrBlob: Blob | File ): File {\n\tif ( fileOrBlob instanceof File ) {\n\t\treturn fileOrBlob;\n\t}\n\n\t// Extension is only an approximation.\n\t// The server will override it if incorrect.\n\tconst ext = fileOrBlob.type.split( '/' )[ 1 ];\n\tconst mediaType =\n\t\t'application/pdf' === fileOrBlob.type\n\t\t\t? 'document'\n\t\t\t: fileOrBlob.type.split( '/' )[ 0 ];\n\treturn new File( [ fileOrBlob ], `${ mediaType }.${ ext }`, {\n\t\ttype: fileOrBlob.type,\n\t} );\n}\n\n/**\n * Renames a given file and returns a new file.\n *\n * Copies over the last modified time.\n *\n * @param file File object.\n * @param name File name.\n * @return Renamed file object.\n */\nexport function renameFile( file: File, name: string ): File {\n\treturn new File( [ file ], name, {\n\t\ttype: file.type,\n\t\tlastModified: file.lastModified,\n\t} );\n}\n\n/**\n * Clones a given file object.\n *\n * @param file File object.\n * @return New file object.\n */\nexport function cloneFile( file: File ): File {\n\treturn renameFile( file, file.name );\n}\n\n/**\n * Returns the file extension from a given file name or URL.\n *\n * @param file File URL.\n * @return File extension or null if it does not have one.\n */\nexport function getFileExtension( file: string ): string | null {\n\treturn file.includes( '.' ) ? file.split( '.' ).pop() || null : null;\n}\n\n/**\n * Returns file basename without extension.\n *\n * For example, turns \"my-awesome-file.jpeg\" into \"my-awesome-file\".\n *\n * @param name File name.\n * @return File basename.\n */\nexport function getFileBasename( name: string ): string {\n\treturn name.includes( '.' )\n\t\t? name.split( '.' ).slice( 0, -1 ).join( '.' )\n\t\t: name;\n}\n\n/**\n * Returns the file name including extension from a URL.\n *\n * @param url File URL.\n * @return File name.\n */\nexport function getFileNameFromUrl( url: string ) {\n\treturn getFilename( url ) || _x( 'unnamed', 'file name' );\n}\n", "/**\n * Internal dependencies\n */\nimport { ImageFile } from '../../image-file';\nimport { getFileBasename } from '../../utils';\nimport type { ImageSizeCrop, QueueItemId } from '../types';\n\n/**\n * Cached dynamic import promise for @wordpress/vips/worker.\n *\n * The module contains ~10MB of inlined WASM code. By using a dynamic import,\n * the WASM is only loaded when vips functions are actually called at image\n * processing time, rather than at module parse time.\n *\n * The promise is cached so the module is only resolved once.\n */\nlet vipsModulePromise:\n\t| Promise< typeof import('@wordpress/vips/worker') >\n\t| undefined;\n\n/**\n * The resolved module reference, available synchronously after the first\n * load completes. Used by terminateVipsWorker() and vipsCancelOperations().\n */\nlet vipsModule: typeof import('@wordpress/vips/worker') | undefined;\n\n/**\n * Lazily loads and caches the @wordpress/vips/worker module.\n *\n * @return The vips worker module.\n */\nfunction loadVipsModule(): Promise< typeof import('@wordpress/vips/worker') > {\n\tif ( ! vipsModulePromise ) {\n\t\tvipsModulePromise = import( '@wordpress/vips/worker' ).then(\n\t\t\t( mod ) => {\n\t\t\t\tvipsModule = mod;\n\t\t\t\treturn mod;\n\t\t\t}\n\t\t);\n\t}\n\treturn vipsModulePromise;\n}\n\n/**\n * Converts an image to a different format using vips in a web worker.\n *\n * @param id         Queue item ID.\n * @param file       File object.\n * @param type       Output mime type.\n * @param quality    Desired quality (0-1).\n * @param interlaced Whether to use interlaced/progressive mode.\n * @return Converted file.\n */\nexport async function vipsConvertImageFormat(\n\tid: QueueItemId,\n\tfile: File,\n\ttype:\n\t\t| 'image/jpeg'\n\t\t| 'image/png'\n\t\t| 'image/webp'\n\t\t| 'image/avif'\n\t\t| 'image/gif',\n\tquality: number,\n\tinterlaced?: boolean\n) {\n\tconst { vipsConvertImageFormat: convertImageFormat } =\n\t\tawait loadVipsModule();\n\tconst buffer = await convertImageFormat(\n\t\tid,\n\t\tawait file.arrayBuffer(),\n\t\tfile.type,\n\t\ttype,\n\t\tquality,\n\t\tinterlaced\n\t);\n\tconst ext = type.split( '/' )[ 1 ];\n\tconst fileName = `${ getFileBasename( file.name ) }.${ ext }`;\n\treturn new File( [ new Blob( [ buffer as ArrayBuffer ] ) ], fileName, {\n\t\ttype,\n\t} );\n}\n\n/**\n * Compresses an image using vips in a web worker.\n *\n * @param id         Queue item ID.\n * @param file       File object.\n * @param quality    Desired quality (0-1).\n * @param interlaced Whether to use interlaced/progressive mode.\n * @return Compressed file.\n */\nexport async function vipsCompressImage(\n\tid: QueueItemId,\n\tfile: File,\n\tquality: number,\n\tinterlaced?: boolean\n) {\n\tconst { vipsCompressImage: compressImage } = await loadVipsModule();\n\tconst buffer = await compressImage(\n\t\tid,\n\t\tawait file.arrayBuffer(),\n\t\tfile.type,\n\t\tquality,\n\t\tinterlaced\n\t);\n\treturn new File(\n\t\t[ new Blob( [ buffer as ArrayBuffer ], { type: file.type } ) ],\n\t\tfile.name,\n\t\t{ type: file.type }\n\t);\n}\n\n/**\n * Checks whether an image has transparency using vips in a web worker.\n *\n * @param url Image URL.\n * @return Whether the image has transparency.\n */\nexport async function vipsHasTransparency( url: string ) {\n\tconst { vipsHasTransparency: hasTransparency } = await loadVipsModule();\n\tconst response = await fetch( url );\n\tif ( ! response.ok ) {\n\t\tthrow new Error( `Failed to fetch image: ${ response.status }` );\n\t}\n\treturn hasTransparency( await response.arrayBuffer() );\n}\n\n/**\n * Resizes an image using vips in a web worker.\n *\n * @param id           Queue item ID.\n * @param file         File object.\n * @param resize       Resize options (width, height, crop).\n * @param smartCrop    Whether to use smart cropping (saliency-aware).\n * @param addSuffix    Whether to add dimension suffix to filename.\n * @param signal       Optional abort signal to cancel the operation.\n * @param scaledSuffix Whether to add '-scaled' suffix instead of dimensions (for big image threshold).\n * @return Resized ImageFile with dimension metadata.\n */\nexport async function vipsResizeImage(\n\tid: QueueItemId,\n\tfile: File,\n\tresize: ImageSizeCrop,\n\tsmartCrop: boolean,\n\taddSuffix: boolean,\n\tsignal?: AbortSignal,\n\tscaledSuffix?: boolean\n) {\n\tif ( signal?.aborted ) {\n\t\tthrow new Error( 'Operation aborted' );\n\t}\n\n\tconst { vipsResizeImage: resizeImage } = await loadVipsModule();\n\tconst { buffer, width, height, originalWidth, originalHeight } =\n\t\tawait resizeImage(\n\t\t\tid,\n\t\t\tawait file.arrayBuffer(),\n\t\t\tfile.type,\n\t\t\tresize,\n\t\t\tsmartCrop\n\t\t);\n\n\tlet fileName = file.name;\n\tconst wasResized = originalWidth > width || originalHeight > height;\n\n\tif ( wasResized ) {\n\t\tconst basename = getFileBasename( file.name );\n\t\tif ( scaledSuffix ) {\n\t\t\t// Add '-scaled' suffix for big image threshold resizing.\n\t\t\t// This matches WordPress core's behavior in wp_create_image_subsizes().\n\t\t\tfileName = file.name.replace( basename, `${ basename }-scaled` );\n\t\t} else if ( addSuffix ) {\n\t\t\t// Add dimension suffix for thumbnails.\n\t\t\tfileName = file.name.replace(\n\t\t\t\tbasename,\n\t\t\t\t`${ basename }-${ width }x${ height }`\n\t\t\t);\n\t\t}\n\t}\n\n\tconst resultFile = new ImageFile(\n\t\tnew File(\n\t\t\t[ new Blob( [ buffer as ArrayBuffer ], { type: file.type } ) ],\n\t\t\tfileName,\n\t\t\t{\n\t\t\t\ttype: file.type,\n\t\t\t}\n\t\t),\n\t\twidth,\n\t\theight,\n\t\toriginalWidth,\n\t\toriginalHeight\n\t);\n\n\treturn resultFile;\n}\n\n/**\n * Rotates an image based on EXIF orientation using vips in a web worker.\n *\n * This applies the correct rotation/flip transformation based on the EXIF\n * orientation value (1-8), and adds a '-rotated' suffix to the filename.\n * This matches WordPress core's behavior when rotating images based on EXIF.\n *\n * @param id          Queue item ID.\n * @param file        File object.\n * @param orientation EXIF orientation value (1-8).\n * @param signal      Optional abort signal to cancel the operation.\n * @return Rotated ImageFile with updated dimensions.\n */\nexport async function vipsRotateImage(\n\tid: QueueItemId,\n\tfile: File,\n\torientation: number,\n\tsignal?: AbortSignal\n) {\n\tif ( signal?.aborted ) {\n\t\tthrow new Error( 'Operation aborted' );\n\t}\n\n\t// If orientation is 1 (normal), no rotation needed.\n\tif ( orientation === 1 ) {\n\t\treturn file;\n\t}\n\n\tconst { vipsRotateImage: rotateImage } = await loadVipsModule();\n\tconst { buffer, width, height } = await rotateImage(\n\t\tid,\n\t\tawait file.arrayBuffer(),\n\t\tfile.type,\n\t\torientation\n\t);\n\n\t// Add '-rotated' suffix to filename, matching WordPress core behavior.\n\tconst basename = getFileBasename( file.name );\n\tconst fileName = file.name.replace( basename, `${ basename }-rotated` );\n\n\tconst resultFile = new ImageFile(\n\t\tnew File(\n\t\t\t[ new Blob( [ buffer as ArrayBuffer ], { type: file.type } ) ],\n\t\t\tfileName,\n\t\t\t{\n\t\t\t\ttype: file.type,\n\t\t\t}\n\t\t),\n\t\twidth,\n\t\theight\n\t);\n\n\treturn resultFile;\n}\n\n/**\n * Cancels all ongoing image operations for the given item.\n *\n * If the vips module has not been loaded yet, there can be no active\n * operations to cancel.\n *\n * @param id Queue item ID to cancel operations for.\n * @return Whether any operation was cancelled.\n */\nexport async function vipsCancelOperations( id: QueueItemId ) {\n\tif ( ! vipsModule ) {\n\t\treturn false;\n\t}\n\treturn vipsModule.vipsCancelOperations( id );\n}\n\n/**\n * Terminates the vips worker if it has been loaded.\n *\n * If the vips module has not been loaded yet (i.e., no image processing\n * has occurred), this is a no-op since there is no worker to terminate.\n */\nexport function terminateVipsWorker(): void {\n\tif ( vipsModule ) {\n\t\tvipsModule.terminateVipsWorker();\n\t}\n}\n", "/**\n * WordPress dependencies\n */\nimport { __, sprintf } from '@wordpress/i18n';\n\n/**\n * Internal dependencies\n */\nimport { UploadError } from './upload-error';\n\n/**\n * Verifies if the caller (e.g. a block) supports this mime type.\n *\n * @param file         File object.\n * @param allowedTypes List of allowed mime types.\n */\nexport function validateMimeType( file: File, allowedTypes?: string[] ) {\n\tif ( ! allowedTypes ) {\n\t\treturn;\n\t}\n\n\t// Allowed type specified by consumer.\n\tconst isAllowedType = allowedTypes.some( ( allowedType ) => {\n\t\t// If a complete mimetype is specified verify if it matches exactly the mime type of the file.\n\t\tif ( allowedType.includes( '/' ) ) {\n\t\t\treturn allowedType === file.type;\n\t\t}\n\t\t// Otherwise a general mime type is used, and we should verify if the file mimetype starts with it.\n\t\treturn file.type.startsWith( `${ allowedType }/` );\n\t} );\n\n\tif ( file.type && ! isAllowedType ) {\n\t\tthrow new UploadError( {\n\t\t\tcode: 'MIME_TYPE_NOT_SUPPORTED',\n\t\t\tmessage: sprintf(\n\t\t\t\t// translators: %s: file name.\n\t\t\t\t__( '%s: Sorry, this file type is not supported here.' ),\n\t\t\t\tfile.name\n\t\t\t),\n\t\t\tfile,\n\t\t} );\n\t}\n}\n", "interface UploadErrorArgs {\n\tcode: string;\n\tmessage: string;\n\tfile: File;\n\tcause?: Error;\n}\n\n/**\n * MediaError class.\n *\n * Small wrapper around the `Error` class\n * to hold an error code and a reference to a file object.\n */\nexport class UploadError extends Error {\n\tcode: string;\n\tfile: File;\n\n\tconstructor( { code, message, file, cause }: UploadErrorArgs ) {\n\t\tsuper( message, { cause } );\n\n\t\tObject.setPrototypeOf( this, new.target.prototype );\n\n\t\tthis.code = code;\n\t\tthis.file = file;\n\t}\n}\n", "/**\n * WordPress dependencies\n */\nimport { __, sprintf } from '@wordpress/i18n';\n\n/**\n * Internal dependencies\n */\nimport { UploadError } from './upload-error';\nimport { getMimeTypesArray } from './get-mime-types-array';\n\n/**\n * Verifies if the user is allowed to upload this mime type.\n *\n * @param file               File object.\n * @param wpAllowedMimeTypes List of allowed mime types and file extensions.\n */\nexport function validateMimeTypeForUser(\n\tfile: File,\n\twpAllowedMimeTypes?: Record< string, string > | null\n) {\n\t// Allowed types for the current WP_User.\n\tconst allowedMimeTypesForUser = getMimeTypesArray( wpAllowedMimeTypes );\n\n\tif ( ! allowedMimeTypesForUser ) {\n\t\treturn;\n\t}\n\n\tconst isAllowedMimeTypeForUser = allowedMimeTypesForUser.includes(\n\t\tfile.type\n\t);\n\n\tif ( file.type && ! isAllowedMimeTypeForUser ) {\n\t\tthrow new UploadError( {\n\t\t\tcode: 'MIME_TYPE_NOT_ALLOWED_FOR_USER',\n\t\t\tmessage: sprintf(\n\t\t\t\t// translators: %s: file name.\n\t\t\t\t__(\n\t\t\t\t\t'%s: Sorry, you are not allowed to upload this file type.'\n\t\t\t\t),\n\t\t\t\tfile.name\n\t\t\t),\n\t\t\tfile,\n\t\t} );\n\t}\n}\n", "/**\n * Browsers may use unexpected mime types, and they differ from browser to browser.\n * This function computes a flexible array of mime types from the mime type structured provided by the server.\n * Converts { jpg|jpeg|jpe: \"image/jpeg\" } into [ \"image/jpeg\", \"image/jpg\", \"image/jpeg\", \"image/jpe\" ]\n *\n * @param {?Object} wpMimeTypesObject Mime type object received from the server.\n *                                    Extensions are keys separated by '|' and values are mime types associated with an extension.\n *\n * @return An array of mime types or null\n */\nexport function getMimeTypesArray(\n\twpMimeTypesObject?: Record< string, string > | null\n) {\n\tif ( ! wpMimeTypesObject ) {\n\t\treturn null;\n\t}\n\treturn Object.entries( wpMimeTypesObject ).flatMap(\n\t\t( [ extensionsString, mime ] ) => {\n\t\t\tconst [ type ] = mime.split( '/' );\n\t\t\tconst extensions = extensionsString.split( '|' );\n\t\t\treturn [\n\t\t\t\tmime,\n\t\t\t\t...extensions.map(\n\t\t\t\t\t( extension ) => `${ type }/${ extension }`\n\t\t\t\t),\n\t\t\t];\n\t\t}\n\t);\n}\n", "/**\n * WordPress dependencies\n */\nimport { __, sprintf } from '@wordpress/i18n';\n\n/**\n * Internal dependencies\n */\nimport { UploadError } from './upload-error';\n\n/**\n * Verifies whether the file is within the file upload size limits for the site.\n *\n * @param file              File object.\n * @param maxUploadFileSize Maximum upload size in bytes allowed for the site.\n */\nexport function validateFileSize( file: File, maxUploadFileSize?: number ) {\n\t// Don't allow empty files to be uploaded.\n\tif ( file.size <= 0 ) {\n\t\tthrow new UploadError( {\n\t\t\tcode: 'EMPTY_FILE',\n\t\t\tmessage: sprintf(\n\t\t\t\t// translators: %s: file name.\n\t\t\t\t__( '%s: This file is empty.' ),\n\t\t\t\tfile.name\n\t\t\t),\n\t\t\tfile,\n\t\t} );\n\t}\n\n\tif ( maxUploadFileSize && file.size > maxUploadFileSize ) {\n\t\tthrow new UploadError( {\n\t\t\tcode: 'SIZE_ABOVE_LIMIT',\n\t\t\tmessage: sprintf(\n\t\t\t\t// translators: %s: file name.\n\t\t\t\t__(\n\t\t\t\t\t'%s: This file exceeds the maximum upload size for this site.'\n\t\t\t\t),\n\t\t\t\tfile.name\n\t\t\t),\n\t\t\tfile,\n\t\t} );\n\t}\n}\n", "/**\n * External dependencies\n */\nimport { v4 as uuidv4 } from 'uuid';\n\n/**\n * WordPress dependencies\n */\nimport type { createRegistry } from '@wordpress/data';\n\ntype WPDataRegistry = ReturnType< typeof createRegistry >;\n\n/**\n * Internal dependencies\n */\nimport type {\n\tAdditionalData,\n\tCancelAction,\n\tOnBatchSuccessHandler,\n\tOnChangeHandler,\n\tOnErrorHandler,\n\tOnSuccessHandler,\n\tQueueItemId,\n\tRetryItemAction,\n\tState,\n} from './types';\nimport { Type } from './types';\nimport type {\n\taddItem,\n\tprocessItem,\n\tremoveItem,\n\trevokeBlobUrls,\n} from './private-actions';\nimport { vipsCancelOperations } from './utils';\nimport { validateMimeType } from '../validate-mime-type';\nimport { validateMimeTypeForUser } from '../validate-mime-type-for-user';\nimport { validateFileSize } from '../validate-file-size';\n\ntype ActionCreators = {\n\taddItem: typeof addItem;\n\taddItems: typeof addItems;\n\tremoveItem: typeof removeItem;\n\tprocessItem: typeof processItem;\n\tcancelItem: typeof cancelItem;\n\tretryItem: typeof retryItem;\n\trevokeBlobUrls: typeof revokeBlobUrls;\n\t< T = Record< string, unknown > >( args: T ): void;\n};\n\ntype AllSelectors = typeof import('./selectors') &\n\ttypeof import('./private-selectors');\ntype CurriedState< F > = F extends ( state: State, ...args: infer P ) => infer R\n\t? ( ...args: P ) => R\n\t: F;\ntype Selectors = {\n\t[ key in keyof AllSelectors ]: CurriedState< AllSelectors[ key ] >;\n};\n\ntype ThunkArgs = {\n\tselect: Selectors;\n\tdispatch: ActionCreators;\n\tregistry: WPDataRegistry;\n};\n\ninterface AddItemsArgs {\n\tfiles: File[];\n\tonChange?: OnChangeHandler;\n\tonSuccess?: OnSuccessHandler;\n\tonBatchSuccess?: OnBatchSuccessHandler;\n\tonError?: OnErrorHandler;\n\tadditionalData?: AdditionalData;\n\tallowedTypes?: string[];\n}\n\n/**\n * Adds a new item to the upload queue.\n *\n * @param $0\n * @param $0.files            Files\n * @param [$0.onChange]       Function called each time a file or a temporary representation of the file is available.\n * @param [$0.onSuccess]      Function called after the file is uploaded.\n * @param [$0.onBatchSuccess] Function called after a batch of files is uploaded.\n * @param [$0.onError]        Function called when an error happens.\n * @param [$0.additionalData] Additional data to include in the request.\n * @param [$0.allowedTypes]   Array with the types of media that can be uploaded, if unset all types are allowed.\n */\nexport function addItems( {\n\tfiles,\n\tonChange,\n\tonSuccess,\n\tonError,\n\tonBatchSuccess,\n\tadditionalData,\n\tallowedTypes,\n}: AddItemsArgs ) {\n\treturn async ( { select, dispatch }: ThunkArgs ) => {\n\t\tconst batchId = uuidv4();\n\t\tfor ( const file of files ) {\n\t\t\t/*\n\t\t\t Check if the caller (e.g. a block) supports this mime type.\n\t\t\t Special case for file types such as HEIC which will be converted before upload anyway.\n\t\t\t Another check will be done before upload.\n\t\t\t*/\n\t\t\ttry {\n\t\t\t\tvalidateMimeType( file, allowedTypes );\n\t\t\t\tvalidateMimeTypeForUser(\n\t\t\t\t\tfile,\n\t\t\t\t\tselect.getSettings().allowedMimeTypes\n\t\t\t\t);\n\t\t\t} catch ( error: unknown ) {\n\t\t\t\tonError?.( error as Error );\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tvalidateFileSize(\n\t\t\t\t\tfile,\n\t\t\t\t\tselect.getSettings().maxUploadFileSize\n\t\t\t\t);\n\t\t\t} catch ( error: unknown ) {\n\t\t\t\tonError?.( error as Error );\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdispatch.addItem( {\n\t\t\t\tfile,\n\t\t\t\tbatchId,\n\t\t\t\tonChange,\n\t\t\t\tonSuccess,\n\t\t\t\tonBatchSuccess,\n\t\t\t\tonError,\n\t\t\t\tadditionalData,\n\t\t\t} );\n\t\t}\n\t};\n}\n\n/**\n * Cancels an item in the queue based on an error.\n *\n * @param id     Item ID.\n * @param error  Error instance.\n * @param silent Whether to cancel the item silently,\n *               without invoking its `onError` callback.\n */\nexport function cancelItem( id: QueueItemId, error: Error, silent = false ) {\n\treturn async ( { select, dispatch }: ThunkArgs ) => {\n\t\tconst item = select.getItem( id );\n\n\t\tif ( ! item ) {\n\t\t\t/*\n\t\t\t * Do nothing if item has already been removed.\n\t\t\t * This can happen if an upload is cancelled manually\n\t\t\t * while transcoding with vips is still in progress.\n\t\t\t * Then, cancelItem() is once invoked manually and once\n\t\t\t * by the error handler in optimizeImageItem().\n\t\t\t */\n\t\t\treturn;\n\t\t}\n\n\t\titem.abortController?.abort();\n\n\t\t// Cancel any ongoing vips operations for this item.\n\t\tawait vipsCancelOperations( id );\n\n\t\tif ( ! silent ) {\n\t\t\tconst { onError } = item;\n\t\t\tonError?.( error ?? new Error( 'Upload cancelled' ) );\n\t\t\tif ( ! onError && error ) {\n\t\t\t\t// TODO: Find better way to surface errors with sideloads etc.\n\t\t\t\t// eslint-disable-next-line no-console -- Deliberately log errors here.\n\t\t\t\tconsole.error( 'Upload cancelled', error );\n\t\t\t}\n\t\t}\n\n\t\tdispatch< CancelAction >( {\n\t\t\ttype: Type.Cancel,\n\t\t\tid,\n\t\t\terror,\n\t\t} );\n\t\tdispatch.removeItem( id );\n\t\tdispatch.revokeBlobUrls( id );\n\n\t\t// All items of this batch were cancelled or finished.\n\t\tif ( item.batchId && select.isBatchUploaded( item.batchId ) ) {\n\t\t\titem.onBatchSuccess?.();\n\t\t}\n\t};\n}\n\n/**\n * Retries a failed item in the queue.\n *\n * @param id Item ID.\n */\nexport function retryItem( id: QueueItemId ) {\n\treturn async ( { select, dispatch }: ThunkArgs ) => {\n\t\tconst item = select.getItem( id );\n\n\t\tif ( ! item ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Only retry items that have an error.\n\t\tif ( ! item.error ) {\n\t\t\treturn;\n\t\t}\n\n\t\tdispatch< RetryItemAction >( {\n\t\t\ttype: Type.RetryItem,\n\t\t\tid,\n\t\t} );\n\n\t\tdispatch.processItem( id );\n\t};\n}\n", "/**\n * External dependencies\n */\nimport { v4 as uuidv4 } from 'uuid';\n\n/**\n * WordPress dependencies\n */\nimport { createBlobURL, isBlobURL, revokeBlobURL } from '@wordpress/blob';\nimport type { createRegistry } from '@wordpress/data';\n\ntype WPDataRegistry = ReturnType< typeof createRegistry >;\n\n/**\n * Internal dependencies\n */\nimport { cloneFile, convertBlobToFile, renameFile } from '../utils';\nimport { CLIENT_SIDE_SUPPORTED_MIME_TYPES } from './constants';\nimport { StubFile } from '../stub-file';\nimport { UploadError } from '../upload-error';\nimport {\n\tvipsResizeImage,\n\tvipsRotateImage,\n\tvipsConvertImageFormat,\n\tvipsHasTransparency,\n\tterminateVipsWorker,\n} from './utils';\nimport type {\n\tAddAction,\n\tAdditionalData,\n\tAddOperationsAction,\n\tBatchId,\n\tCacheBlobUrlAction,\n\tImageFormat,\n\tOnBatchSuccessHandler,\n\tOnChangeHandler,\n\tOnErrorHandler,\n\tOnSuccessHandler,\n\tOperation,\n\tOperationArgs,\n\tOperationFinishAction,\n\tOperationStartAction,\n\tPauseItemAction,\n\tPauseQueueAction,\n\tQueueItem,\n\tQueueItemId,\n\tResumeItemAction,\n\tResumeQueueAction,\n\tRevokeBlobUrlsAction,\n\tSideloadAdditionalData,\n\tSettings,\n\tState,\n\tUpdateProgressAction,\n\tUpdateSettingsAction,\n} from './types';\nimport { ItemStatus, OperationType, Type } from './types';\nimport type { cancelItem } from './actions';\n\nconst DEFAULT_OUTPUT_QUALITY = 0.82;\n\ntype ActionCreators = {\n\tcancelItem: typeof cancelItem;\n\taddItem: typeof addItem;\n\taddSideloadItem: typeof addSideloadItem;\n\tremoveItem: typeof removeItem;\n\tpauseItem: typeof pauseItem;\n\tresumeItemByPostId: typeof resumeItemByPostId;\n\tprepareItem: typeof prepareItem;\n\tprocessItem: typeof processItem;\n\tfinishOperation: typeof finishOperation;\n\tuploadItem: typeof uploadItem;\n\tsideloadItem: typeof sideloadItem;\n\tresizeCropItem: typeof resizeCropItem;\n\trotateItem: typeof rotateItem;\n\ttranscodeImageItem: typeof transcodeImageItem;\n\tgenerateThumbnails: typeof generateThumbnails;\n\tupdateItemProgress: typeof updateItemProgress;\n\trevokeBlobUrls: typeof revokeBlobUrls;\n\t< T = Record< string, unknown > >( args: T ): void;\n};\n\ntype AllSelectors = typeof import('./selectors') &\n\ttypeof import('./private-selectors');\ntype CurriedState< F > = F extends ( state: State, ...args: infer P ) => infer R\n\t? ( ...args: P ) => R\n\t: F;\ntype Selectors = {\n\t[ key in keyof AllSelectors ]: CurriedState< AllSelectors[ key ] >;\n};\n\ntype ThunkArgs = {\n\tselect: Selectors;\n\tdispatch: ActionCreators;\n\tregistry: WPDataRegistry;\n};\n\n/**\n * Determines if an upload should be paused to avoid race conditions.\n *\n * When sideloading thumbnails, we need to pause uploads if another\n * upload to the same post is already in progress.\n *\n * @param item      Queue item to check.\n * @param operation Current operation type.\n * @param select    Store selectors.\n * @return Whether the upload should be paused.\n */\nfunction shouldPauseForSideload(\n\titem: QueueItem,\n\toperation: OperationType | undefined,\n\tselect: Selectors\n): boolean {\n\tif (\n\t\toperation !== OperationType.Upload ||\n\t\t! item.parentId ||\n\t\t! item.additionalData.post\n\t) {\n\t\treturn false;\n\t}\n\treturn select.isUploadingToPost( item.additionalData.post as number );\n}\n\ninterface AddItemArgs {\n\t// It should always be a File, but some consumers might still pass Blobs only.\n\tfile: File | Blob;\n\tbatchId?: BatchId;\n\tonChange?: OnChangeHandler;\n\tonSuccess?: OnSuccessHandler;\n\tonError?: OnErrorHandler;\n\tonBatchSuccess?: OnBatchSuccessHandler;\n\tadditionalData?: AdditionalData;\n\tsourceUrl?: string;\n\tsourceAttachmentId?: number;\n\tabortController?: AbortController;\n\toperations?: Operation[];\n}\n\n/**\n * Adds a new item to the upload queue.\n *\n * @param $0\n * @param $0.file                 File\n * @param [$0.batchId]            Batch ID.\n * @param [$0.onChange]           Function called each time a file or a temporary representation of the file is available.\n * @param [$0.onSuccess]          Function called after the file is uploaded.\n * @param [$0.onBatchSuccess]     Function called after a batch of files is uploaded.\n * @param [$0.onError]            Function called when an error happens.\n * @param [$0.additionalData]     Additional data to include in the request.\n * @param [$0.sourceUrl]          Source URL. Used when importing a file from a URL or optimizing an existing file.\n * @param [$0.sourceAttachmentId] Source attachment ID. Used when optimizing an existing file for example.\n * @param [$0.abortController]    Abort controller for upload cancellation.\n * @param [$0.operations]         List of operations to perform. Defaults to automatically determined list, based on the file.\n */\nexport function addItem( {\n\tfile: fileOrBlob,\n\tbatchId,\n\tonChange,\n\tonSuccess,\n\tonBatchSuccess,\n\tonError,\n\tadditionalData = {} as AdditionalData,\n\tsourceUrl,\n\tsourceAttachmentId,\n\tabortController,\n\toperations,\n}: AddItemArgs ) {\n\treturn async ( { dispatch }: ThunkArgs ) => {\n\t\tconst itemId = uuidv4();\n\n\t\t// Hardening in case a Blob is passed instead of a File.\n\t\t// See https://github.com/WordPress/gutenberg/pull/65693 for an example.\n\t\tconst file = convertBlobToFile( fileOrBlob );\n\n\t\tlet blobUrl;\n\n\t\t// StubFile could be coming from addItemFromUrl().\n\t\tif ( ! ( file instanceof StubFile ) ) {\n\t\t\tblobUrl = createBlobURL( file );\n\t\t\tdispatch< CacheBlobUrlAction >( {\n\t\t\t\ttype: Type.CacheBlobUrl,\n\t\t\t\tid: itemId,\n\t\t\t\tblobUrl,\n\t\t\t} );\n\t\t}\n\n\t\tdispatch< AddAction >( {\n\t\t\ttype: Type.Add,\n\t\t\titem: {\n\t\t\t\tid: itemId,\n\t\t\t\tbatchId,\n\t\t\t\tstatus: ItemStatus.Processing,\n\t\t\t\tsourceFile: cloneFile( file ),\n\t\t\t\tfile,\n\t\t\t\tattachment: {\n\t\t\t\t\turl: blobUrl,\n\t\t\t\t},\n\t\t\t\tadditionalData: {\n\t\t\t\t\tconvert_format: false,\n\t\t\t\t\tgenerate_sub_sizes: false,\n\t\t\t\t\t...additionalData,\n\t\t\t\t},\n\t\t\t\tonChange,\n\t\t\t\tonSuccess,\n\t\t\t\tonBatchSuccess,\n\t\t\t\tonError,\n\t\t\t\tsourceUrl,\n\t\t\t\tsourceAttachmentId,\n\t\t\t\tabortController: abortController || new AbortController(),\n\t\t\t\toperations: Array.isArray( operations )\n\t\t\t\t\t? operations\n\t\t\t\t\t: [ OperationType.Prepare ],\n\t\t\t},\n\t\t} );\n\n\t\tdispatch.processItem( itemId );\n\t};\n}\n\ninterface AddSideloadItemArgs {\n\tfile: File;\n\tonChange?: OnChangeHandler;\n\tadditionalData?: AdditionalData;\n\toperations?: Operation[];\n\tbatchId?: BatchId;\n\tparentId?: QueueItemId;\n}\n\n/**\n * Adds a new item to the upload queue for sideloading.\n *\n * This is typically a client-side generated thumbnail.\n *\n * @param $0\n * @param $0.file             File\n * @param [$0.batchId]        Batch ID.\n * @param [$0.parentId]       Parent ID.\n * @param [$0.onChange]       Function called each time a file or a temporary representation of the file is available.\n * @param [$0.additionalData] Additional data to include in the request.\n * @param [$0.operations]     List of operations to perform. Defaults to automatically determined list, based on the file.\n */\nexport function addSideloadItem( {\n\tfile,\n\tonChange,\n\tadditionalData,\n\toperations,\n\tbatchId,\n\tparentId,\n}: AddSideloadItemArgs ) {\n\treturn ( { dispatch }: ThunkArgs ) => {\n\t\tconst itemId = uuidv4();\n\t\tdispatch< AddAction >( {\n\t\t\ttype: Type.Add,\n\t\t\titem: {\n\t\t\t\tid: itemId,\n\t\t\t\tbatchId,\n\t\t\t\tstatus: ItemStatus.Processing,\n\t\t\t\tsourceFile: cloneFile( file ),\n\t\t\t\tfile,\n\t\t\t\tonChange,\n\t\t\t\tadditionalData: {\n\t\t\t\t\t...additionalData,\n\t\t\t\t},\n\t\t\t\tparentId,\n\t\t\t\toperations: Array.isArray( operations )\n\t\t\t\t\t? operations\n\t\t\t\t\t: [ OperationType.Prepare ],\n\t\t\t\tabortController: new AbortController(),\n\t\t\t},\n\t\t} );\n\n\t\tdispatch.processItem( itemId );\n\t};\n}\n\n/**\n * Processes a single item in the queue.\n *\n * Runs the next operation in line and invokes any callbacks.\n *\n * @param id Item ID.\n */\nexport function processItem( id: QueueItemId ) {\n\treturn async ( { select, dispatch }: ThunkArgs ) => {\n\t\tif ( select.isPaused() ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst item = select.getItem( id );\n\t\tif ( ! item ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst {\n\t\t\tattachment,\n\t\t\tonChange,\n\t\t\tonSuccess,\n\t\t\tonBatchSuccess,\n\t\t\tbatchId,\n\t\t\tparentId,\n\t\t} = item;\n\n\t\tconst operation = Array.isArray( item.operations?.[ 0 ] )\n\t\t\t? item.operations[ 0 ][ 0 ]\n\t\t\t: item.operations?.[ 0 ];\n\t\tconst operationArgs = Array.isArray( item.operations?.[ 0 ] )\n\t\t\t? item.operations[ 0 ][ 1 ]\n\t\t\t: undefined;\n\n\t\t// If we're sideloading a thumbnail, pause upload to avoid race conditions.\n\t\t// It will be resumed after the previous upload finishes.\n\t\tif ( shouldPauseForSideload( item, operation, select ) ) {\n\t\t\tdispatch< PauseItemAction >( {\n\t\t\t\ttype: Type.PauseItem,\n\t\t\t\tid,\n\t\t\t} );\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * If the next operation is an upload, check concurrency limit.\n\t\t * If at capacity, the item remains queued and will be processed\n\t\t * when another upload completes.\n\t\t */\n\t\tif ( operation === OperationType.Upload ) {\n\t\t\tconst settings = select.getSettings();\n\t\t\tconst activeCount = select.getActiveUploadCount();\n\t\t\tif ( activeCount >= settings.maxConcurrentUploads ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If the next operation is image processing (resize/crop/rotate),\n\t\t * check the image processing concurrency limit.\n\t\t * If at capacity, the item remains queued and will be processed\n\t\t * when another image processing operation completes.\n\t\t */\n\t\tif (\n\t\t\toperation === OperationType.ResizeCrop ||\n\t\t\toperation === OperationType.Rotate\n\t\t) {\n\t\t\tconst settings = select.getSettings();\n\t\t\tconst activeCount = select.getActiveImageProcessingCount();\n\t\t\tif ( activeCount >= settings.maxConcurrentImageProcessing ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif ( attachment ) {\n\t\t\tonChange?.( [ attachment ] );\n\t\t}\n\n\t\t/*\n\t\t If there are no more operations, the item can be removed from the queue,\n\t\t but only if there are no thumbnails still being side-loaded,\n\t\t or if itself is a side-loaded item.\n\t\t*/\n\n\t\tif ( ! operation ) {\n\t\t\tif (\n\t\t\t\tparentId ||\n\t\t\t\t( ! parentId && ! select.hasPendingItemsByParentId( id ) )\n\t\t\t) {\n\t\t\t\tif ( attachment ) {\n\t\t\t\t\tonSuccess?.( [ attachment ] );\n\t\t\t\t}\n\n\t\t\t\tdispatch.removeItem( id );\n\t\t\t\tdispatch.revokeBlobUrls( id );\n\n\t\t\t\tif ( batchId && select.isBatchUploaded( batchId ) ) {\n\t\t\t\t\tonBatchSuccess?.();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// All other side-loaded items have been removed, so remove the parent too.\n\t\t\tif ( parentId && batchId && select.isBatchUploaded( batchId ) ) {\n\t\t\t\tconst parentItem = select.getItem( parentId ) as QueueItem;\n\t\t\t\tif ( ! parentItem ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif ( attachment ) {\n\t\t\t\t\tparentItem.onSuccess?.( [ attachment ] );\n\t\t\t\t}\n\n\t\t\t\tdispatch.removeItem( parentId );\n\t\t\t\tdispatch.revokeBlobUrls( parentId );\n\n\t\t\t\tif (\n\t\t\t\t\tparentItem.batchId &&\n\t\t\t\t\tselect.isBatchUploaded( parentItem.batchId )\n\t\t\t\t) {\n\t\t\t\t\tparentItem.onBatchSuccess?.();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t At this point we are dealing with a parent whose children haven't fully uploaded yet.\n\t\t\t Do nothing and let the removal happen once the last side-loaded item finishes.\n\t\t\t */\n\n\t\t\treturn;\n\t\t}\n\n\t\tdispatch< OperationStartAction >( {\n\t\t\ttype: Type.OperationStart,\n\t\t\tid,\n\t\t\toperation,\n\t\t} );\n\n\t\tswitch ( operation ) {\n\t\t\tcase OperationType.Prepare:\n\t\t\t\tdispatch.prepareItem( item.id );\n\t\t\t\tbreak;\n\n\t\t\tcase OperationType.ResizeCrop:\n\t\t\t\tdispatch.resizeCropItem(\n\t\t\t\t\titem.id,\n\t\t\t\t\toperationArgs as OperationArgs[ OperationType.ResizeCrop ]\n\t\t\t\t);\n\t\t\t\tbreak;\n\n\t\t\tcase OperationType.Rotate:\n\t\t\t\tdispatch.rotateItem(\n\t\t\t\t\titem.id,\n\t\t\t\t\toperationArgs as OperationArgs[ OperationType.Rotate ]\n\t\t\t\t);\n\t\t\t\tbreak;\n\n\t\t\tcase OperationType.TranscodeImage:\n\t\t\t\tdispatch.transcodeImageItem(\n\t\t\t\t\titem.id,\n\t\t\t\t\toperationArgs as OperationArgs[ OperationType.TranscodeImage ]\n\t\t\t\t);\n\t\t\t\tbreak;\n\n\t\t\tcase OperationType.Upload:\n\t\t\t\tif ( item.parentId ) {\n\t\t\t\t\tdispatch.sideloadItem( id );\n\t\t\t\t} else {\n\t\t\t\t\tdispatch.uploadItem( id );\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase OperationType.ThumbnailGeneration:\n\t\t\t\tdispatch.generateThumbnails( id );\n\t\t\t\tbreak;\n\t\t}\n\t};\n}\n\n/**\n * Returns an action object that pauses all processing in the queue.\n *\n * Useful for testing purposes.\n *\n * @return Action object.\n */\nexport function pauseQueue(): PauseQueueAction {\n\treturn {\n\t\ttype: Type.PauseQueue,\n\t};\n}\n\n/**\n * Resumes all processing in the queue.\n *\n * Dispatches an action object for resuming the queue itself,\n * and triggers processing for each remaining item in the queue individually.\n */\nexport function resumeQueue() {\n\treturn async ( { select, dispatch }: ThunkArgs ) => {\n\t\tdispatch< ResumeQueueAction >( {\n\t\t\ttype: Type.ResumeQueue,\n\t\t} );\n\n\t\tfor ( const item of select.getAllItems() ) {\n\t\t\tdispatch.processItem( item.id );\n\t\t}\n\t};\n}\n\n/**\n * Pauses a specific item in the queue.\n *\n * @param id Item ID.\n */\nexport function pauseItem( id: QueueItemId ) {\n\treturn async ( { dispatch }: ThunkArgs ) => {\n\t\tdispatch< PauseItemAction >( {\n\t\t\ttype: Type.PauseItem,\n\t\t\tid,\n\t\t} );\n\t};\n}\n\n/**\n * Resumes processing for a given post/attachment ID.\n *\n * This function looks up paused uploads by post ID and resumes them.\n * It's typically called after a sideload completes to resume paused\n * thumbnail uploads.\n *\n * @param postOrAttachmentId Post or attachment ID.\n */\nexport function resumeItemByPostId( postOrAttachmentId: number ) {\n\treturn async ( { select, dispatch }: ThunkArgs ) => {\n\t\tconst item = select.getPausedUploadForPost( postOrAttachmentId );\n\t\tif ( item ) {\n\t\t\tdispatch< ResumeItemAction >( {\n\t\t\t\ttype: Type.ResumeItem,\n\t\t\t\tid: item.id,\n\t\t\t} );\n\t\t\tdispatch.processItem( item.id );\n\t\t}\n\t};\n}\n\n/**\n * Removes a specific item from the queue.\n *\n * @param id Item ID.\n */\nexport function removeItem( id: QueueItemId ) {\n\treturn async ( { select, dispatch }: ThunkArgs ) => {\n\t\tconst item = select.getItem( id );\n\t\tif ( ! item ) {\n\t\t\treturn;\n\t\t}\n\n\t\tdispatch( {\n\t\t\ttype: Type.Remove,\n\t\t\tid,\n\t\t} );\n\n\t\t/*\n\t\t * If the queue is now empty, terminate the VIPS worker to free\n\t\t * WASM memory. The worker will be lazily re-created if needed.\n\t\t */\n\t\tif ( select.getAllItems().length === 0 ) {\n\t\t\tterminateVipsWorker();\n\t\t}\n\t};\n}\n\n/**\n * Finishes an operation for a given item ID and immediately triggers processing the next one.\n *\n * @param id      Item ID.\n * @param updates Updated item data.\n */\nexport function finishOperation(\n\tid: QueueItemId,\n\tupdates: Partial< QueueItem >\n) {\n\treturn async ( { select, dispatch }: ThunkArgs ) => {\n\t\tconst item = select.getItem( id );\n\t\tconst previousOperation = item?.currentOperation;\n\n\t\tdispatch< OperationFinishAction >( {\n\t\t\ttype: Type.OperationFinish,\n\t\t\tid,\n\t\t\titem: updates,\n\t\t} );\n\n\t\tdispatch.processItem( id );\n\n\t\t/*\n\t\t * If an upload just finished, there may be items waiting in the queue\n\t\t * due to concurrency limits. Trigger processing for them.\n\t\t */\n\t\tif ( previousOperation === OperationType.Upload ) {\n\t\t\tconst pendingUploads = select.getPendingUploads();\n\t\t\tfor ( const pendingItem of pendingUploads ) {\n\t\t\t\tdispatch.processItem( pendingItem.id );\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If an image processing operation just finished, there may be items\n\t\t * waiting in the queue due to the image processing concurrency limit.\n\t\t * Trigger processing for them.\n\t\t */\n\t\tif (\n\t\t\tpreviousOperation === OperationType.ResizeCrop ||\n\t\t\tpreviousOperation === OperationType.Rotate\n\t\t) {\n\t\t\tconst pendingItems = select.getPendingImageProcessing();\n\t\t\tfor ( const pendingItem of pendingItems ) {\n\t\t\t\tdispatch.processItem( pendingItem.id );\n\t\t\t}\n\t\t}\n\t};\n}\n\nconst VALID_IMAGE_FORMATS = [ 'jpeg', 'webp', 'avif', 'png', 'gif' ] as const;\n\n/**\n * Checks if a format string is a valid ImageFormat.\n *\n * @param format The format string to validate.\n * @return Whether the format is valid.\n */\nfunction isValidImageFormat( format: string ): format is ImageFormat {\n\treturn VALID_IMAGE_FORMATS.includes( format as ImageFormat );\n}\n\n/**\n * Gets the appropriate interlace setting for the given output format.\n *\n * @param outputMimeType The output mime type.\n * @param settings       The upload settings.\n * @return Whether to use interlaced encoding.\n */\nfunction getInterlacedSetting(\n\toutputMimeType: string,\n\tsettings: Settings\n): boolean {\n\tswitch ( outputMimeType ) {\n\t\tcase 'image/jpeg':\n\t\t\treturn settings.jpegInterlaced ?? false;\n\t\tcase 'image/png':\n\t\t\treturn settings.pngInterlaced ?? false;\n\t\tcase 'image/gif':\n\t\t\treturn settings.gifInterlaced ?? false;\n\t\tdefault:\n\t\t\treturn false;\n\t}\n}\n\n/**\n * Determines if an image should be transcoded to a different format.\n *\n * Handles PNG to JPEG conversion carefully by checking for transparency\n * to preserve the alpha channel when needed.\n *\n * @param file           The image file.\n * @param outputMimeType The target output MIME type.\n * @param settings       Media settings.\n * @return The transcode operation tuple if transcoding is needed, null otherwise.\n */\nexport async function getTranscodeImageOperation(\n\tfile: File,\n\toutputMimeType: string,\n\tsettings: Settings\n): Promise<\n\t| [\n\t\t\tOperationType.TranscodeImage,\n\t\t\tOperationArgs[ OperationType.TranscodeImage ],\n\t  ]\n\t| null\n> {\n\t// For PNG -> JPEG conversion, check if the image has transparency.\n\t// If it does, skip transcoding to preserve the alpha channel.\n\tif ( file.type === 'image/png' && outputMimeType === 'image/jpeg' ) {\n\t\tconst blobUrl = createBlobURL( file );\n\t\ttry {\n\t\t\tconst hasAlpha = await vipsHasTransparency( blobUrl );\n\t\t\tif ( hasAlpha ) {\n\t\t\t\t// Image has transparency, skip conversion to JPEG.\n\t\t\t\treturn null;\n\t\t\t}\n\t\t} catch {\n\t\t\t// If transparency check fails, err on the side of caution.\n\t\t\treturn null;\n\t\t} finally {\n\t\t\trevokeBlobURL( blobUrl );\n\t\t}\n\t}\n\n\tconst formatPart = outputMimeType.split( '/' )[ 1 ];\n\tif ( ! isValidImageFormat( formatPart ) ) {\n\t\t// Unknown format, skip transcoding.\n\t\treturn null;\n\t}\n\n\treturn [\n\t\tOperationType.TranscodeImage,\n\t\t{\n\t\t\toutputFormat: formatPart,\n\t\t\toutputQuality: DEFAULT_OUTPUT_QUALITY,\n\t\t\tinterlaced: getInterlacedSetting( outputMimeType, settings ),\n\t\t},\n\t];\n}\n\n/**\n * Prepares an item for initial processing.\n *\n * Determines the list of operations to perform for a given image,\n * depending on its media type.\n *\n * For example, HEIF images first need to be converted, resized,\n * compressed, and then uploaded.\n *\n * Or videos need to be compressed, and then need poster generation\n * before upload.\n *\n * @param id Item ID.\n */\nexport function prepareItem( id: QueueItemId ) {\n\treturn async ( { select, dispatch }: ThunkArgs ) => {\n\t\tconst item = select.getItem( id );\n\t\tif ( ! item ) {\n\t\t\treturn;\n\t\t}\n\t\tconst { file } = item;\n\n\t\tconst operations: Operation[] = [];\n\t\tconst settings = select.getSettings();\n\n\t\tconst isImage = file.type.startsWith( 'image/' );\n\t\tconst isVipsSupported = CLIENT_SIDE_SUPPORTED_MIME_TYPES.includes(\n\t\t\tfile.type\n\t\t);\n\n\t\t// For images that can be processed by vips, check if we need to scale down based on threshold.\n\t\tif ( isImage && isVipsSupported ) {\n\t\t\tconst { bigImageSizeThreshold, imageOutputFormats } = settings;\n\n\t\t\t// If a threshold is set, add a resize operation to scale down large images.\n\t\t\t// This matches WordPress core's behavior in wp_create_image_subsizes().\n\t\t\tif ( bigImageSizeThreshold ) {\n\t\t\t\toperations.push( [\n\t\t\t\t\tOperationType.ResizeCrop,\n\t\t\t\t\t{\n\t\t\t\t\t\tresize: {\n\t\t\t\t\t\t\twidth: bigImageSizeThreshold,\n\t\t\t\t\t\t\theight: bigImageSizeThreshold,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tisThresholdResize: true,\n\t\t\t\t\t},\n\t\t\t\t] );\n\t\t\t}\n\n\t\t\t// Check if we need to transcode to a different format.\n\t\t\t// Uses WordPress image_editor_output_format filter settings.\n\t\t\tconst outputMimeType = imageOutputFormats?.[ file.type ];\n\t\t\tif ( outputMimeType && outputMimeType !== file.type ) {\n\t\t\t\tconst transcodeOperation = await getTranscodeImageOperation(\n\t\t\t\t\tfile,\n\t\t\t\t\toutputMimeType,\n\t\t\t\t\tsettings\n\t\t\t\t);\n\t\t\t\tif ( transcodeOperation ) {\n\t\t\t\t\toperations.push( transcodeOperation );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\toperations.push(\n\t\t\t\tOperationType.Upload,\n\t\t\t\tOperationType.ThumbnailGeneration\n\t\t\t);\n\t\t} else {\n\t\t\toperations.push( OperationType.Upload );\n\t\t}\n\n\t\tdispatch< AddOperationsAction >( {\n\t\t\ttype: Type.AddOperations,\n\t\t\tid,\n\t\t\toperations,\n\t\t} );\n\n\t\t// If the file is not processed by vips, tell the server to\n\t\t// generate sub-sizes since they won't be created client-side.\n\t\tconst updates =\n\t\t\t! isVipsSupported || ! isImage\n\t\t\t\t? {\n\t\t\t\t\t\tadditionalData: {\n\t\t\t\t\t\t\t...item.additionalData,\n\t\t\t\t\t\t\tgenerate_sub_sizes: true,\n\t\t\t\t\t\t},\n\t\t\t\t  }\n\t\t\t\t: {};\n\n\t\tdispatch.finishOperation( id, updates );\n\t};\n}\n\n/**\n * Uploads an item to the server.\n *\n * @param id Item ID.\n */\nexport function uploadItem( id: QueueItemId ) {\n\treturn async ( { select, dispatch }: ThunkArgs ) => {\n\t\tconst item = select.getItem( id );\n\t\tif ( ! item ) {\n\t\t\treturn;\n\t\t}\n\n\t\tselect.getSettings().mediaUpload( {\n\t\t\tfilesList: [ item.file ],\n\t\t\tadditionalData: item.additionalData,\n\t\t\tsignal: item.abortController?.signal,\n\t\t\tonFileChange: ( [ attachment ] ) => {\n\t\t\t\tif ( ! isBlobURL( attachment.url ) ) {\n\t\t\t\t\tdispatch.finishOperation( id, {\n\t\t\t\t\t\tattachment,\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t},\n\t\t\tonSuccess: ( [ attachment ] ) => {\n\t\t\t\tdispatch.finishOperation( id, {\n\t\t\t\t\tattachment,\n\t\t\t\t} );\n\t\t\t},\n\t\t\tonError: ( error ) => {\n\t\t\t\tdispatch.cancelItem( id, error );\n\t\t\t},\n\t\t} );\n\t};\n}\n\n/**\n * Sideloads an item to the server.\n *\n * @param id Item ID.\n */\nexport function sideloadItem( id: QueueItemId ) {\n\treturn async ( { select, dispatch }: ThunkArgs ) => {\n\t\tconst item = select.getItem( id );\n\t\tif ( ! item ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst { post, ...additionalData } =\n\t\t\titem.additionalData as SideloadAdditionalData;\n\n\t\tconst mediaSideload = select.getSettings().mediaSideload;\n\t\tif ( ! mediaSideload ) {\n\t\t\t// If sideloading is not supported, skip this operation.\n\t\t\tdispatch.finishOperation( id, {} );\n\t\t\treturn;\n\t\t}\n\n\t\tmediaSideload( {\n\t\t\tfile: item.file,\n\t\t\tattachmentId: post as number,\n\t\t\tadditionalData,\n\t\t\tsignal: item.abortController?.signal,\n\t\t\tonFileChange: ( [ attachment ] ) => {\n\t\t\t\tdispatch.finishOperation( id, { attachment } );\n\t\t\t\tdispatch.resumeItemByPostId( post as number );\n\t\t\t},\n\t\t\tonError: ( error ) => {\n\t\t\t\tdispatch.cancelItem( id, error );\n\t\t\t\tdispatch.resumeItemByPostId( post as number );\n\t\t\t},\n\t\t} );\n\t};\n}\n\ntype ResizeCropItemArgs = OperationArgs[ OperationType.ResizeCrop ];\n\n/**\n * Resizes and crops an existing image item.\n *\n * @param id     Item ID.\n * @param [args] Additional arguments for the operation.\n */\nexport function resizeCropItem( id: QueueItemId, args?: ResizeCropItemArgs ) {\n\treturn async ( { select, dispatch }: ThunkArgs ) => {\n\t\tconst item = select.getItem( id );\n\t\tif ( ! item ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( ! args?.resize ) {\n\t\t\tdispatch.finishOperation( id, {\n\t\t\t\tfile: item.file,\n\t\t\t} );\n\t\t\treturn;\n\t\t}\n\n\t\t// Add dimension suffix for sub-sizes (thumbnails).\n\t\tconst addSuffix = Boolean( item.parentId );\n\t\t// Add '-scaled' suffix for big image threshold resizing.\n\t\tconst scaledSuffix = Boolean( args.isThresholdResize );\n\n\t\ttry {\n\t\t\tconst file = await vipsResizeImage(\n\t\t\t\titem.id,\n\t\t\t\titem.file,\n\t\t\t\targs.resize,\n\t\t\t\tfalse, // smartCrop\n\t\t\t\taddSuffix,\n\t\t\t\titem.abortController?.signal,\n\t\t\t\tscaledSuffix\n\t\t\t);\n\n\t\t\tconst blobUrl = createBlobURL( file );\n\t\t\tdispatch< CacheBlobUrlAction >( {\n\t\t\t\ttype: Type.CacheBlobUrl,\n\t\t\t\tid,\n\t\t\t\tblobUrl,\n\t\t\t} );\n\n\t\t\tdispatch.finishOperation( id, {\n\t\t\t\tfile,\n\t\t\t\tattachment: {\n\t\t\t\t\turl: blobUrl,\n\t\t\t\t},\n\t\t\t} );\n\t\t} catch ( error ) {\n\t\t\tdispatch.cancelItem(\n\t\t\t\tid,\n\t\t\t\tnew UploadError( {\n\t\t\t\t\tcode: 'IMAGE_TRANSCODING_ERROR',\n\t\t\t\t\tmessage: 'File could not be uploaded',\n\t\t\t\t\tfile: item.file,\n\t\t\t\t\tcause: error instanceof Error ? error : undefined,\n\t\t\t\t} )\n\t\t\t);\n\t\t}\n\t};\n}\n\ntype RotateItemArgs = OperationArgs[ OperationType.Rotate ];\n\n/**\n * Rotates an image based on EXIF orientation.\n *\n * This is used for images that need rotation but don't need resizing\n * (i.e., smaller than the big image size threshold).\n * Matches WordPress core's behavior of creating a '-rotated' version.\n *\n * @param id     Item ID.\n * @param [args] Rotation arguments including EXIF orientation value.\n */\nexport function rotateItem( id: QueueItemId, args?: RotateItemArgs ) {\n\treturn async ( { select, dispatch }: ThunkArgs ) => {\n\t\tconst item = select.getItem( id );\n\t\tif ( ! item ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If no orientation provided or orientation is 1 (normal), skip rotation.\n\t\tif ( ! args?.orientation || args.orientation === 1 ) {\n\t\t\tdispatch.finishOperation( id, {\n\t\t\t\tfile: item.file,\n\t\t\t} );\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tconst file = await vipsRotateImage(\n\t\t\t\titem.id,\n\t\t\t\titem.file,\n\t\t\t\targs.orientation,\n\t\t\t\titem.abortController?.signal\n\t\t\t);\n\n\t\t\tconst blobUrl = createBlobURL( file );\n\t\t\tdispatch< CacheBlobUrlAction >( {\n\t\t\t\ttype: Type.CacheBlobUrl,\n\t\t\t\tid,\n\t\t\t\tblobUrl,\n\t\t\t} );\n\n\t\t\tdispatch.finishOperation( id, {\n\t\t\t\tfile,\n\t\t\t\tattachment: {\n\t\t\t\t\turl: blobUrl,\n\t\t\t\t},\n\t\t\t} );\n\t\t} catch ( error ) {\n\t\t\tdispatch.cancelItem(\n\t\t\t\tid,\n\t\t\t\tnew UploadError( {\n\t\t\t\t\tcode: 'IMAGE_ROTATION_ERROR',\n\t\t\t\t\tmessage: 'Image could not be rotated',\n\t\t\t\t\tfile: item.file,\n\t\t\t\t\tcause: error instanceof Error ? error : undefined,\n\t\t\t\t} )\n\t\t\t);\n\t\t}\n\t};\n}\n\ntype TranscodeImageItemArgs = OperationArgs[ OperationType.TranscodeImage ];\n\n/**\n * Transcodes an image to a different format.\n *\n * This operation converts images between formats (e.g., PNG to WebP, JPEG to AVIF)\n * based on the WordPress image_editor_output_format filter settings.\n *\n * @param id     Item ID.\n * @param [args] Transcode arguments including output format, quality, and interlace settings.\n */\nexport function transcodeImageItem(\n\tid: QueueItemId,\n\targs?: TranscodeImageItemArgs\n) {\n\treturn async ( { select, dispatch }: ThunkArgs ) => {\n\t\tconst item = select.getItem( id );\n\t\tif ( ! item ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If no output format specified, skip transcoding.\n\t\tif ( ! args?.outputFormat ) {\n\t\t\tdispatch.finishOperation( id, {\n\t\t\t\tfile: item.file,\n\t\t\t} );\n\t\t\treturn;\n\t\t}\n\n\t\tconst outputMimeType = `image/${ args.outputFormat }` as\n\t\t\t| 'image/jpeg'\n\t\t\t| 'image/png'\n\t\t\t| 'image/webp'\n\t\t\t| 'image/avif'\n\t\t\t| 'image/gif';\n\t\tconst quality = args.outputQuality ?? DEFAULT_OUTPUT_QUALITY;\n\t\tconst interlaced = args.interlaced ?? false;\n\n\t\ttry {\n\t\t\tconst file = await vipsConvertImageFormat(\n\t\t\t\titem.id,\n\t\t\t\titem.file,\n\t\t\t\toutputMimeType,\n\t\t\t\tquality,\n\t\t\t\tinterlaced\n\t\t\t);\n\n\t\t\tconst blobUrl = createBlobURL( file );\n\t\t\tdispatch< CacheBlobUrlAction >( {\n\t\t\t\ttype: Type.CacheBlobUrl,\n\t\t\t\tid,\n\t\t\t\tblobUrl,\n\t\t\t} );\n\n\t\t\tdispatch.finishOperation( id, {\n\t\t\t\tfile,\n\t\t\t\tattachment: {\n\t\t\t\t\turl: blobUrl,\n\t\t\t\t},\n\t\t\t} );\n\t\t} catch ( error ) {\n\t\t\tdispatch.cancelItem(\n\t\t\t\tid,\n\t\t\t\tnew UploadError( {\n\t\t\t\t\tcode: 'MEDIA_TRANSCODING_ERROR',\n\t\t\t\t\tmessage:\n\t\t\t\t\t\t'Image could not be transcoded to the target format',\n\t\t\t\t\tfile: item.file,\n\t\t\t\t\tcause: error instanceof Error ? error : undefined,\n\t\t\t\t} )\n\t\t\t);\n\t\t}\n\t};\n}\n\n/**\n * Adds thumbnail versions to the queue for sideloading.\n *\n * Also handles image rotation for images that need EXIF-based rotation\n * but weren't scaled down (and thus weren't auto-rotated by vips).\n *\n * @param id Item ID.\n */\nexport function generateThumbnails( id: QueueItemId ) {\n\treturn async ( { select, dispatch }: ThunkArgs ) => {\n\t\tconst item = select.getItem( id );\n\t\tif ( ! item ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( ! item.attachment ) {\n\t\t\tdispatch.finishOperation( id, {} );\n\t\t\treturn;\n\t\t}\n\t\tconst attachment = item.attachment;\n\n\t\t// Check if image needs rotation.\n\t\t// If exif_orientation is not 1, the image needs rotation.\n\t\t// Images that were scaled (bigImageSizeThreshold) are already rotated by vips.\n\t\tconst needsRotation =\n\t\t\tattachment.exif_orientation &&\n\t\t\tattachment.exif_orientation !== 1 &&\n\t\t\t! item.file.name.includes( '-scaled' );\n\n\t\t// If rotation is needed for a non-scaled image, sideload the rotated version.\n\t\t// This matches WordPress core's behavior of creating a -rotated version.\n\t\tif ( needsRotation && attachment.id ) {\n\t\t\ttry {\n\t\t\t\tconst rotatedFile = await vipsRotateImage(\n\t\t\t\t\titem.id,\n\t\t\t\t\titem.sourceFile,\n\t\t\t\t\tattachment.exif_orientation as number,\n\t\t\t\t\titem.abortController?.signal\n\t\t\t\t);\n\n\t\t\t\t// Sideload the rotated file as the \"original\" to set original_image metadata.\n\t\t\t\t// The server will store this in $metadata['original_image'].\n\t\t\t\tdispatch.addSideloadItem( {\n\t\t\t\t\tfile: rotatedFile,\n\t\t\t\t\tbatchId: uuidv4(),\n\t\t\t\t\tparentId: item.id,\n\t\t\t\t\tadditionalData: {\n\t\t\t\t\t\tpost: attachment.id,\n\t\t\t\t\t\timage_size: 'original',\n\t\t\t\t\t\tconvert_format: false,\n\t\t\t\t\t},\n\t\t\t\t\toperations: [ OperationType.Upload ],\n\t\t\t\t} );\n\t\t\t} catch {\n\t\t\t\t// If rotation fails, continue with thumbnail generation.\n\t\t\t\t// Thumbnails will still be rotated correctly by vips.\n\t\t\t\t// eslint-disable-next-line no-console\n\t\t\t\tconsole.warn(\n\t\t\t\t\t'Failed to rotate image, continuing with thumbnails'\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// Client-side thumbnail generation for images.\n\t\tif (\n\t\t\t! item.parentId &&\n\t\t\tattachment.missing_image_sizes &&\n\t\t\tattachment.missing_image_sizes.length > 0\n\t\t) {\n\t\t\t// Use sourceFile for thumbnail generation to preserve quality.\n\t\t\t// WordPress core generates thumbnails from the original (unscaled) image.\n\t\t\t// Vips will auto-rotate based on EXIF orientation during thumbnail generation.\n\t\t\tconst file = attachment.media_filename\n\t\t\t\t? renameFile( item.sourceFile, attachment.media_filename )\n\t\t\t\t: item.sourceFile;\n\t\t\tconst batchId = uuidv4();\n\n\t\t\tconst settings = select.getSettings();\n\t\t\tconst allImageSizes = settings.allImageSizes || {};\n\t\t\tconst { imageOutputFormats } = settings;\n\n\t\t\t// Check if thumbnails should be transcoded to a different format.\n\t\t\t// Uses the same transparency-aware logic as the main image\n\t\t\t// to avoid converting transparent PNGs to JPEG.\n\t\t\tconst sourceType = item.sourceFile.type;\n\t\t\tconst outputMimeType = imageOutputFormats?.[ sourceType ];\n\n\t\t\tlet thumbnailTranscodeOperation:\n\t\t\t\t| [\n\t\t\t\t\t\tOperationType.TranscodeImage,\n\t\t\t\t\t\tOperationArgs[ OperationType.TranscodeImage ],\n\t\t\t\t  ]\n\t\t\t\t| null = null;\n\n\t\t\tif ( outputMimeType && outputMimeType !== sourceType ) {\n\t\t\t\tthumbnailTranscodeOperation = await getTranscodeImageOperation(\n\t\t\t\t\titem.sourceFile,\n\t\t\t\t\toutputMimeType,\n\t\t\t\t\tsettings\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tfor ( const name of attachment.missing_image_sizes ) {\n\t\t\t\tconst imageSize = allImageSizes[ name ];\n\t\t\t\tif ( ! imageSize ) {\n\t\t\t\t\t// eslint-disable-next-line no-console\n\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t`Image size \"${ name }\" not found in configuration`\n\t\t\t\t\t);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Build operations list for this thumbnail.\n\t\t\t\tconst thumbnailOperations: Operation[] = [\n\t\t\t\t\t[ OperationType.ResizeCrop, { resize: imageSize } ],\n\t\t\t\t];\n\n\t\t\t\t// Add transcoding if format conversion is configured and\n\t\t\t\t// the transparency check passed.\n\t\t\t\tif ( thumbnailTranscodeOperation ) {\n\t\t\t\t\tthumbnailOperations.push( thumbnailTranscodeOperation );\n\t\t\t\t}\n\n\t\t\t\tthumbnailOperations.push( OperationType.Upload );\n\n\t\t\t\tdispatch.addSideloadItem( {\n\t\t\t\t\tfile,\n\t\t\t\t\tonChange: ( [ updatedAttachment ] ) => {\n\t\t\t\t\t\t// If the sub-size is still being generated, there is no need\n\t\t\t\t\t\t// to invoke the callback below. It would just override\n\t\t\t\t\t\t// the main image in the editor with the sub-size.\n\t\t\t\t\t\tif ( isBlobURL( updatedAttachment.url ) ) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// This might be confusing, but the idea is to update the original\n\t\t\t\t\t\t// image item in the editor with the new one with the added sub-size.\n\t\t\t\t\t\titem.onChange?.( [ updatedAttachment ] );\n\t\t\t\t\t},\n\t\t\t\t\tbatchId,\n\t\t\t\t\tparentId: item.id,\n\t\t\t\t\tadditionalData: {\n\t\t\t\t\t\t// Sideloading does not use the parent post ID but the\n\t\t\t\t\t\t// attachment ID as the image sizes need to be added to it.\n\t\t\t\t\t\tpost: attachment.id,\n\t\t\t\t\t\timage_size: name,\n\t\t\t\t\t\tconvert_format: false,\n\t\t\t\t\t},\n\t\t\t\t\toperations: thumbnailOperations,\n\t\t\t\t} );\n\t\t\t}\n\t\t}\n\n\t\tdispatch.finishOperation( id, {} );\n\t};\n}\n\n/**\n * Revokes all blob URLs for a given item, freeing up memory.\n *\n * @param id Item ID.\n */\nexport function revokeBlobUrls( id: QueueItemId ) {\n\treturn async ( { select, dispatch }: ThunkArgs ) => {\n\t\tconst blobUrls = select.getBlobUrls( id );\n\n\t\tfor ( const blobUrl of blobUrls ) {\n\t\t\trevokeBlobURL( blobUrl );\n\t\t}\n\n\t\tdispatch< RevokeBlobUrlsAction >( {\n\t\t\ttype: Type.RevokeBlobUrls,\n\t\t\tid,\n\t\t} );\n\t};\n}\n\n/**\n * Updates the progress of an item.\n *\n * @param id       Item ID.\n * @param progress Progress value (0-100).\n */\nexport function updateItemProgress( id: QueueItemId, progress: number ) {\n\treturn async ( { dispatch }: ThunkArgs ) => {\n\t\tdispatch< UpdateProgressAction >( {\n\t\t\ttype: Type.UpdateProgress,\n\t\t\tid,\n\t\t\tprogress,\n\t\t} );\n\t};\n}\n\n/**\n * Returns an action object that updates the store settings.\n *\n * Useful for testing purposes.\n *\n * @param settings\n * @return Action object.\n */\nexport function updateSettings(\n\tsettings: Partial< Settings >\n): UpdateSettingsAction {\n\treturn {\n\t\ttype: Type.UpdateSettings,\n\t\tsettings,\n\t};\n}\n", "export class StubFile extends File {\n\tconstructor( fileName = 'stub-file' ) {\n\t\tsuper( [], fileName );\n\t}\n}\n", "/**\n * WordPress dependencies\n */\nimport { __dangerousOptInToUnstableAPIsOnlyForCoreModules } from '@wordpress/private-apis';\n\nexport const { lock, unlock } =\n\t__dangerousOptInToUnstableAPIsOnlyForCoreModules(\n\t\t'I acknowledge private features are not for use in themes or plugins and doing so will break in the next version of WordPress.',\n\t\t'@wordpress/upload-media'\n\t);\n", "/**\n * WordPress dependencies\n */\nimport { useEffect } from '@wordpress/element';\nimport { useDispatch } from '@wordpress/data';\n\n/**\n * Internal dependencies\n */\nimport withRegistryProvider from './with-registry-provider';\nimport { unlock } from '../../lock-unlock';\nimport { store as uploadStore } from '../../store';\n\nconst MediaUploadProvider = withRegistryProvider( ( props: any ) => {\n\tconst { children, settings } = props;\n\tconst { updateSettings } = unlock( useDispatch( uploadStore ) );\n\n\tuseEffect( () => {\n\t\tupdateSettings( settings );\n\t}, [ settings, updateSettings ] );\n\n\treturn <>{ children }</>;\n} );\n\nexport default MediaUploadProvider;\n", "/**\n * WordPress dependencies\n */\nimport { useState } from '@wordpress/element';\nimport { useRegistry, createRegistry, RegistryProvider } from '@wordpress/data';\nimport { createHigherOrderComponent } from '@wordpress/compose';\n\n/**\n * Internal dependencies\n */\nimport { storeConfig } from '../../store';\nimport { STORE_NAME as mediaUploadStoreName } from '../../store/constants';\n\ntype WPDataRegistry = ReturnType< typeof createRegistry >;\n\nfunction getSubRegistry(\n\tsubRegistries: WeakMap< WPDataRegistry, WPDataRegistry >,\n\tregistry: WPDataRegistry,\n\tuseSubRegistry: boolean\n) {\n\tif ( ! useSubRegistry ) {\n\t\treturn registry;\n\t}\n\tlet subRegistry = subRegistries.get( registry );\n\tif ( ! subRegistry ) {\n\t\tsubRegistry = createRegistry( {}, registry );\n\t\tsubRegistry.registerStore( mediaUploadStoreName, storeConfig );\n\t\tsubRegistries.set( registry, subRegistry );\n\t}\n\treturn subRegistry;\n}\n\nconst withRegistryProvider = createHigherOrderComponent(\n\t( WrappedComponent ) =>\n\t\t( { useSubRegistry = true, ...props } ) => {\n\t\t\tconst registry = useRegistry() as unknown as WPDataRegistry;\n\t\t\tconst [ subRegistries ] = useState<\n\t\t\t\tWeakMap< WPDataRegistry, WPDataRegistry >\n\t\t\t>( () => new WeakMap() );\n\t\t\tconst subRegistry = getSubRegistry(\n\t\t\t\tsubRegistries,\n\t\t\t\tregistry,\n\t\t\t\tuseSubRegistry\n\t\t\t);\n\n\t\t\tif ( subRegistry === registry ) {\n\t\t\t\treturn <WrappedComponent registry={ registry } { ...props } />;\n\t\t\t}\n\n\t\t\treturn (\n\t\t\t\t<RegistryProvider value={ subRegistry }>\n\t\t\t\t\t<WrappedComponent registry={ subRegistry } { ...props } />\n\t\t\t\t</RegistryProvider>\n\t\t\t);\n\t\t},\n\t'withRegistryProvider'\n);\n\nexport default withRegistryProvider;\n", "/**\n * Result of client-side media processing support detection.\n */\nexport interface FeatureDetectionResult {\n\t/**\n\t * Whether client-side media processing is supported.\n\t */\n\tsupported: boolean;\n\t/**\n\t * Reason why client-side media processing is not supported (if applicable).\n\t */\n\treason?: string;\n}\n\n/**\n * Cached result of feature detection.\n */\nlet cachedResult: FeatureDetectionResult | null = null;\n\n/**\n * Detects whether the browser supports client-side media processing.\n *\n * This checks for:\n * 1. WebAssembly support (required for wasm-vips)\n * 2. SharedArrayBuffer support (required for WASM threading)\n * 3. CSP compatibility for blob URL workers (required for inline worker creation)\n *\n * @return Feature detection result with supported status and reason if not supported.\n */\nexport function detectClientSideMediaSupport(): FeatureDetectionResult {\n\t// Return cached result if available.\n\tif ( cachedResult !== null ) {\n\t\treturn cachedResult;\n\t}\n\n\t// Check WebAssembly support.\n\tif ( typeof WebAssembly === 'undefined' ) {\n\t\tcachedResult = {\n\t\t\tsupported: false,\n\t\t\treason: 'WebAssembly is not supported in this browser',\n\t\t};\n\t\treturn cachedResult;\n\t}\n\n\t// Check SharedArrayBuffer support (required for WASM threading).\n\tif ( typeof SharedArrayBuffer === 'undefined' ) {\n\t\tcachedResult = {\n\t\t\tsupported: false,\n\t\t\treason: 'SharedArrayBuffer is not available. This may be due to missing cross-origin isolation headers.',\n\t\t};\n\t\treturn cachedResult;\n\t}\n\n\t// Check that blob URL workers are allowed by CSP.\n\t// Security plugins often set a strict worker-src directive that blocks blob: URLs,\n\t// which would prevent creating the WASM processing worker at runtime.\n\tif ( typeof window !== 'undefined' && typeof Worker !== 'undefined' ) {\n\t\ttry {\n\t\t\tconst testBlob = new Blob( [ '' ], {\n\t\t\t\ttype: 'application/javascript',\n\t\t\t} );\n\t\t\tconst testUrl = URL.createObjectURL( testBlob );\n\t\t\ttry {\n\t\t\t\tconst testWorker = new Worker( testUrl );\n\t\t\t\ttestWorker.terminate();\n\t\t\t} finally {\n\t\t\t\tURL.revokeObjectURL( testUrl );\n\t\t\t}\n\t\t} catch {\n\t\t\tcachedResult = {\n\t\t\t\tsupported: false,\n\t\t\t\treason: \"The site's Content Security Policy (CSP) does not allow blob: workers. The worker-src directive must include blob: to enable client-side media processing.\",\n\t\t\t};\n\t\t\treturn cachedResult;\n\t\t}\n\t}\n\n\tcachedResult = { supported: true };\n\treturn cachedResult;\n}\n\n/**\n * Returns whether client-side media processing is supported.\n *\n * This is a convenience function that returns just the boolean result.\n *\n * @return Whether client-side media processing is supported.\n */\nexport function isClientSideMediaSupported(): boolean {\n\treturn detectClientSideMediaSupport().supported;\n}\n\n/**\n * Clears the cached feature detection result.\n *\n * This is primarily useful for testing purposes.\n */\nexport function clearFeatureDetectionCache(): void {\n\tcachedResult = null;\n}\n"],
  "mappings": "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",
  "names": ["require_data", "__commonJSMin", "exports", "module", "require_url", "__commonJSMin", "exports", "module", "require_i18n", "__commonJSMin", "exports", "module", "require_blob", "__commonJSMin", "exports", "module", "require_private_apis", "__commonJSMin", "exports", "module", "require_element", "__commonJSMin", "exports", "module", "require_compose", "__commonJSMin", "exports", "module", "require_jsx_runtime", "__commonJSMin", "exports", "module", "import_data", "Type", "ItemStatus", "OperationType", "STORE_NAME", "DEFAULT_MAX_CONCURRENT_UPLOADS", "DEFAULT_MAX_CONCURRENT_IMAGE_PROCESSING", "CLIENT_SIDE_SUPPORTED_MIME_TYPES", "noop", "DEFAULT_STATE", "DEFAULT_MAX_CONCURRENT_UPLOADS", "DEFAULT_MAX_CONCURRENT_IMAGE_PROCESSING", "reducer", "state", "action", "Type", "item", "ItemStatus", "operations", "attachment", "blobUrls", "newBlobUrls", "reducer_default", "getItems", "state", "isUploading", "isUploadingByUrl", "url", "item", "isUploadingById", "attachmentId", "getSettings", "getAllItems", "state", "getItem", "id", "item", "isBatchUploaded", "batchId", "isUploadingToPost", "postOrAttachmentId", "OperationType", "getPausedUploadForPost", "ItemStatus", "isPaused", "getBlobUrls", "getActiveUploadCount", "getPendingUploads", "getActiveImageProcessingCount", "getPendingImageProcessing", "nextOperation", "getFailedItems", "hasPendingItemsByParentId", "parentId", "getItemProgress", "i", "getRandomValues", "rnds8", "rng", "byteToHex", "i", "unsafeStringify", "arr", "offset", "randomUUID", "native_default", "v4", "options", "buf", "offset", "native_default", "rnds", "rng", "i", "unsafeStringify", "v4_default", "ImageFile", "file", "width", "height", "originalWidth", "originalHeight", "import_url", "import_i18n", "convertBlobToFile", "fileOrBlob", "ext", "mediaType", "renameFile", "file", "name", "cloneFile", "getFileBasename", "name", "vipsModulePromise", "vipsModule", "loadVipsModule", "mod", "vipsConvertImageFormat", "id", "file", "type", "quality", "interlaced", "convertImageFormat", "buffer", "ext", "fileName", "getFileBasename", "vipsHasTransparency", "url", "hasTransparency", "loadVipsModule", "response", "vipsResizeImage", "id", "file", "resize", "smartCrop", "addSuffix", "signal", "scaledSuffix", "resizeImage", "buffer", "width", "height", "originalWidth", "originalHeight", "fileName", "basename", "getFileBasename", "ImageFile", "vipsRotateImage", "orientation", "rotateImage", "vipsCancelOperations", "vipsModule", "terminateVipsWorker", "import_i18n", "UploadError", "code", "message", "file", "cause", "validateMimeType", "file", "allowedTypes", "isAllowedType", "allowedType", "UploadError", "import_i18n", "getMimeTypesArray", "wpMimeTypesObject", "extensionsString", "mime", "type", "extensions", "extension", "validateMimeTypeForUser", "file", "wpAllowedMimeTypes", "allowedMimeTypesForUser", "getMimeTypesArray", "isAllowedMimeTypeForUser", "UploadError", "import_i18n", "validateFileSize", "file", "maxUploadFileSize", "UploadError", "addItems", "files", "onChange", "onSuccess", "onError", "onBatchSuccess", "additionalData", "allowedTypes", "select", "dispatch", "batchId", "v4_default", "file", "validateMimeType", "validateMimeTypeForUser", "error", "validateFileSize", "cancelItem", "id", "silent", "item", "vipsCancelOperations", "Type", "retryItem", "import_blob", "StubFile", "fileName", "DEFAULT_OUTPUT_QUALITY", "shouldPauseForSideload", "item", "operation", "select", "OperationType", "addItem", "fileOrBlob", "batchId", "onChange", "onSuccess", "onBatchSuccess", "onError", "additionalData", "sourceUrl", "sourceAttachmentId", "abortController", "operations", "dispatch", "itemId", "v4_default", "file", "convertBlobToFile", "blobUrl", "StubFile", "Type", "ItemStatus", "cloneFile", "addSideloadItem", "parentId", "processItem", "id", "attachment", "operationArgs", "settings", "parentItem", "pauseQueue", "resumeQueue", "pauseItem", "resumeItemByPostId", "postOrAttachmentId", "removeItem", "terminateVipsWorker", "finishOperation", "updates", "previousOperation", "pendingUploads", "pendingItem", "pendingItems", "VALID_IMAGE_FORMATS", "isValidImageFormat", "format", "getInterlacedSetting", "outputMimeType", "getTranscodeImageOperation", "vipsHasTransparency", "formatPart", "prepareItem", "isImage", "isVipsSupported", "CLIENT_SIDE_SUPPORTED_MIME_TYPES", "bigImageSizeThreshold", "imageOutputFormats", "transcodeOperation", "uploadItem", "error", "sideloadItem", "post", "mediaSideload", "resizeCropItem", "args", "addSuffix", "scaledSuffix", "vipsResizeImage", "UploadError", "rotateItem", "vipsRotateImage", "transcodeImageItem", "quality", "interlaced", "vipsConvertImageFormat", "generateThumbnails", "rotatedFile", "renameFile", "allImageSizes", "sourceType", "thumbnailTranscodeOperation", "name", "imageSize", "thumbnailOperations", "updatedAttachment", "revokeBlobUrls", "blobUrls", "updateItemProgress", "progress", "updateSettings", "import_private_apis", "lock", "unlock", "storeConfig", "reducer_default", "selectors_exports", "actions_exports", "store", "STORE_NAME", "unlock", "private_actions_exports", "private_selectors_exports", "import_element", "import_data", "import_element", "import_data", "import_compose", "import_jsx_runtime", "getSubRegistry", "subRegistries", "registry", "useSubRegistry", "subRegistry", "STORE_NAME", "storeConfig", "withRegistryProvider", "WrappedComponent", "props", "with_registry_provider_default", "import_jsx_runtime", "MediaUploadProvider", "with_registry_provider_default", "props", "children", "settings", "updateSettings", "unlock", "store", "provider_default", "cachedResult", "detectClientSideMediaSupport", "testBlob", "testUrl", "isClientSideMediaSupported", "clearFeatureDetectionCache"]
}
