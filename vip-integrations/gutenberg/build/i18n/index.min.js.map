{"version":3,"file":"./build/i18n/index.min.js","mappings":"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","sources":["webpack://wp/webpack/bootstrap","webpack://wp/webpack/runtime/define property getters","webpack://wp/webpack/runtime/hasOwnProperty shorthand","webpack://wp/webpack/runtime/make namespace object","webpack://wp/./node_modules/@tannin/sprintf/src/index.js","webpack://wp/./node_modules/@tannin/postfix/index.js","../../packages/i18n/src/sprintf.ts","webpack://wp/./node_modules/@tannin/evaluate/index.js","webpack://wp/./node_modules/tannin/index.js","webpack://wp/./node_modules/@tannin/plural-forms/index.js","webpack://wp/./node_modules/@tannin/compile/index.js","../../packages/i18n/src/create-i18n.ts","webpack://wp/external window [\"wp\",\"hooks\"]","../../packages/i18n/src/default-i18n.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * Regular expression matching format placeholder syntax.\n *\n * The pattern for matching named arguments is a naive and incomplete matcher\n * against valid JavaScript identifier names.\n *\n * via Mathias Bynens:\n *\n * >An identifier must start with $, _, or any character in the Unicode\n * >categories “Uppercase letter (Lu)”, “Lowercase letter (Ll)”, “Titlecase\n * >letter (Lt)”, “Modifier letter (Lm)”, “Other letter (Lo)”, or “Letter\n * >number (Nl)”.\n * >\n * >The rest of the string can contain the same characters, plus any U+200C zero\n * >width non-joiner characters, U+200D zero width joiner characters, and\n * >characters in the Unicode categories “Non-spacing mark (Mn)”, “Spacing\n * >combining mark (Mc)”, “Decimal digit number (Nd)”, or “Connector\n * >punctuation (Pc)”.\n *\n * If browser support is constrained to those supporting ES2015, this could be\n * made more accurate using the `u` flag:\n *\n * ```\n * /^[$_\\p{L}\\p{Nl}][$_\\p{L}\\p{Nl}\\u200C\\u200D\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}]*$/u;\n * ```\n *\n * @see http://www.pixelbeat.org/programming/gcc/format_specs.html\n * @see https://mathiasbynens.be/notes/javascript-identifiers#valid-identifier-names\n *\n * @type {RegExp}\n */\nvar PATTERN =\n\t/%(((\\d+)\\$)|(\\(([$_a-zA-Z][$_a-zA-Z0-9]*)\\)))?[ +0#-]*\\d*(\\.(\\d+|\\*))?(ll|[lhqL])?([cduxXefgsp%])/g;\n//               ▲         ▲                    ▲       ▲  ▲            ▲           ▲ type\n//               │         │                    │       │  │            └ Length (unsupported)\n//               │         │                    │       │  └ Precision / max width\n//               │         │                    │       └ Min width (unsupported)\n//               │         │                    └ Flags (unsupported)\n//               └ Index   └ Name (for named arguments)\n/**\n * Given a format string, returns string with arguments interpolatation.\n * Arguments can either be provided directly via function arguments spread, or\n * with an array as the second argument.\n *\n * @see https://en.wikipedia.org/wiki/Printf_format_string\n *\n * @example\n *\n * ```js\n * import sprintf from '@tannin/sprintf';\n *\n * sprintf( 'Hello %s!', 'world' );\n * // ⇒ 'Hello world!'\n * ```\n * @template {string} T\n * @overload\n * @param {T} string - string printf format string\n * @param {...import('../types').SprintfArgs<T>} args - arguments to interpolate\n *\n * @return {string} Formatted string.\n */\n\n/**\n * Given a format string, returns string with arguments interpolatation.\n * Arguments can either be provided directly via function arguments spread, or\n * with an array as the second argument.\n *\n * @see https://en.wikipedia.org/wiki/Printf_format_string\n *\n * @example\n *\n * ```js\n * import sprintf from '@tannin/sprintf';\n *\n * sprintf( 'Hello %s!', 'world' );\n * // ⇒ 'Hello world!'\n * ```\n * @template {string} T\n * @overload\n * @param {T} string - string printf format string\n * @param {import('../types').SprintfArgs<T>} args - arguments to interpolate\n *\n * @return {string} Formatted string.\n */\n\n/**\n * Given a format string, returns string with arguments interpolatation.\n * Arguments can either be provided directly via function arguments spread, or\n * with an array as the second argument.\n *\n * @see https://en.wikipedia.org/wiki/Printf_format_string\n *\n * @example\n *\n * ```js\n * import sprintf from '@tannin/sprintf';\n *\n * sprintf( 'Hello %s!', 'world' );\n * // ⇒ 'Hello world!'\n * ```\n * @template {string} T\n * @param {T} string - string printf format string\n * @param {...import('../types').SprintfArgs<T>} args - arguments to interpolate\n *\n * @return {string} Formatted string.\n */\nexport default function sprintf(string, ...args) {\n\tvar i = 0;\n\tif (Array.isArray(args[0])) {\n\t\targs = /** @type {import('../types').SprintfArgs<T>[]} */ (\n\t\t\t/** @type {unknown} */ args[0]\n\t\t);\n\t}\n\n\treturn string.replace(PATTERN, function () {\n\t\tvar index,\n\t\t\t// name needs to be documented as `string | undefined` else value will have tpye unknown.\n\t\t\t/**\n\t\t\t * Name of the argument to substitute, if any.\n\t\t\t *\n\t\t\t * @type {string | undefined}\n\t\t\t */\n\t\t\tname,\n\t\t\tprecision,\n\t\t\ttype,\n\t\t\tvalue;\n\n\t\tindex = arguments[3];\n\t\tname = arguments[5];\n\t\tprecision = arguments[7];\n\t\ttype = arguments[9];\n\n\t\t// There's no placeholder substitution in the explicit \"%\", meaning it\n\t\t// is not necessary to increment argument index.\n\t\tif (type === '%') {\n\t\t\treturn '%';\n\t\t}\n\n\t\t// Asterisk precision determined by peeking / shifting next argument.\n\t\tif (precision === '*') {\n\t\t\tprecision = args[i];\n\t\t\ti++;\n\t\t}\n\n\t\tif (name === undefined) {\n\t\t\t// If not a positional argument, use counter value.\n\t\t\tif (index === undefined) {\n\t\t\t\tindex = i + 1;\n\t\t\t}\n\n\t\t\ti++;\n\n\t\t\t// Positional argument.\n\t\t\tvalue = args[index - 1];\n\t\t} else if (\n\t\t\targs[0] &&\n\t\t\ttypeof args[0] === 'object' &&\n\t\t\targs[0].hasOwnProperty(name)\n\t\t) {\n\t\t\t// If it's a named argument, use name.\n\t\t\tvalue = args[0][name];\n\t\t}\n\n\t\t// Parse as type.\n\t\tif (type === 'f') {\n\t\t\tvalue = parseFloat(value) || 0;\n\t\t} else if (type === 'd') {\n\t\t\tvalue = parseInt(value) || 0;\n\t\t}\n\n\t\t// Apply precision.\n\t\tif (precision !== undefined) {\n\t\t\tif (type === 'f') {\n\t\t\t\tvalue = value.toFixed(precision);\n\t\t\t} else if (type === 's') {\n\t\t\t\tvalue = value.substr(0, precision);\n\t\t\t}\n\t\t}\n\n\t\t// To avoid \"undefined\" concatenation, return empty string if no\n\t\t// placeholder substitution can be performed.\n\t\treturn value !== undefined && value !== null ? value : '';\n\t});\n}\n","var PRECEDENCE, OPENERS, TERMINATORS, PATTERN;\n\n/**\n * Operator precedence mapping.\n *\n * @type {Object}\n */\nPRECEDENCE = {\n\t'(': 9,\n\t'!': 8,\n\t'*': 7,\n\t'/': 7,\n\t'%': 7,\n\t'+': 6,\n\t'-': 6,\n\t'<': 5,\n\t'<=': 5,\n\t'>': 5,\n\t'>=': 5,\n\t'==': 4,\n\t'!=': 4,\n\t'&&': 3,\n\t'||': 2,\n\t'?': 1,\n\t'?:': 1,\n};\n\n/**\n * Characters which signal pair opening, to be terminated by terminators.\n *\n * @type {string[]}\n */\nOPENERS = [ '(', '?' ];\n\n/**\n * Characters which signal pair termination, the value an array with the\n * opener as its first member. The second member is an optional operator\n * replacement to push to the stack.\n *\n * @type {string[]}\n */\nTERMINATORS = {\n\t')': [ '(' ],\n\t':': [ '?', '?:' ],\n};\n\n/**\n * Pattern matching operators and openers.\n *\n * @type {RegExp}\n */\nPATTERN = /<=|>=|==|!=|&&|\\|\\||\\?:|\\(|!|\\*|\\/|%|\\+|-|<|>|\\?|\\)|:/;\n\n/**\n * Given a C expression, returns the equivalent postfix (Reverse Polish)\n * notation terms as an array.\n *\n * If a postfix string is desired, simply `.join( ' ' )` the result.\n *\n * @example\n *\n * ```js\n * import postfix from '@tannin/postfix';\n *\n * postfix( 'n > 1' );\n * // ⇒ [ 'n', '1', '>' ]\n * ```\n *\n * @param {string} expression C expression.\n *\n * @return {string[]} Postfix terms.\n */\nexport default function postfix( expression ) {\n\tvar terms = [],\n\t\tstack = [],\n\t\tmatch, operator, term, element;\n\n\twhile ( ( match = expression.match( PATTERN ) ) ) {\n\t\toperator = match[ 0 ];\n\n\t\t// Term is the string preceding the operator match. It may contain\n\t\t// whitespace, and may be empty (if operator is at beginning).\n\t\tterm = expression.substr( 0, match.index ).trim();\n\t\tif ( term ) {\n\t\t\tterms.push( term );\n\t\t}\n\n\t\twhile ( ( element = stack.pop() ) ) {\n\t\t\tif ( TERMINATORS[ operator ] ) {\n\t\t\t\tif ( TERMINATORS[ operator ][ 0 ] === element ) {\n\t\t\t\t\t// Substitution works here under assumption that because\n\t\t\t\t\t// the assigned operator will no longer be a terminator, it\n\t\t\t\t\t// will be pushed to the stack during the condition below.\n\t\t\t\t\toperator = TERMINATORS[ operator ][ 1 ] || operator;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if ( OPENERS.indexOf( element ) >= 0 || PRECEDENCE[ element ] < PRECEDENCE[ operator ] ) {\n\t\t\t\t// Push to stack if either an opener or when pop reveals an\n\t\t\t\t// element of lower precedence.\n\t\t\t\tstack.push( element );\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// For each popped from stack, push to terms.\n\t\t\tterms.push( element );\n\t\t}\n\n\t\tif ( ! TERMINATORS[ operator ] ) {\n\t\t\tstack.push( operator );\n\t\t}\n\n\t\t// Slice matched fragment from expression to continue match.\n\t\texpression = expression.substr( match.index + operator.length );\n\t}\n\n\t// Push remainder of operand, if exists, to terms.\n\texpression = expression.trim();\n\tif ( expression ) {\n\t\tterms.push( expression );\n\t}\n\n\t// Pop remaining items from stack into terms.\n\treturn terms.concat( stack.reverse() );\n}\n","/**\n * External dependencies\n */\n// Disable reason: `eslint-plugin-import` doesn't support `exports` (https://github.com/import-js/eslint-plugin-import/issues/1810)\n// eslint-disable-next-line import/no-unresolved\nimport _sprintf from '@tannin/sprintf';\n\n/**\n * Internal dependencies\n */\nimport type { DistributeSprintfArgs, TranslatableText } from './types';\n\nexport function sprintf< T extends string >(\n\tformat: T | TranslatableText< T >,\n\t...args: DistributeSprintfArgs< T >\n): string;\nexport function sprintf< T extends string >(\n\tformat: T | TranslatableText< T >,\n\targs: DistributeSprintfArgs< T >\n): string;\n\n/**\n * Returns a formatted string.\n *\n * @param format The format of the string to generate.\n * @param args   Arguments to apply to the format.\n *\n * @see https://www.npmjs.com/package/@tannin/sprintf\n *\n * @return The formatted string.\n */\nexport function sprintf< T extends string >(\n\tformat: T | TranslatableText< T >,\n\t...args: DistributeSprintfArgs< T >\n): string {\n\treturn _sprintf( format as T, ...( args as DistributeSprintfArgs< T > ) );\n}\n","/**\n * Operator callback functions.\n *\n * @type {Object}\n */\nvar OPERATORS = {\n\t'!': function( a ) {\n\t\treturn ! a;\n\t},\n\t'*': function( a, b ) {\n\t\treturn a * b;\n\t},\n\t'/': function( a, b ) {\n\t\treturn a / b;\n\t},\n\t'%': function( a, b ) {\n\t\treturn a % b;\n\t},\n\t'+': function( a, b ) {\n\t\treturn a + b;\n\t},\n\t'-': function( a, b ) {\n\t\treturn a - b;\n\t},\n\t'<': function( a, b ) {\n\t\treturn a < b;\n\t},\n\t'<=': function( a, b ) {\n\t\treturn a <= b;\n\t},\n\t'>': function( a, b ) {\n\t\treturn a > b;\n\t},\n\t'>=': function( a, b ) {\n\t\treturn a >= b;\n\t},\n\t'==': function( a, b ) {\n\t\treturn a === b;\n\t},\n\t'!=': function( a, b ) {\n\t\treturn a !== b;\n\t},\n\t'&&': function( a, b ) {\n\t\treturn a && b;\n\t},\n\t'||': function( a, b ) {\n\t\treturn a || b;\n\t},\n\t'?:': function( a, b, c ) {\n\t\tif ( a ) {\n\t\t\tthrow b;\n\t\t}\n\n\t\treturn c;\n\t},\n};\n\n/**\n * Given an array of postfix terms and operand variables, returns the result of\n * the postfix evaluation.\n *\n * @example\n *\n * ```js\n * import evaluate from '@tannin/evaluate';\n *\n * // 3 + 4 * 5 / 6 ⇒ '3 4 5 * 6 / +'\n * const terms = [ '3', '4', '5', '*', '6', '/', '+' ];\n *\n * evaluate( terms, {} );\n * // ⇒ 6.333333333333334\n * ```\n *\n * @param {string[]} postfix   Postfix terms.\n * @param {Object}   variables Operand variables.\n *\n * @return {*} Result of evaluation.\n */\nexport default function evaluate( postfix, variables ) {\n\tvar stack = [],\n\t\ti, j, args, getOperatorResult, term, value;\n\n\tfor ( i = 0; i < postfix.length; i++ ) {\n\t\tterm = postfix[ i ];\n\n\t\tgetOperatorResult = OPERATORS[ term ];\n\t\tif ( getOperatorResult ) {\n\t\t\t// Pop from stack by number of function arguments.\n\t\t\tj = getOperatorResult.length;\n\t\t\targs = Array( j );\n\t\t\twhile ( j-- ) {\n\t\t\t\targs[ j ] = stack.pop();\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tvalue = getOperatorResult.apply( null, args );\n\t\t\t} catch ( earlyReturn ) {\n\t\t\t\treturn earlyReturn;\n\t\t\t}\n\t\t} else if ( variables.hasOwnProperty( term ) ) {\n\t\t\tvalue = variables[ term ];\n\t\t} else {\n\t\t\tvalue = +term;\n\t\t}\n\n\t\tstack.push( value );\n\t}\n\n\treturn stack[ 0 ];\n}\n","import pluralForms from '@tannin/plural-forms';\n\n/**\n * Tannin constructor options.\n *\n * @typedef {Object} TanninOptions\n *\n * @property {string}   [contextDelimiter] Joiner in string lookup with context.\n * @property {Function} [onMissingKey]     Callback to invoke when key missing.\n */\n\n/**\n * Domain metadata.\n *\n * @typedef {Object} TanninDomainMetadata\n *\n * @property {string}            [domain]       Domain name.\n * @property {string}            [lang]         Language code.\n * @property {(string|Function)} [plural_forms] Plural forms expression or\n *                                              function evaluator.\n */\n\n/**\n * Domain translation pair respectively representing the singular and plural\n * translation.\n *\n * @typedef {[string,string]} TanninTranslation\n */\n\n/**\n * Locale data domain. The key is used as reference for lookup, the value an\n * array of two string entries respectively representing the singular and plural\n * translation.\n *\n * @typedef {{[key:string]:TanninDomainMetadata|TanninTranslation,'':TanninDomainMetadata|TanninTranslation}} TanninLocaleDomain\n */\n\n/**\n * Jed-formatted locale data.\n *\n * @see http://messageformat.github.io/Jed/\n *\n * @typedef {{[domain:string]:TanninLocaleDomain}} TanninLocaleData\n */\n\n/**\n * Default Tannin constructor options.\n *\n * @type {TanninOptions}\n */\nvar DEFAULT_OPTIONS = {\n\tcontextDelimiter: '\\u0004',\n\tonMissingKey: null,\n};\n\n/**\n * Given a specific locale data's config `plural_forms` value, returns the\n * expression.\n *\n * @example\n *\n * ```\n * getPluralExpression( 'nplurals=2; plural=(n != 1);' ) === '(n != 1)'\n * ```\n *\n * @param {string} pf Locale data plural forms.\n *\n * @return {string} Plural forms expression.\n */\nfunction getPluralExpression( pf ) {\n\tvar parts, i, part;\n\n\tparts = pf.split( ';' );\n\n\tfor ( i = 0; i < parts.length; i++ ) {\n\t\tpart = parts[ i ].trim();\n\t\tif ( part.indexOf( 'plural=' ) === 0 ) {\n\t\t\treturn part.substr( 7 );\n\t\t}\n\t}\n}\n\n/**\n * Tannin constructor.\n *\n * @class\n *\n * @param {TanninLocaleData} data      Jed-formatted locale data.\n * @param {TanninOptions}    [options] Tannin options.\n */\nexport default function Tannin( data, options ) {\n\tvar key;\n\n\t/**\n\t * Jed-formatted locale data.\n\t *\n\t * @name Tannin#data\n\t * @type {TanninLocaleData}\n\t */\n\tthis.data = data;\n\n\t/**\n\t * Plural forms function cache, keyed by plural forms string.\n\t *\n\t * @name Tannin#pluralForms\n\t * @type {Object<string,Function>}\n\t */\n\tthis.pluralForms = {};\n\n\t/**\n\t * Effective options for instance, including defaults.\n\t *\n\t * @name Tannin#options\n\t * @type {TanninOptions}\n\t */\n\tthis.options = {};\n\n\tfor ( key in DEFAULT_OPTIONS ) {\n\t\tthis.options[ key ] = options !== undefined && key in options\n\t\t\t? options[ key ]\n\t\t\t: DEFAULT_OPTIONS[ key ];\n\t}\n}\n\n/**\n * Returns the plural form index for the given domain and value.\n *\n * @param {string} domain Domain on which to calculate plural form.\n * @param {number} n      Value for which plural form is to be calculated.\n *\n * @return {number} Plural form index.\n */\nTannin.prototype.getPluralForm = function( domain, n ) {\n\tvar getPluralForm = this.pluralForms[ domain ],\n\t\tconfig, plural, pf;\n\n\tif ( ! getPluralForm ) {\n\t\tconfig = this.data[ domain ][ '' ];\n\n\t\tpf = (\n\t\t\tconfig[ 'Plural-Forms' ] ||\n\t\t\tconfig[ 'plural-forms' ] ||\n\t\t\t// Ignore reason: As known, there's no way to document the empty\n\t\t\t// string property on a key to guarantee this as metadata.\n\t\t\t// @ts-ignore\n\t\t\tconfig.plural_forms\n\t\t);\n\n\t\tif ( typeof pf !== 'function' ) {\n\t\t\tplural = getPluralExpression(\n\t\t\t\tconfig[ 'Plural-Forms' ] ||\n\t\t\t\tconfig[ 'plural-forms' ] ||\n\t\t\t\t// Ignore reason: As known, there's no way to document the empty\n\t\t\t\t// string property on a key to guarantee this as metadata.\n\t\t\t\t// @ts-ignore\n\t\t\t\tconfig.plural_forms\n\t\t\t);\n\n\t\t\tpf = pluralForms( plural );\n\t\t}\n\n\t\tgetPluralForm = this.pluralForms[ domain ] = pf;\n\t}\n\n\treturn getPluralForm( n );\n};\n\n/**\n * Translate a string.\n *\n * @param {string}      domain   Translation domain.\n * @param {string|void} context  Context distinguishing terms of the same name.\n * @param {string}      singular Primary key for translation lookup.\n * @param {string=}     plural   Fallback value used for non-zero plural\n *                               form index.\n * @param {number=}     n        Value to use in calculating plural form.\n *\n * @return {string} Translated string.\n */\nTannin.prototype.dcnpgettext = function( domain, context, singular, plural, n ) {\n\tvar index, key, entry;\n\n\tif ( n === undefined ) {\n\t\t// Default to singular.\n\t\tindex = 0;\n\t} else {\n\t\t// Find index by evaluating plural form for value.\n\t\tindex = this.getPluralForm( domain, n );\n\t}\n\n\tkey = singular;\n\n\t// If provided, context is prepended to key with delimiter.\n\tif ( context ) {\n\t\tkey = context + this.options.contextDelimiter + singular;\n\t}\n\n\tentry = this.data[ domain ][ key ];\n\n\t// Verify not only that entry exists, but that the intended index is within\n\t// range and non-empty.\n\tif ( entry && entry[ index ] ) {\n\t\treturn entry[ index ];\n\t}\n\n\tif ( this.options.onMissingKey ) {\n\t\tthis.options.onMissingKey( singular, domain );\n\t}\n\n\t// If entry not found, fall back to singular vs. plural with zero index\n\t// representing the singular value.\n\treturn index === 0 ? singular : plural;\n};\n","import compile from '@tannin/compile';\n\n/**\n * Given a C expression, returns a function which, when called with a value,\n * evaluates the result with the value assumed to be the \"n\" variable of the\n * expression. The result will be coerced to its numeric equivalent.\n *\n * @param {string} expression C expression.\n *\n * @return {Function} Evaluator function.\n */\nexport default function pluralForms( expression ) {\n\tvar evaluate = compile( expression );\n\n\treturn function( n ) {\n\t\treturn +evaluate( { n: n } );\n\t};\n}\n","import postfix from '@tannin/postfix';\nimport evaluate from '@tannin/evaluate';\n\n/**\n * Given a C expression, returns a function which can be called to evaluate its\n * result.\n *\n * @example\n *\n * ```js\n * import compile from '@tannin/compile';\n *\n * const evaluate = compile( 'n > 1' );\n *\n * evaluate( { n: 2 } );\n * // ⇒ true\n * ```\n *\n * @param {string} expression C expression.\n *\n * @return {(variables?:{[variable:string]:*})=>*} Compiled evaluator.\n */\nexport default function compile( expression ) {\n\tvar terms = postfix( expression );\n\n\treturn function( variables ) {\n\t\treturn evaluate( terms, variables );\n\t};\n}\n","/**\n * External dependencies\n */\nimport type { TanninLocaleDomain } from 'tannin';\nimport Tannin from 'tannin';\n/**\n * Internal dependencies\n */\nimport type {\n\tgetFilterDomain,\n\tI18n,\n\tLocaleData,\n\tSubscribeCallback,\n\tTranslatableText,\n\tUnsubscribeCallback,\n} from './types';\n/**\n * WordPress dependencies\n */\nimport type { Hooks } from '@wordpress/hooks';\n/**\n * Default locale data to use for Tannin domain when not otherwise provided.\n * Assumes an English plural forms expression.\n */\nconst DEFAULT_LOCALE_DATA: LocaleData = {\n\t'': {\n\t\tplural_forms( n: number ) {\n\t\t\treturn n === 1 ? 0 : 1;\n\t\t},\n\t},\n};\n\n/*\n * Regular expression that matches i18n hooks like `i18n.gettext`, `i18n.ngettext`,\n * `i18n.gettext_domain` or `i18n.ngettext_with_context` or `i18n.has_translation`.\n */\nconst I18N_HOOK_REGEXP = /^i18n\\.(n?gettext|has_translation)(_|$)/;\n\n/**\n * Create an i18n instance\n *\n * @param [initialData]   Locale data configuration.\n * @param [initialDomain] Domain for which configuration applies.\n * @param [hooks]         Hooks implementation.\n *\n * @return I18n instance.\n */\nexport const createI18n = < TextDomain extends string >(\n\tinitialData?: LocaleData< TextDomain >,\n\tinitialDomain?: TextDomain,\n\thooks?: Hooks\n): I18n< TextDomain > => {\n\t/**\n\t * The underlying instance of Tannin to which exported functions interface.\n\t */\n\tconst tannin = new Tannin( {} );\n\n\tconst listeners = new Set< () => void >();\n\n\tconst notifyListeners = () => {\n\t\tlisteners.forEach( ( listener ) => listener() );\n\t};\n\n\t/**\n\t * Subscribe to changes of locale data.\n\t *\n\t * @param callback Subscription callback.\n\t * @return Unsubscribe callback.\n\t */\n\tconst subscribe = ( callback: SubscribeCallback ): UnsubscribeCallback => {\n\t\tlisteners.add( callback );\n\t\treturn () => listeners.delete( callback );\n\t};\n\n\tconst getLocaleData: I18n< TextDomain >[ 'getLocaleData' ] = (\n\t\tdomain = 'default' as TextDomain\n\t) => tannin.data[ domain ] as LocaleData< TextDomain >;\n\n\t/**\n\t * @param [data]\n\t * @param [domain]\n\t */\n\tconst doSetLocaleData = (\n\t\tdata?: LocaleData,\n\t\tdomain: TextDomain = 'default' as TextDomain\n\t) => {\n\t\ttannin.data[ domain ] = {\n\t\t\t...tannin.data[ domain ],\n\t\t\t...data,\n\t\t} as TanninLocaleDomain;\n\n\t\t// Populate default domain configuration (supported locale date which omits\n\t\t// a plural forms expression).\n\t\ttannin.data[ domain ][ '' ] = {\n\t\t\t...DEFAULT_LOCALE_DATA[ '' ],\n\t\t\t...tannin.data[ domain ]?.[ '' ],\n\t\t};\n\n\t\t// Clean up cached plural forms functions cache as it might be updated.\n\t\tdelete tannin.pluralForms[ domain ];\n\t};\n\n\tconst setLocaleData: I18n< TextDomain >[ 'setLocaleData' ] = (\n\t\tdata,\n\t\tdomain\n\t) => {\n\t\tdoSetLocaleData( data, domain );\n\t\tnotifyListeners();\n\t};\n\n\tconst addLocaleData: I18n< TextDomain >[ 'addLocaleData' ] = (\n\t\tdata,\n\t\tdomain = 'default' as TextDomain\n\t) => {\n\t\ttannin.data[ domain ] = {\n\t\t\t...tannin.data[ domain ],\n\t\t\t...data,\n\t\t\t// Populate default domain configuration (supported locale date which omits\n\t\t\t// a plural forms expression).\n\t\t\t'': {\n\t\t\t\t...DEFAULT_LOCALE_DATA[ '' ],\n\t\t\t\t...tannin.data[ domain ]?.[ '' ],\n\t\t\t\t...data?.[ '' ],\n\t\t\t},\n\t\t} as TanninLocaleDomain;\n\n\t\t// Clean up cached plural forms functions cache as it might be updated.\n\t\tdelete tannin.pluralForms[ domain ];\n\n\t\tnotifyListeners();\n\t};\n\n\tconst resetLocaleData: I18n< TextDomain >[ 'resetLocaleData' ] = (\n\t\tdata,\n\t\tdomain\n\t) => {\n\t\t// Reset all current Tannin locale data.\n\t\ttannin.data = {};\n\n\t\t// Reset cached plural forms functions cache.\n\t\ttannin.pluralForms = {};\n\n\t\tsetLocaleData( data, domain );\n\t};\n\n\t/**\n\t * Wrapper for Tannin's `dcnpgettext`. Populates default locale data if not\n\t * otherwise previously assigned.\n\t *\n\t * @param domain   Domain to retrieve the translated text.\n\t * @param context  Context information for the translators.\n\t * @param single   Text to translate if non-plural. Used as\n\t *                 fallback return value on a caught error.\n\t * @param [plural] The text to be used if the number is\n\t *                 plural.\n\t * @param [number] The number to compare against to use\n\t *                 either the singular or plural form.\n\t *\n\t * @return The translated string.\n\t */\n\tconst dcnpgettext = (\n\t\tdomain = 'default' as TextDomain,\n\t\tcontext: string | void,\n\t\tsingle: string,\n\t\tplural?: string,\n\t\tnumber?: number\n\t): string => {\n\t\tif ( ! tannin.data[ domain ] ) {\n\t\t\t// Use `doSetLocaleData` to set silently, without notifying listeners.\n\t\t\tdoSetLocaleData( undefined, domain );\n\t\t}\n\n\t\treturn tannin.dcnpgettext( domain, context, single, plural, number );\n\t};\n\n\tconst getFilterDomain: getFilterDomain = ( domain ) => domain || 'default';\n\n\tconst __: I18n< TextDomain >[ '__' ] = ( text, domain ) => {\n\t\tlet translation = dcnpgettext( domain, undefined, text );\n\t\tif ( ! hooks ) {\n\t\t\treturn translation as TranslatableText< typeof text >;\n\t\t}\n\n\t\t/**\n\t\t * Filters text with its translation.\n\t\t *\n\t\t * @param translation Translated text.\n\t\t * @param text        Text to translate.\n\t\t * @param domain      Text domain. Unique identifier for retrieving translated strings.\n\t\t */\n\t\ttranslation = hooks.applyFilters(\n\t\t\t'i18n.gettext',\n\t\t\ttranslation,\n\t\t\ttext,\n\t\t\tdomain\n\t\t) as TranslatableText< typeof text >;\n\n\t\treturn hooks.applyFilters(\n\t\t\t'i18n.gettext_' + getFilterDomain( domain ),\n\t\t\ttranslation,\n\t\t\ttext,\n\t\t\tdomain\n\t\t) as TranslatableText< typeof text >;\n\t};\n\n\tconst _x: I18n< TextDomain >[ '_x' ] = ( text, context, domain ) => {\n\t\tlet translation = dcnpgettext( domain, context, text );\n\t\tif ( ! hooks ) {\n\t\t\treturn translation as TranslatableText< typeof text >;\n\t\t}\n\n\t\t/**\n\t\t * Filters text with its translation based on context information.\n\t\t *\n\t\t * @param translation Translated text.\n\t\t * @param text        Text to translate.\n\t\t * @param context     Context information for the translators.\n\t\t * @param domain      Text domain. Unique identifier for retrieving translated strings.\n\t\t */\n\t\ttranslation = hooks.applyFilters(\n\t\t\t'i18n.gettext_with_context',\n\t\t\ttranslation,\n\t\t\ttext,\n\t\t\tcontext,\n\t\t\tdomain\n\t\t) as TranslatableText< typeof text >;\n\n\t\treturn hooks.applyFilters(\n\t\t\t'i18n.gettext_with_context_' + getFilterDomain( domain ),\n\t\t\ttranslation,\n\t\t\ttext,\n\t\t\tcontext,\n\t\t\tdomain\n\t\t) as TranslatableText< typeof text >;\n\t};\n\n\tconst _n: I18n< TextDomain >[ '_n' ] = (\n\t\tsingle,\n\t\tplural,\n\t\tnumber,\n\t\tdomain\n\t) => {\n\t\tlet translation = dcnpgettext(\n\t\t\tdomain,\n\t\t\tundefined,\n\t\t\tsingle,\n\t\t\tplural,\n\t\t\tnumber\n\t\t);\n\t\tif ( ! hooks ) {\n\t\t\treturn translation as TranslatableText<\n\t\t\t\ttypeof single | typeof plural\n\t\t\t>;\n\t\t}\n\n\t\t/**\n\t\t * Filters the singular or plural form of a string.\n\t\t *\n\t\t * @param translation Translated text.\n\t\t * @param single      The text to be used if the number is singular.\n\t\t * @param plural      The text to be used if the number is plural.\n\t\t * @param number      The number to compare against to use either the singular or plural form.\n\t\t * @param domain      Text domain. Unique identifier for retrieving translated strings.\n\t\t */\n\t\ttranslation = hooks.applyFilters(\n\t\t\t'i18n.ngettext',\n\t\t\ttranslation,\n\t\t\tsingle,\n\t\t\tplural,\n\t\t\tnumber,\n\t\t\tdomain\n\t\t) as TranslatableText< typeof single | typeof plural >;\n\n\t\treturn hooks.applyFilters(\n\t\t\t'i18n.ngettext_' + getFilterDomain( domain ),\n\t\t\ttranslation,\n\t\t\tsingle,\n\t\t\tplural,\n\t\t\tnumber,\n\t\t\tdomain\n\t\t) as TranslatableText< typeof single | typeof plural >;\n\t};\n\n\tconst _nx: I18n< TextDomain >[ '_nx' ] = (\n\t\tsingle,\n\t\tplural,\n\t\tnumber,\n\t\tcontext,\n\t\tdomain\n\t) => {\n\t\tlet translation = dcnpgettext(\n\t\t\tdomain,\n\t\t\tcontext,\n\t\t\tsingle,\n\t\t\tplural,\n\t\t\tnumber\n\t\t);\n\t\tif ( ! hooks ) {\n\t\t\treturn translation as TranslatableText<\n\t\t\t\ttypeof single | typeof plural\n\t\t\t>;\n\t\t}\n\n\t\t/**\n\t\t * Filters the singular or plural form of a string with gettext context.\n\t\t *\n\t\t * @param translation Translated text.\n\t\t * @param single      The text to be used if the number is singular.\n\t\t * @param plural      The text to be used if the number is plural.\n\t\t * @param number      The number to compare against to use either the singular or plural form.\n\t\t * @param context     Context information for the translators.\n\t\t * @param domain      Text domain. Unique identifier for retrieving translated strings.\n\t\t */\n\t\ttranslation = hooks.applyFilters(\n\t\t\t'i18n.ngettext_with_context',\n\t\t\ttranslation,\n\t\t\tsingle,\n\t\t\tplural,\n\t\t\tnumber,\n\t\t\tcontext,\n\t\t\tdomain\n\t\t) as TranslatableText< typeof single | typeof plural >;\n\n\t\treturn hooks.applyFilters(\n\t\t\t'i18n.ngettext_with_context_' + getFilterDomain( domain ),\n\t\t\ttranslation,\n\t\t\tsingle,\n\t\t\tplural,\n\t\t\tnumber,\n\t\t\tcontext,\n\t\t\tdomain\n\t\t) as TranslatableText< typeof single | typeof plural >;\n\t};\n\n\tconst isRTL: I18n< TextDomain >[ 'isRTL' ] = () => {\n\t\treturn 'rtl' === _x( 'ltr', 'text direction' );\n\t};\n\n\tconst hasTranslation: I18n< TextDomain >[ 'hasTranslation' ] = (\n\t\tsingle,\n\t\tcontext,\n\t\tdomain\n\t) => {\n\t\tconst key = context ? context + '\\u0004' + single : single;\n\t\tlet result = !! tannin.data?.[ domain ?? 'default' ]?.[ key ];\n\t\tif ( hooks ) {\n\t\t\t/**\n\t\t\t * Filters the presence of a translation in the locale data.\n\t\t\t *\n\t\t\t * @param hasTranslation Whether the translation is present or not..\n\t\t\t * @param single         The singular form of the translated text (used as key in locale data)\n\t\t\t * @param context        Context information for the translators.\n\t\t\t * @param domain         Text domain. Unique identifier for retrieving translated strings.\n\t\t\t */\n\t\t\tresult = hooks.applyFilters(\n\t\t\t\t'i18n.has_translation',\n\t\t\t\tresult,\n\t\t\t\tsingle,\n\t\t\t\tcontext,\n\t\t\t\tdomain\n\t\t\t) as boolean;\n\n\t\t\tresult = hooks.applyFilters(\n\t\t\t\t'i18n.has_translation_' + getFilterDomain( domain ),\n\t\t\t\tresult,\n\t\t\t\tsingle,\n\t\t\t\tcontext,\n\t\t\t\tdomain\n\t\t\t) as boolean;\n\t\t}\n\t\treturn result;\n\t};\n\n\tif ( initialData ) {\n\t\tsetLocaleData( initialData, initialDomain );\n\t}\n\n\tif ( hooks ) {\n\t\t/**\n\t\t * @param hookName\n\t\t */\n\t\tconst onHookAddedOrRemoved = ( hookName: string ) => {\n\t\t\tif ( I18N_HOOK_REGEXP.test( hookName ) ) {\n\t\t\t\tnotifyListeners();\n\t\t\t}\n\t\t};\n\n\t\thooks.addAction( 'hookAdded', 'core/i18n', onHookAddedOrRemoved );\n\t\thooks.addAction( 'hookRemoved', 'core/i18n', onHookAddedOrRemoved );\n\t}\n\n\treturn {\n\t\tgetLocaleData,\n\t\tsetLocaleData,\n\t\taddLocaleData,\n\t\tresetLocaleData,\n\t\tsubscribe,\n\t\t__,\n\t\t_x,\n\t\t_n,\n\t\t_nx,\n\t\tisRTL,\n\t\thasTranslation,\n\t};\n};\n","const __WEBPACK_NAMESPACE_OBJECT__ = window[\"wp\"][\"hooks\"];","/**\n * Internal dependencies\n */\nimport { createI18n } from './create-i18n';\n\n/**\n * WordPress dependencies\n */\nimport { defaultHooks } from '@wordpress/hooks';\nimport {\n\tLocaleData,\n\tSubscribeCallback,\n\tTranslatableText,\n\tUnsubscribeCallback,\n} from './types';\n\nconst i18n = createI18n( undefined, undefined, defaultHooks );\n\n/**\n * Default, singleton instance of `I18n`.\n */\nexport default i18n;\n\n/*\n * Comments in this file are duplicated from ./i18n due to\n * https://github.com/WordPress/gutenberg/pull/20318#issuecomment-590837722\n */\n\n/**\n * Returns locale data by domain in a Jed-formatted JSON object shape.\n *\n * @see http://messageformat.github.io/Jed/\n *\n * @param { string | undefined } [domain] Domain for which to get the data.\n * @return { LocaleData } Locale data.\n */\nexport const getLocaleData = i18n.getLocaleData.bind( i18n );\n\n/**\n * Merges locale data into the Tannin instance by domain. Accepts data in a\n * Jed-formatted JSON object shape.\n *\n * @see http://messageformat.github.io/Jed/\n *\n * @param {LocaleData }        [data]   Locale data configuration.\n * @param {string | undefined} [domain] Domain for which configuration applies.\n */\nexport const setLocaleData = i18n.setLocaleData.bind( i18n );\n\n/**\n * Resets all current Tannin instance locale data and sets the specified\n * locale data for the domain. Accepts data in a Jed-formatted JSON object shape.\n *\n * @see http://messageformat.github.io/Jed/\n *\n * @param {LocaleData}         [data]   Locale data configuration.\n * @param {string | undefined} [domain] Domain for which configuration applies.\n */\nexport const resetLocaleData = i18n.resetLocaleData.bind( i18n );\n\n/**\n * Subscribes to changes of locale data\n *\n * @param {SubscribeCallback} callback Subscription callback\n * @return {UnsubscribeCallback} Unsubscribe callback\n */\nexport const subscribe = i18n.subscribe.bind( i18n );\n\n/**\n * Retrieve the translation of text.\n *\n * @see https://developer.wordpress.org/reference/functions/__/\n *\n * @template {string} Text\n *\n * @param {Text}               text   Text to translate.\n * @param {string | undefined} domain Domain to retrieve the translated text.\n *\n * @return {TranslatableText<Text>} Translated text.\n */\nexport const __ = i18n.__.bind( i18n );\n\n/**\n * Retrieve translated string with gettext context.\n *\n * @see https://developer.wordpress.org/reference/functions/_x/\n *\n * @template {string} Text\n *\n * @param {Text}               text    Text to translate.\n * @param {string}             context Context information for the translators.\n * @param {string | undefined} domain  Domain to retrieve the translated text.\n *\n * @return {TranslatableText<Text>} Translated context string without pipe.\n */\nexport const _x = i18n._x.bind( i18n );\n\n/**\n * Translates and retrieves the singular or plural form based on the supplied\n * number.\n *\n * @see https://developer.wordpress.org/reference/functions/_n/\n *\n * @template {string} Single\n * @template {string} Plural\n *\n * @param {Single}             single The text to be used if the number is singular.\n * @param {Plural}             plural The text to be used if the number is plural.\n * @param {number}             number The number to compare against to use either the\n *                                    singular or plural form.\n * @param {string | undefined} domain Domain to retrieve the translated text.\n *\n * @return {TranslatableText<Single | Plural>} The translated singular or plural form.\n */\nexport const _n = i18n._n.bind( i18n );\n\n/**\n * Translates and retrieves the singular or plural form based on the supplied\n * number, with gettext context.\n *\n * @see https://developer.wordpress.org/reference/functions/_nx/\n *\n * @template {string} Single\n * @template {string} Plural\n * @param {Single}             single   The text to be used if the number is singular.\n *\n * @param {Single}             single   The text to be used if the number is singular.\n * @param {Plural}             plural   The text to be used if the number is plural.\n * @param {number}             number   The number to compare against to use either the\n *                                      singular or plural form.\n * @param {string}             context  Context information for the translators.\n * @param {string | undefined} [domain] Domain to retrieve the translated text.\n *\n * @return {TranslatableText<Single | Plural>} The translated singular or plural form.\n */\nexport const _nx = i18n._nx.bind( i18n );\n\n/**\n * Check if current locale is RTL.\n *\n * **RTL (Right To Left)** is a locale property indicating that text is written from right to left.\n * For example, the `he` locale (for Hebrew) specifies right-to-left. Arabic (ar) is another common\n * language written RTL. The opposite of RTL, LTR (Left To Right) is used in other languages,\n * including English (`en`, `en-US`, `en-GB`, etc.), Spanish (`es`), and French (`fr`).\n *\n * @return {boolean} Whether locale is RTL.\n */\nexport const isRTL = i18n.isRTL.bind( i18n );\n\n/**\n * Check if there is a translation for a given string (in singular form).\n *\n * @param {string} single  Singular form of the string to look up.\n * @param {string} context Context information for the translators.\n * @param {string} domain  Domain to retrieve the translated text.\n *\n * @return {boolean} Whether the translation exists or not.\n */\nexport const hasTranslation = i18n.hasTranslation.bind( i18n );\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","PRECEDENCE","OPENERS","TERMINATORS","PATTERN","sprintf","format","args","string","i","Array","isArray","replace","index","name","precision","type","arguments","undefined","parseFloat","parseInt","toFixed","substr","_sprintf","OPERATORS","a","b","c","DEFAULT_OPTIONS","contextDelimiter","onMissingKey","Tannin","data","options","this","pluralForms","getPluralForm","domain","n","config","plural","pf","evaluate","plural_forms","parts","part","split","length","trim","indexOf","getPluralExpression","expression","terms","match","operator","term","element","stack","push","pop","concat","reverse","postfix","variables","j","getOperatorResult","apply","earlyReturn","compile","dcnpgettext","context","singular","entry","DEFAULT_LOCALE_DATA","I18N_HOOK_REGEXP","createI18n","initialData","initialDomain","hooks","tannin","listeners","Set","notifyListeners","forEach","listener","doSetLocaleData","setLocaleData","single","number","getFilterDomain","_x","text","translation","applyFilters","onHookAddedOrRemoved","hookName","test","addAction","getLocaleData","addLocaleData","resetLocaleData","subscribe","callback","add","delete","__","_n","_nx","isRTL","hasTranslation","result","window","i18n","defaultHooks","bind"],"sourceRoot":""}