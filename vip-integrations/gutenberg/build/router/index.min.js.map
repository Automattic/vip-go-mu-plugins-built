{"version":3,"file":"./build/router/index.min.js","mappings":"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","sources":["webpack://wp/webpack/bootstrap","webpack://wp/webpack/runtime/define property getters","webpack://wp/webpack/runtime/hasOwnProperty shorthand","webpack://wp/webpack/runtime/make namespace object","webpack://wp/./node_modules/route-recognizer/dist/route-recognizer/util.ts","webpack://wp/./node_modules/route-recognizer/dist/route-recognizer/dsl.ts","webpack://wp/./node_modules/route-recognizer/dist/route-recognizer/normalizer.ts","webpack://wp/./node_modules/route-recognizer/dist/route-recognizer.ts","webpack://wp/./node_modules/@babel/runtime/helpers/esm/extends.js","webpack://wp/external window [\"wp\",\"element\"]","webpack://wp/external window [\"wp\",\"url\"]","webpack://wp/external window [\"wp\",\"compose\"]","webpack://wp/external window \"ReactJSXRuntime\"","../../packages/router/src/router.tsx","../../packages/router/src/link.tsx","webpack://wp/external window [\"wp\",\"privateApis\"]","../../packages/router/src/lock-unlock.ts","../../packages/router/src/private-apis.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","const createObject = Object.create;\nexport function createMap<T>() {\n  const map: { [key: string]: T | undefined } = createObject(null);\n  map[\"__\"] = undefined;\n  delete map[\"__\"];\n  return map;\n}\n","import { createMap } from \"./util\";\n\nexport interface Delegate {\n  contextEntered?(context: string, route: MatchDSL): void;\n  willAddRoute?(context: string | undefined, route: string): string;\n}\n\nexport type Opaque = {} | void | null | undefined;\n\nexport interface Route {\n  path: string;\n  handler: Opaque;\n  queryParams?: string[];\n}\n\nexport interface RouteRecognizer {\n  delegate: Delegate | undefined;\n  add(routes: Route[]): void;\n}\n\nexport interface MatchCallback {\n  (match: MatchDSL): void;\n}\n\nexport interface MatchDSL {\n  (path: string): ToDSL;\n  (path: string, callback: MatchCallback): void;\n}\n\nexport interface ToDSL {\n  to(name: string, callback?: MatchCallback): void;\n}\n\nclass Target implements ToDSL {\n  path: string;\n  matcher: Matcher;\n  delegate: Delegate | undefined;\n\n  constructor(path: string, matcher: Matcher, delegate: Delegate | undefined) {\n    this.path = path;\n    this.matcher = matcher;\n    this.delegate = delegate;\n  }\n\n  to(target: string, callback: MatchCallback) {\n    let delegate = this.delegate;\n\n    if (delegate && delegate.willAddRoute) {\n      target = delegate.willAddRoute(this.matcher.target, target);\n    }\n\n    this.matcher.add(this.path, target);\n\n    if (callback) {\n      if (callback.length === 0) { throw new Error(\"You must have an argument in the function passed to `to`\"); }\n      this.matcher.addChild(this.path, target, callback, this.delegate);\n    }\n  }\n}\n\nexport class Matcher {\n  routes: {\n    [path: string]: string | undefined;\n  };\n  children: {\n    [path: string]: Matcher | undefined;\n  };\n  target: string | undefined;\n\n  constructor(target?: string) {\n    this.routes = createMap<string>();\n    this.children = createMap<Matcher>();\n    this.target = target;\n  }\n\n  add(path: string, target: string) {\n    this.routes[path] = target;\n  }\n\n  addChild(path: string, target: string, callback: MatchCallback, delegate: Delegate | undefined) {\n    let matcher = new Matcher(target);\n    this.children[path] = matcher;\n\n    let match = generateMatch(path, matcher, delegate);\n\n    if (delegate && delegate.contextEntered) {\n      delegate.contextEntered(target, match);\n    }\n\n    callback(match);\n  }\n}\n\nfunction generateMatch(startingPath: string, matcher: Matcher, delegate: Delegate | undefined): MatchDSL {\n  function match(path: string): ToDSL;\n  function match(path: string, callback: MatchCallback): void;\n  function match(path: string, callback?: MatchCallback): ToDSL | void {\n    let fullPath = startingPath + path;\n    if (callback) {\n      callback(generateMatch(fullPath, matcher, delegate));\n    } else {\n      return new Target(fullPath, matcher, delegate);\n    }\n  };\n  return match;\n}\n\nfunction addRoute(routeArray: Route[], path: string, handler: any) {\n  let len = 0;\n  for (let i = 0; i < routeArray.length; i++) {\n    len += routeArray[i].path.length;\n  }\n\n  path = path.substr(len);\n  let route = { path: path, handler: handler };\n  routeArray.push(route);\n}\n\nfunction eachRoute<T>(baseRoute: Route[], matcher: Matcher, callback: (this: T, routes: Route[]) => void, binding: T) {\n  let routes = matcher.routes;\n  let paths = Object.keys(routes);\n  for (let i = 0; i < paths.length; i++) {\n    let path = paths[i];\n    let routeArray = baseRoute.slice();\n    addRoute(routeArray, path, routes[path]);\n    let nested = matcher.children[path];\n    if (nested) {\n      eachRoute(routeArray, nested, callback, binding);\n    } else {\n      callback.call(binding, routeArray);\n    }\n  }\n}\n\nexport default function <T extends RouteRecognizer>(this: T, callback: MatchCallback, addRouteCallback?: (routeRecognizer: T, routes: Route[]) => void) {\n  let matcher = new Matcher();\n\n  callback(generateMatch(\"\", matcher, this.delegate));\n\n  eachRoute([], matcher, function(routes: Route[]) {\n    if (addRouteCallback) { addRouteCallback(this, routes); }\n    else { this.add(routes); }\n  }, this);\n}\n","// Normalizes percent-encoded values in `path` to upper-case and decodes percent-encoded\n// values that are not reserved (i.e., unicode characters, emoji, etc). The reserved\n// chars are \"/\" and \"%\".\n// Safe to call multiple times on the same path.\nexport function normalizePath(path: string): string {\n  return path.split(\"/\")\n             .map(normalizeSegment)\n             .join(\"/\");\n}\n\n// We want to ensure the characters \"%\" and \"/\" remain in percent-encoded\n// form when normalizing paths, so replace them with their encoded form after\n// decoding the rest of the path\nconst SEGMENT_RESERVED_CHARS = /%|\\//g;\nexport function normalizeSegment(segment: string) {\n  if (segment.length < 3 || segment.indexOf(\"%\") === -1) return segment;\n  return decodeURIComponent(segment).replace(SEGMENT_RESERVED_CHARS, encodeURIComponent);\n}\n\n// We do not want to encode these characters when generating dynamic path segments\n// See https://tools.ietf.org/html/rfc3986#section-3.3\n// sub-delims: \"!\", \"$\", \"&\", \"'\", \"(\", \")\", \"*\", \"+\", \",\", \";\", \"=\"\n// others allowed by RFC 3986: \":\", \"@\"\n//\n// First encode the entire path segment, then decode any of the encoded special chars.\n//\n// The chars \"!\", \"'\", \"(\", \")\", \"*\" do not get changed by `encodeURIComponent`,\n// so the possible encoded chars are:\n// ['%24', '%26', '%2B', '%2C', '%3B', '%3D', '%3A', '%40'].\nconst PATH_SEGMENT_ENCODINGS = /%(?:2(?:4|6|B|C)|3(?:B|D|A)|40)/g;\n\nexport function encodePathSegment(str: string) {\n  return encodeURIComponent(str).replace(PATH_SEGMENT_ENCODINGS, decodeURIComponent);\n}\n","import { createMap } from \"./route-recognizer/util\";\nimport map, { Delegate, Route, Opaque, MatchCallback } from \"./route-recognizer/dsl\";\nimport { normalizePath, normalizeSegment, encodePathSegment } from \"./route-recognizer/normalizer\";\nexport { Delegate, MatchCallback } from './route-recognizer/dsl';\n\nconst enum CHARS {\n  ANY = -1,\n  STAR = 42,\n  SLASH = 47,\n  COLON = 58\n}\n\nconst escapeRegex = /(\\/|\\.|\\*|\\+|\\?|\\||\\(|\\)|\\[|\\]|\\{|\\}|\\\\)/g;\n\nconst isArray = Array.isArray;\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction getParam(params: Params | null | undefined, key: string): string {\n  if (typeof params !== \"object\" || params === null) {\n    throw new Error(\"You must pass an object as the second argument to `generate`.\");\n  }\n\n  if (!hasOwnProperty.call(params, key)) {\n    throw new Error(\"You must provide param `\" + key + \"` to `generate`.\");\n  }\n\n  let value = params[key];\n  let str = typeof value === \"string\" ? value : \"\" + value;\n  if (str.length === 0) {\n    throw new Error(\"You must provide a param `\" + key + \"`.\");\n  }\n  return str;\n}\n\nconst enum SegmentType {\n  Static  = 0,\n  Dynamic = 1,\n  Star    = 2,\n  Epsilon = 4\n}\n\nconst enum SegmentFlags {\n  Static  = 2 << SegmentType.Static,\n  Dynamic = 2 << SegmentType.Dynamic,\n  Star    = 2 << SegmentType.Star,\n  Epsilon = 2 << SegmentType.Epsilon,\n  Named = Dynamic | Star,\n  Decoded = Dynamic,\n  Counted = Static | Dynamic | Star\n}\n\nconst eachChar: ((segment: Segment, currentState: State) => State)[] = [];\neachChar[SegmentType.Static] = function (segment: Segment, currentState: State) {\n  let state = currentState;\n  let value = segment.value;\n  for (let i = 0; i < value.length; i++) {\n    let ch = value.charCodeAt(i);\n    state = state.put(ch, false, false);\n  }\n  return state;\n};\neachChar[SegmentType.Dynamic] = function (_: Segment, currentState: State) {\n  return currentState.put(CHARS.SLASH, true, true);\n};\neachChar[SegmentType.Star] = function (_: Segment, currentState: State) {\n  return currentState.put(CHARS.ANY, false, true);\n};\neachChar[SegmentType.Epsilon] = function (_: Segment, currentState: State) {\n  return currentState;\n};\n\nconst regex: ((segment: Segment) => string)[] = [];\nregex[SegmentType.Static] = function (segment: Segment) {\n  return segment.value.replace(escapeRegex, \"\\\\$1\");\n};\nregex[SegmentType.Dynamic] = function () {\n  return \"([^/]+)\";\n};\nregex[SegmentType.Star] = function () {\n  return \"(.+)\";\n};\nregex[SegmentType.Epsilon] = function () {\n  return \"\";\n};\n\nconst generate: ((segment: Segment, params?: Params | null) => string)[] = [];\ngenerate[SegmentType.Static] = function (segment: Segment) {\n  return segment.value;\n};\ngenerate[SegmentType.Dynamic] = function (segment: Segment, params?: Params) {\n  let value = getParam(params, segment.value);\n  if (RouteRecognizer.ENCODE_AND_DECODE_PATH_SEGMENTS) {\n    return encodePathSegment(value);\n  } else {\n    return value;\n  }\n};\ngenerate[SegmentType.Star] = function (segment: Segment, params?: Params) {\n  return getParam(params, segment.value);\n};\ngenerate[SegmentType.Epsilon] = function () {\n  return \"\";\n};\n\n// A Segment represents a segment in the original route description.\n// Each Segment type provides an `eachChar` and `regex` method.\n//\n// The `eachChar` method invokes the callback with one or more character\n// specifications. A character specification consumes one or more input\n// characters.\n//\n// The `regex` method returns a regex fragment for the segment. If the\n// segment is a dynamic of star segment, the regex fragment also includes\n// a capture.\n//\n// A character specification contains:\n//\n// * `validChars`: a String with a list of all valid characters, or\n// * `invalidChars`: a String with a list of all invalid characters\n// * `repeat`: true if the character specification can repeat\ninterface Segment {\n  type: SegmentType;\n  value: string;\n}\n\nexport interface Params {\n  [key: string]: Opaque;\n  [key: number]: Opaque;\n  queryParams?: QueryParams | null;\n}\n\ninterface PopulatedParsedHandlers {\n  names: string[];\n  shouldDecodes: any[];\n}\n\nconst EmptyObject = Object.freeze({});\ntype EmptyObject = Readonly<{}>\n\nconst EmptyArray = Object.freeze([]) as ReadonlyArray<any>;\ntype EmptyArray = ReadonlyArray<any>;\n\ninterface EmptyParsedHandlers {\n  names: EmptyArray;\n  shouldDecodes: EmptyArray;\n}\n\ntype ParsedHandler = PopulatedParsedHandlers | EmptyParsedHandlers;\n\n// The `names` will be populated with the paramter name for each dynamic/star\n// segment. `shouldDecodes` will be populated with a boolean for each dyanamic/star\n// segment, indicating whether it should be decoded during recognition.\nfunction parse(segments: Segment[], route: string, types: [number, number, number]) {\n  // normalize route as not starting with a \"/\". Recognition will\n  // also normalize.\n  if (route.length > 0 && route.charCodeAt(0) === CHARS.SLASH) { route = route.substr(1); }\n\n  let parts = route.split(\"/\");\n  let names: void | string[] = undefined;\n  let shouldDecodes: void | any[] = undefined;\n\n  for (let i = 0; i < parts.length; i++) {\n    let part = parts[i];\n    let flags: SegmentFlags = 0;\n    let type: SegmentType = 0;\n\n    if (part === \"\") {\n      type = SegmentType.Epsilon;\n    } else if (part.charCodeAt(0) === CHARS.COLON) {\n      type = SegmentType.Dynamic;\n    } else if (part.charCodeAt(0) === CHARS.STAR) {\n      type = SegmentType.Star;\n    }  else {\n      type = SegmentType.Static;\n    }\n\n    flags = 2 << type;\n\n    if (flags & SegmentFlags.Named) {\n      part = part.slice(1);\n      names = names || [];\n      names.push(part);\n\n      shouldDecodes = shouldDecodes || [];\n      shouldDecodes.push((flags & SegmentFlags.Decoded) !== 0);\n    }\n\n    if (flags & SegmentFlags.Counted) {\n      types[type]++;\n    }\n\n    segments.push({\n      type,\n      value: normalizeSegment(part)\n    });\n  }\n\n  return {\n    names: names || EmptyArray,\n    shouldDecodes: shouldDecodes || EmptyArray,\n  } as ParsedHandler;\n}\n\nfunction isEqualCharSpec(spec: CharSpec, char: number, negate: boolean) {\n  return spec.char === char && spec.negate === negate;\n}\n\ninterface EmptyHandler {\n  handler: Opaque;\n  names: EmptyArray;\n  shouldDecodes: EmptyArray;\n}\n\ninterface PopulatedHandler {\n  handler: Opaque;\n  names: string [];\n  shouldDecodes: boolean[];\n}\n\ntype Handler = EmptyHandler | PopulatedHandler;\n\n// A State has a character specification and (`charSpec`) and a list of possible\n// subsequent states (`nextStates`).\n//\n// If a State is an accepting state, it will also have several additional\n// properties:\n//\n// * `regex`: A regular expression that is used to extract parameters from paths\n//   that reached this accepting state.\n// * `handlers`: Information on how to convert the list of captures into calls\n//   to registered handlers with the specified parameters\n// * `types`: How many static, dynamic or star segments in this route. Used to\n//   decide which route to use if multiple registered routes match a path.\n//\n// Currently, State is implemented naively by looping over `nextStates` and\n// comparing a character specification against a character. A more efficient\n// implementation would use a hash of keys pointing at one or more next states.\nclass State implements CharSpec {\n  states: State[];\n  id: number;\n  negate: boolean;\n  char: number;\n  nextStates: number[] | number | null;\n  pattern: string;\n  _regex: RegExp | undefined;\n  handlers: Handler[] | undefined;\n  types: [number, number, number] | undefined;\n\n  constructor(states: State[], id: number, char: number, negate: boolean, repeat: boolean) {\n    this.states = states;\n    this.id = id;\n    this.char = char;\n    this.negate = negate;\n    this.nextStates = repeat ? id : null;\n    this.pattern = \"\";\n    this._regex = undefined;\n    this.handlers = undefined;\n    this.types = undefined;\n  }\n\n  regex(): RegExp {\n    if (!this._regex) {\n      this._regex = new RegExp(this.pattern);\n    }\n    return this._regex;\n  }\n\n  get(char: number, negate: boolean): State | void {\n    let nextStates = this.nextStates;\n    if (nextStates === null) return;\n    if (isArray(nextStates)) {\n      for (let i = 0; i < nextStates.length; i++) {\n        let child = this.states[nextStates[i]];\n        if (isEqualCharSpec(child, char, negate)) {\n          return child;\n        }\n      }\n    } else {\n      let child = this.states[nextStates];\n      if (isEqualCharSpec(child, char, negate)) {\n        return child;\n      }\n    }\n  }\n\n  put(char: number, negate: boolean, repeat: boolean) {\n    let state: State | void;\n\n    // If the character specification already exists in a child of the current\n    // state, just return that state.\n    if (state = this.get(char, negate)) { return state; }\n\n    // Make a new state for the character spec\n    let states = this.states;\n    state = new State(states, states.length, char, negate, repeat);\n    states[states.length] = state;\n\n    // Insert the new state as a child of the current state\n    if (this.nextStates == null) {\n      this.nextStates = state.id;\n    } else if (isArray(this.nextStates)) {\n      this.nextStates.push(state.id);\n    } else {\n      this.nextStates = [this.nextStates, state.id];\n    }\n\n    // Return the new state\n    return state;\n  }\n\n  // Find a list of child states matching the next character\n  match(ch: number): State[] {\n    let nextStates = this.nextStates;\n    if (!nextStates) return [];\n\n    let returned: State[] = [];\n    if (isArray(nextStates)) {\n      for (let i = 0; i < nextStates.length; i++) {\n        let child = this.states[nextStates[i]];\n\n        if (isMatch(child, ch)) {\n          returned.push(child);\n        }\n      }\n    } else {\n      let child = this.states[nextStates];\n      if (isMatch(child, ch)) {\n        returned.push(child);\n      }\n    }\n    return returned;\n  }\n}\n\nfunction isMatch(spec: CharSpec, char: number) {\n  return spec.negate ? spec.char !== char && spec.char !== CHARS.ANY : spec.char === char || spec.char === CHARS.ANY;\n}\n\n// This is a somewhat naive strategy, but should work in a lot of cases\n// A better strategy would properly resolve /posts/:id/new and /posts/edit/:id.\n//\n// This strategy generally prefers more static and less dynamic matching.\n// Specifically, it\n//\n//  * prefers fewer stars to more, then\n//  * prefers using stars for less of the match to more, then\n//  * prefers fewer dynamic segments to more, then\n//  * prefers more static segments to more\nfunction sortSolutions(states: State[]) {\n  return states.sort(function(a, b) {\n    let [ astatics, adynamics, astars ] = a.types || [0, 0, 0];\n    let [ bstatics, bdynamics, bstars ] = b.types || [0, 0, 0];\n    if (astars !== bstars) { return astars - bstars; }\n\n    if (astars) {\n      if (astatics !== bstatics) { return bstatics - astatics; }\n      if (adynamics !== bdynamics) { return bdynamics - adynamics; }\n    }\n\n    if (adynamics !== bdynamics) { return adynamics - bdynamics; }\n    if (astatics !== bstatics) { return bstatics - astatics; }\n\n    return 0;\n  });\n}\n\nfunction recognizeChar(states: State[], ch: number) {\n  let nextStates: State[] = [];\n\n  for (let i = 0, l = states.length; i < l; i++) {\n    let state = states[i];\n\n    nextStates = nextStates.concat(state.match(ch));\n  }\n\n  return nextStates;\n}\n\n\nexport interface QueryParams {\n  [param: string]: any[] | any | null | undefined;\n}\n\nexport interface Result {\n  handler: Opaque;\n  params: Params;\n  isDynamic: boolean;\n}\n\nexport interface Results extends ArrayLike<Result | undefined> {\n  queryParams: QueryParams;\n  slice(start?: number, end?: number): Result[];\n  splice(start: number, deleteCount: number, ...items: Result[]): Result[];\n  push(...results: Result[]): number;\n}\n\nclass RecognizeResults implements Results {\n  queryParams: QueryParams;\n  length = 0;\n  [index: number]: Result | undefined;\n  splice: (start: number, deleteCount: number, ...items: Result[]) => Result[];\n  slice: (start?: number, end?: number) => Result[];\n  push: (...results: Result[]) => number;\n\n  constructor(queryParams?: QueryParams) {\n    this.queryParams = queryParams || {};\n  }\n};\n\nRecognizeResults.prototype.splice = Array.prototype.splice;\nRecognizeResults.prototype.slice =  Array.prototype.slice;\nRecognizeResults.prototype.push = Array.prototype.push;\n\nfunction findHandler(state: State, originalPath: string, queryParams: QueryParams): Results {\n  let handlers = state.handlers;\n  let regex: RegExp = state.regex();\n  if (!regex || !handlers) throw new Error(\"state not initialized\");\n  let captures: RegExpMatchArray | null = originalPath.match(regex);\n  let currentCapture = 1;\n  let result = new RecognizeResults(queryParams);\n\n  result.length = handlers.length;\n\n  for (let i = 0; i < handlers.length; i++) {\n    let handler = handlers[i];\n    let names = handler.names;\n    let shouldDecodes = handler.shouldDecodes;\n    let params: EmptyObject | Params = EmptyObject;\n\n    let isDynamic = false;\n\n    if (names !== EmptyArray && shouldDecodes !== EmptyArray) {\n      for (let j = 0; j < names.length; j++) {\n        isDynamic = true;\n        let name = names[j];\n        let capture = captures && captures[currentCapture++];\n\n        if (params === EmptyObject) {\n          params = {};\n        }\n\n        if (RouteRecognizer.ENCODE_AND_DECODE_PATH_SEGMENTS && shouldDecodes[j]) {\n          (<Params>params)[name] = capture && decodeURIComponent(capture);\n        } else {\n          (<Params>params)[name] = capture;\n        }\n      }\n    }\n\n    result[i] = {\n      handler: handler.handler,\n      params,\n      isDynamic\n    };\n  }\n\n  return result;\n}\n\nfunction decodeQueryParamPart(part: string): string {\n  // http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4.1\n  part = part.replace(/\\+/gm, \"%20\");\n  let result;\n  try {\n    result = decodeURIComponent(part);\n  } catch (error) {result = \"\"; }\n  return result;\n}\n\ninterface NamedRoute {\n  segments: Segment[];\n  handlers: Handler[];\n}\n\nclass RouteRecognizer {\n  private states: State[];\n  private rootState: State;\n  private names: {\n    [name: string]: NamedRoute | undefined;\n  } = createMap<NamedRoute>();\n  map: (context: MatchCallback, addCallback?: (router: this, routes: Route[]) => void) => void;\n  delegate: Delegate | undefined;\n\n  constructor() {\n    let states: State[] = [];\n    let state = new State(states, 0, CHARS.ANY, true, false);\n    states[0] = state;\n    this.states = states;\n    this.rootState = state;\n  }\n\n  static VERSION = \"0.3.4\";\n  // Set to false to opt-out of encoding and decoding path segments.\n  // See https://github.com/tildeio/route-recognizer/pull/55\n  static ENCODE_AND_DECODE_PATH_SEGMENTS = true;\n  static Normalizer = {\n    normalizeSegment, normalizePath, encodePathSegment\n  };\n\n  add(routes: Route[], options?: { as: string }) {\n    let currentState = this.rootState;\n    let pattern = \"^\";\n    let types: [number, number, number] = [0, 0, 0];\n    let handlers: Handler[] = new Array(routes.length);\n    let allSegments: Segment[] = [];\n\n    let isEmpty = true;\n    let j = 0;\n    for (let i = 0; i < routes.length; i++) {\n      let route = routes[i];\n      let { names, shouldDecodes } = parse(allSegments, route.path, types);\n\n      // preserve j so it points to the start of newly added segments\n      for (; j < allSegments.length; j++) {\n        let segment = allSegments[j];\n\n        if (segment.type === SegmentType.Epsilon) { continue; }\n\n        isEmpty = false;\n\n        // Add a \"/\" for the new segment\n        currentState = currentState.put(CHARS.SLASH, false, false);\n        pattern += \"/\";\n\n        // Add a representation of the segment to the NFA and regex\n        currentState = eachChar[segment.type](segment, currentState);\n        pattern += regex[segment.type](segment);\n      }\n      handlers[i] = {\n        handler: route.handler,\n        names,\n        shouldDecodes\n      };\n    }\n\n    if (isEmpty) {\n        currentState = currentState.put(CHARS.SLASH, false, false);\n      pattern += \"/\";\n    }\n\n    currentState.handlers = handlers;\n    currentState.pattern = pattern + \"$\";\n    currentState.types = types;\n\n    let name: string | undefined;\n    if (typeof options === \"object\" && options !== null && options.as) {\n      name = options.as;\n    }\n\n    if (name) {\n      // if (this.names[name]) {\n      //   throw new Error(\"You may not add a duplicate route named `\" + name + \"`.\");\n      // }\n\n      this.names[name] = {\n        segments: allSegments,\n        handlers\n      };\n    }\n  }\n\n  handlersFor(name: string) {\n    let route = this.names[name];\n\n    if (!route) { throw new Error(\"There is no route named \" + name); }\n\n    let result = new Array(route.handlers.length);\n\n    for (let i = 0; i < route.handlers.length; i++) {\n      let handler = route.handlers[i];\n      result[i] = handler;\n    }\n\n    return result;\n  }\n\n  hasRoute(name: string) {\n    return !!this.names[name];\n  }\n\n  generate(name: string, params?: Params | null) {\n    let route = this.names[name];\n    let output = \"\";\n    if (!route) { throw new Error(\"There is no route named \" + name); }\n\n    let segments: Segment[] = route.segments;\n\n    for (let i = 0; i < segments.length; i++) {\n      let segment: Segment = segments[i];\n\n      if (segment.type === SegmentType.Epsilon) {\n        continue;\n      }\n\n      output += \"/\";\n      output += generate[segment.type](segment, params);\n    }\n\n    if (output.charAt(0) !== \"/\") { output = \"/\" + output; }\n\n    if (params && params.queryParams) {\n      output += this.generateQueryString(params.queryParams);\n    }\n\n    return output;\n  }\n\n  generateQueryString(params: QueryParams) {\n    let pairs: string[] = [];\n    let keys: string[] = Object.keys(params);\n    keys.sort();\n    for (let i = 0; i < keys.length; i++) {\n      let key = keys[i];\n      let value = params[key];\n      if (value == null) {\n        continue;\n      }\n      let pair = encodeURIComponent(key);\n      if (isArray(value)) {\n        for (let j = 0; j < value.length; j++) {\n          let arrayPair = key + \"[]\" + \"=\" + encodeURIComponent(value[j]);\n          pairs.push(arrayPair);\n        }\n      } else {\n        pair += \"=\" + encodeURIComponent(value);\n        pairs.push(pair);\n      }\n    }\n\n    if (pairs.length === 0) { return \"\"; }\n\n    return \"?\" + pairs.join(\"&\");\n  }\n\n  parseQueryString(queryString: string): QueryParams {\n    let pairs = queryString.split(\"&\");\n    let queryParams: QueryParams = {};\n    for (let i = 0; i < pairs.length; i++) {\n      let pair      = pairs[i].split(\"=\"),\n          key       = decodeQueryParamPart(pair[0]),\n          keyLength = key.length,\n          isArray = false,\n          value;\n      if (pair.length === 1) {\n        value = \"true\";\n      } else {\n        // Handle arrays\n        if (keyLength > 2 && key.slice(keyLength - 2) === \"[]\") {\n          isArray = true;\n          key = key.slice(0, keyLength - 2);\n          if (!queryParams[key]) {\n            queryParams[key] = [];\n          }\n        }\n        value = pair[1] ? decodeQueryParamPart(pair[1]) : \"\";\n      }\n      if (isArray) {\n        (<string[]>queryParams[key]).push(value);\n      } else {\n        queryParams[key] = value;\n      }\n    }\n    return queryParams;\n  }\n\n  recognize(path: string): Results | undefined {\n    let results: Results | undefined;\n    let states: State[] = [ this.rootState ];\n    let queryParams = {};\n    let isSlashDropped = false;\n    let hashStart = path.indexOf(\"#\");\n    if (hashStart !== -1) {\n      path = path.substr(0, hashStart);\n    }\n\n    let queryStart = path.indexOf(\"?\");\n    if (queryStart !== -1) {\n      let queryString = path.substr(queryStart + 1, path.length);\n      path = path.substr(0, queryStart);\n      queryParams = this.parseQueryString(queryString);\n    }\n\n    if (path.charAt(0) !== \"/\") { path = \"/\" + path; }\n    let originalPath = path;\n\n    if (RouteRecognizer.ENCODE_AND_DECODE_PATH_SEGMENTS) {\n      path = normalizePath(path);\n    } else {\n      path = decodeURI(path);\n      originalPath = decodeURI(originalPath);\n    }\n\n    let pathLen = path.length;\n    if (pathLen > 1 && path.charAt(pathLen - 1) === \"/\") {\n      path = path.substr(0, pathLen - 1);\n      originalPath = originalPath.substr(0, originalPath.length - 1);\n      isSlashDropped = true;\n    }\n\n    for (let i = 0; i < path.length; i++) {\n      states = recognizeChar(states, path.charCodeAt(i));\n      if (!states.length) { break; }\n    }\n\n    let solutions: State[] = [];\n    for (let i = 0; i < states.length; i++) {\n      if (states[i].handlers) { solutions.push(states[i]); }\n    }\n\n    states = sortSolutions(solutions);\n\n    let state = solutions[0];\n\n    if (state && state.handlers) {\n      // if a trailing slash was dropped and a star segment is the last segment\n      // specified, put the trailing slash back\n      if (isSlashDropped && state.pattern && state.pattern.slice(-5) === \"(.+)$\") {\n        originalPath = originalPath + \"/\";\n      }\n      results = findHandler(state, originalPath, queryParams);\n    }\n\n    return results;\n  }\n}\n\nRouteRecognizer.prototype.map = map;\n\nexport default RouteRecognizer;\n\ninterface CharSpec {\n  negate: boolean;\n  char: number;\n}\n","function _extends() {\n  return _extends = Object.assign ? Object.assign.bind() : function (n) {\n    for (var e = 1; e < arguments.length; e++) {\n      var t = arguments[e];\n      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);\n    }\n    return n;\n  }, _extends.apply(null, arguments);\n}\nexport { _extends as default };","const __WEBPACK_NAMESPACE_OBJECT__ = window[\"wp\"][\"element\"];","const __WEBPACK_NAMESPACE_OBJECT__ = window[\"wp\"][\"url\"];","const __WEBPACK_NAMESPACE_OBJECT__ = window[\"wp\"][\"compose\"];","const __WEBPACK_NAMESPACE_OBJECT__ = window[\"ReactJSXRuntime\"];","/**\n * External dependencies\n */\nimport RouteRecognizer from 'route-recognizer';\nimport { createBrowserHistory } from 'history';\n\n/**\n * WordPress dependencies\n */\nimport {\n\tcreateContext,\n\tuseContext,\n\tuseSyncExternalStore,\n\tuseMemo,\n} from '@wordpress/element';\nimport {\n\taddQueryArgs,\n\tgetQueryArgs,\n\tgetPath,\n\tbuildQueryString,\n} from '@wordpress/url';\nimport { useEvent } from '@wordpress/compose';\n\n/**\n * Internal dependencies\n */\nimport type { ReactNode } from 'react';\n\nconst history = createBrowserHistory();\ninterface Route {\n\tname: string;\n\tpath: string;\n\tareas: Record< string, ReactNode >;\n\twidths: Record< string, number >;\n}\n\ntype LocationWithQuery = Location & {\n\tquery?: Record< string, any >;\n};\n\ninterface Match {\n\tname: string;\n\tpath: string;\n\tareas: Record< string, ReactNode >;\n\twidths: Record< string, number >;\n\tquery?: Record< string, any >;\n\tparams?: Record< string, any >;\n}\n\nexport type BeforeNavigate = ( arg: {\n\tpath: string;\n\tquery: Record< string, any >;\n} ) => {\n\tpath: string;\n\tquery: Record< string, any >;\n};\n\ninterface Config {\n\tpathArg: string;\n\tbeforeNavigate?: BeforeNavigate;\n}\n\nexport interface NavigationOptions {\n\ttransition?: string;\n\tstate?: Record< string, any >;\n}\n\nconst RoutesContext = createContext< Match | null >( null );\nexport const ConfigContext = createContext< Config >( { pathArg: 'p' } );\n\nconst locationMemo = new WeakMap();\nfunction getLocationWithQuery() {\n\tconst location = history.location;\n\tlet locationWithQuery = locationMemo.get( location );\n\tif ( ! locationWithQuery ) {\n\t\tlocationWithQuery = {\n\t\t\t...location,\n\t\t\tquery: Object.fromEntries( new URLSearchParams( location.search ) ),\n\t\t};\n\t\tlocationMemo.set( location, locationWithQuery );\n\t}\n\treturn locationWithQuery;\n}\n\nexport function useLocation() {\n\tconst context = useContext( RoutesContext );\n\tif ( ! context ) {\n\t\tthrow new Error( 'useLocation must be used within a RouterProvider' );\n\t}\n\treturn context;\n}\n\nexport function useHistory() {\n\tconst { pathArg, beforeNavigate } = useContext( ConfigContext );\n\n\tconst navigate = useEvent(\n\t\tasync ( rawPath: string, options: NavigationOptions = {} ) => {\n\t\t\tconst query = getQueryArgs( rawPath );\n\t\t\tconst path = getPath( 'http://domain.com/' + rawPath ) ?? '';\n\t\t\tconst performPush = () => {\n\t\t\t\tconst result = beforeNavigate\n\t\t\t\t\t? beforeNavigate( { path, query } )\n\t\t\t\t\t: { path, query };\n\t\t\t\treturn history.push(\n\t\t\t\t\t{\n\t\t\t\t\t\tsearch: buildQueryString( {\n\t\t\t\t\t\t\t[ pathArg ]: result.path,\n\t\t\t\t\t\t\t...result.query,\n\t\t\t\t\t\t} ),\n\t\t\t\t\t},\n\t\t\t\t\toptions.state\n\t\t\t\t);\n\t\t\t};\n\n\t\t\t/*\n\t\t\t * Skip transition in mobile, otherwise it crashes the browser.\n\t\t\t * See: https://github.com/WordPress/gutenberg/pull/63002.\n\t\t\t */\n\t\t\tconst isMediumOrBigger =\n\t\t\t\twindow.matchMedia( '(min-width: 782px)' ).matches;\n\t\t\tif (\n\t\t\t\t! isMediumOrBigger ||\n\t\t\t\t! document.startViewTransition ||\n\t\t\t\t! options.transition\n\t\t\t) {\n\t\t\t\tperformPush();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tawait new Promise< void >( ( resolve ) => {\n\t\t\t\tconst classname = options.transition ?? '';\n\t\t\t\tdocument.documentElement.classList.add( classname );\n\t\t\t\tconst transition = document.startViewTransition( () =>\n\t\t\t\t\tperformPush()\n\t\t\t\t);\n\t\t\t\ttransition.finished.finally( () => {\n\t\t\t\t\tdocument.documentElement.classList.remove( classname );\n\t\t\t\t\tresolve();\n\t\t\t\t} );\n\t\t\t} );\n\t\t}\n\t);\n\n\treturn useMemo(\n\t\t() => ( {\n\t\t\tnavigate,\n\t\t\tback: history.back,\n\t\t} ),\n\t\t[ navigate ]\n\t);\n}\n\nexport default function useMatch(\n\tlocation: LocationWithQuery,\n\tmatcher: RouteRecognizer,\n\tpathArg: string,\n\tmatchResolverArgs: Record< string, any >\n): Match {\n\tconst { query: rawQuery = {} } = location;\n\n\treturn useMemo( () => {\n\t\tconst { [ pathArg ]: path = '/', ...query } = rawQuery;\n\t\tconst result = matcher.recognize( path )?.[ 0 ];\n\t\tif ( ! result ) {\n\t\t\treturn {\n\t\t\t\tname: '404',\n\t\t\t\tpath: addQueryArgs( path, query ),\n\t\t\t\tareas: {},\n\t\t\t\twidths: {},\n\t\t\t\tquery,\n\t\t\t\tparams: {},\n\t\t\t};\n\t\t}\n\n\t\tconst matchedRoute = result.handler as Route;\n\t\tconst resolveFunctions = ( record: Record< string, any > = {} ) => {\n\t\t\treturn Object.fromEntries(\n\t\t\t\tObject.entries( record ).map( ( [ key, value ] ) => {\n\t\t\t\t\tif ( typeof value === 'function' ) {\n\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue( {\n\t\t\t\t\t\t\t\tquery,\n\t\t\t\t\t\t\t\tparams: result.params,\n\t\t\t\t\t\t\t\t...matchResolverArgs,\n\t\t\t\t\t\t\t} ),\n\t\t\t\t\t\t];\n\t\t\t\t\t}\n\t\t\t\t\treturn [ key, value ];\n\t\t\t\t} )\n\t\t\t);\n\t\t};\n\t\treturn {\n\t\t\tname: matchedRoute.name,\n\t\t\tareas: resolveFunctions( matchedRoute.areas ),\n\t\t\twidths: resolveFunctions( matchedRoute.widths ),\n\t\t\tparams: result.params,\n\t\t\tquery,\n\t\t\tpath: addQueryArgs( path, query ),\n\t\t};\n\t}, [ matcher, rawQuery, pathArg, matchResolverArgs ] );\n}\n\nexport function RouterProvider( {\n\troutes,\n\tpathArg,\n\tbeforeNavigate,\n\tchildren,\n\tmatchResolverArgs,\n}: {\n\troutes: Route[];\n\tpathArg: string;\n\tbeforeNavigate?: BeforeNavigate;\n\tchildren: React.ReactNode;\n\tmatchResolverArgs: Record< string, any >;\n} ) {\n\tconst location = useSyncExternalStore(\n\t\thistory.listen,\n\t\tgetLocationWithQuery,\n\t\tgetLocationWithQuery\n\t);\n\tconst matcher = useMemo( () => {\n\t\tconst ret = new RouteRecognizer();\n\t\troutes.forEach( ( route ) => {\n\t\t\tret.add( [ { path: route.path, handler: route } ], {\n\t\t\t\tas: route.name,\n\t\t\t} );\n\t\t} );\n\t\treturn ret;\n\t}, [ routes ] );\n\tconst match = useMatch( location, matcher, pathArg, matchResolverArgs );\n\tconst config = useMemo(\n\t\t() => ( { beforeNavigate, pathArg } ),\n\t\t[ beforeNavigate, pathArg ]\n\t);\n\n\treturn (\n\t\t<ConfigContext.Provider value={ config }>\n\t\t\t<RoutesContext.Provider value={ match }>\n\t\t\t\t{ children }\n\t\t\t</RoutesContext.Provider>\n\t\t</ConfigContext.Provider>\n\t);\n}\n","/**\n * WordPress dependencies\n */\nimport { useContext, useMemo } from '@wordpress/element';\nimport { getQueryArgs, getPath, buildQueryString } from '@wordpress/url';\n\n/**\n * Internal dependencies\n */\nimport { ConfigContext, type NavigationOptions, useHistory } from './router';\n\nexport function useLink( to: string, options: NavigationOptions = {} ) {\n\tconst history = useHistory();\n\tconst { pathArg, beforeNavigate } = useContext( ConfigContext );\n\tfunction onClick( event: React.SyntheticEvent< HTMLAnchorElement > ) {\n\t\tevent?.preventDefault();\n\t\thistory.navigate( to, options );\n\t}\n\tconst query = getQueryArgs( to );\n\tconst path = getPath( 'http://domain.com/' + to ) ?? '';\n\tconst link = useMemo( () => {\n\t\treturn beforeNavigate\n\t\t\t? beforeNavigate( { path, query } )\n\t\t\t: { path, query };\n\t}, [ path, query, beforeNavigate ] );\n\n\tconst [ before ] = window.location.href.split( '?' );\n\n\treturn {\n\t\thref: `${ before }?${ buildQueryString( {\n\t\t\t[ pathArg ]: link.path,\n\t\t\t...link.query,\n\t\t} ) }`,\n\t\tonClick,\n\t};\n}\n\nexport function Link( {\n\tto,\n\toptions,\n\tchildren,\n\t...props\n}: {\n\tto: string;\n\toptions?: NavigationOptions;\n\tchildren: React.ReactNode;\n} ) {\n\tconst { href, onClick } = useLink( to, options );\n\n\treturn (\n\t\t<a href={ href } onClick={ onClick } { ...props }>\n\t\t\t{ children }\n\t\t</a>\n\t);\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = window[\"wp\"][\"privateApis\"];","/**\n * WordPress dependencies\n */\nimport { __dangerousOptInToUnstableAPIsOnlyForCoreModules } from '@wordpress/private-apis';\n\nexport const { lock, unlock } =\n\t__dangerousOptInToUnstableAPIsOnlyForCoreModules(\n\t\t'I acknowledge private features are not for use in themes or plugins and doing so will break in the next version of WordPress.',\n\t\t'@wordpress/router'\n\t);\n","/**\n * Internal dependencies\n */\nimport { useHistory, useLocation, RouterProvider } from './router';\nimport { useLink, Link } from './link';\nimport { lock } from './lock-unlock';\n\nexport const privateApis = {};\nlock( privateApis, {\n\tuseHistory,\n\tuseLocation,\n\tRouterProvider,\n\tuseLink,\n\tLink,\n} );\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","const","createObject","create","map","undefined","path","matcher","delegate","to","target","callback","this","willAddRoute","add","length","Error","addChild","routes","createMap","children","generateMatch","startingPath","let","fullPath","Target","addRoute","routeArray","handler","len","i","route","substr","push","eachRoute","baseRoute","binding","paths","keys","slice","nested","split","normalizeSegment","join","Matcher","match","contextEntered","SEGMENT_RESERVED_CHARS","segment","indexOf","decodeURIComponent","replace","encodeURIComponent","PATH_SEGMENT_ENCODINGS","str","escapeRegex","isArray","Array","getParam","params","eachChar","currentState","state","ch","charCodeAt","put","_","regex","generate","RouteRecognizer","ENCODE_AND_DECODE_PATH_SEGMENTS","encodePathSegment","EmptyObject","freeze","EmptyArray","parse","segments","types","parts","names","shouldDecodes","flags","type","part","isEqualCharSpec","spec","char","negate","states","id","repeat","nextStates","pattern","_regex","handlers","isMatch","recognizeChar","l","concat","RegExp","child","State","returned","queryParams","decodeQueryParamPart","result","error","RecognizeResults","splice","rootState","options","name","allSegments","isEmpty","j","as","handlersFor","hasRoute","output","charAt","generateQueryString","pairs","sort","pair","arrayPair","parseQueryString","queryString","keyLength","recognize","results","isSlashDropped","hashStart","queryStart","originalPath","normalizePath","decodeURI","pathLen","solutions","a","b","astatics","adynamics","astars","bstatics","bdynamics","bstars","sortSolutions","captures","currentCapture","isDynamic","capture","findHandler","VERSION","Normalizer","addRouteCallback","assign","bind","n","e","arguments","t","r","apply","window","history","createBrowserHistory","RoutesContext","createContext","ConfigContext","pathArg","locationMemo","WeakMap","getLocationWithQuery","location","locationWithQuery","query","fromEntries","URLSearchParams","search","set","useHistory","beforeNavigate","useContext","navigate","useEvent","async","rawPath","_getPath","getQueryArgs","getPath","performPush","buildQueryString","matchMedia","matches","document","startViewTransition","transition","Promise","resolve","_options$transition","classname","documentElement","classList","finished","finally","remove","useMemo","back","useLink","link","before","href","onClick","event","preventDefault","lock","unlock","__dangerousOptInToUnstableAPIsOnlyForCoreModules","privateApis","useLocation","context","RouterProvider","matchResolverArgs","rawQuery","addQueryArgs","areas","widths","matchedRoute","resolveFunctions","record","entries","useMatch","useSyncExternalStore","listen","ret","forEach","config","_jsx","Provider","Link","props"],"sourceRoot":""}