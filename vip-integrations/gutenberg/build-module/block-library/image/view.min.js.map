{"version":3,"file":"block-library/image/view.min.js","mappings":"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","sources":["webpack://wp/webpack/bootstrap","webpack://wp/webpack/runtime/define property getters","webpack://wp/webpack/runtime/hasOwnProperty shorthand","webpack://wp/external module \"@wordpress/interactivity\"","webpack://wp/./packages/block-library/build-module/image/@wordpress/block-library/src/image/view.js"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","var x = (y) => {\n\tvar x = {}; __webpack_require__.d(x, y); return x\n} \nvar y = (x) => (() => (x))\nconst __WEBPACK_NAMESPACE_OBJECT__ = x({ [\"getContext\"]: () => (__WEBPACK_EXTERNAL_MODULE__wordpress_interactivity_8e89b257__.getContext), [\"getElement\"]: () => (__WEBPACK_EXTERNAL_MODULE__wordpress_interactivity_8e89b257__.getElement), [\"store\"]: () => (__WEBPACK_EXTERNAL_MODULE__wordpress_interactivity_8e89b257__.store), [\"withSyncEvent\"]: () => (__WEBPACK_EXTERNAL_MODULE__wordpress_interactivity_8e89b257__.withSyncEvent) });","/**\n * WordPress dependencies\n */\nimport {\n\tstore,\n\tgetContext,\n\tgetElement,\n\twithSyncEvent,\n} from '@wordpress/interactivity';\n\n/**\n * Tracks whether user is touching screen; used to differentiate behavior for\n * touch and mouse input.\n *\n * @type {boolean}\n */\nlet isTouching = false;\n\n/**\n * Tracks the last time the screen was touched; used to differentiate behavior\n * for touch and mouse input.\n *\n * @type {number}\n */\nlet lastTouchTime = 0;\n\nconst { state, actions, callbacks } = store(\n\t'core/image',\n\t{\n\t\tstate: {\n\t\t\tcurrentImageId: null,\n\t\t\tget currentImage() {\n\t\t\t\treturn state.metadata[ state.currentImageId ];\n\t\t\t},\n\t\t\tget overlayOpened() {\n\t\t\t\treturn state.currentImageId !== null;\n\t\t\t},\n\t\t\tget roleAttribute() {\n\t\t\t\treturn state.overlayOpened ? 'dialog' : null;\n\t\t\t},\n\t\t\tget ariaModal() {\n\t\t\t\treturn state.overlayOpened ? 'true' : null;\n\t\t\t},\n\t\t\tget enlargedSrc() {\n\t\t\t\treturn (\n\t\t\t\t\tstate.currentImage.uploadedSrc ||\n\t\t\t\t\t'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs='\n\t\t\t\t);\n\t\t\t},\n\t\t\tget figureStyles() {\n\t\t\t\treturn (\n\t\t\t\t\tstate.overlayOpened &&\n\t\t\t\t\t`${ state.currentImage.figureStyles?.replace(\n\t\t\t\t\t\t/margin[^;]*;?/g,\n\t\t\t\t\t\t''\n\t\t\t\t\t) };`\n\t\t\t\t);\n\t\t\t},\n\t\t\tget imgStyles() {\n\t\t\t\treturn (\n\t\t\t\t\tstate.overlayOpened &&\n\t\t\t\t\t`${ state.currentImage.imgStyles?.replace(\n\t\t\t\t\t\t/;$/,\n\t\t\t\t\t\t''\n\t\t\t\t\t) }; object-fit:cover;`\n\t\t\t\t);\n\t\t\t},\n\t\t\tget imageButtonRight() {\n\t\t\t\tconst { imageId } = getContext();\n\t\t\t\treturn state.metadata[ imageId ].imageButtonRight;\n\t\t\t},\n\t\t\tget imageButtonTop() {\n\t\t\t\tconst { imageId } = getContext();\n\t\t\t\treturn state.metadata[ imageId ].imageButtonTop;\n\t\t\t},\n\t\t\tget isContentHidden() {\n\t\t\t\tconst ctx = getContext();\n\t\t\t\treturn (\n\t\t\t\t\tstate.overlayEnabled && state.currentImageId === ctx.imageId\n\t\t\t\t);\n\t\t\t},\n\t\t\tget isContentVisible() {\n\t\t\t\tconst ctx = getContext();\n\t\t\t\treturn (\n\t\t\t\t\t! state.overlayEnabled &&\n\t\t\t\t\tstate.currentImageId === ctx.imageId\n\t\t\t\t);\n\t\t\t},\n\t\t},\n\t\tactions: {\n\t\t\tshowLightbox() {\n\t\t\t\tconst { imageId } = getContext();\n\n\t\t\t\t// Bails out if the image has not loaded yet.\n\t\t\t\tif ( ! state.metadata[ imageId ].imageRef?.complete ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Stores the positions of the scroll to fix it until the overlay is\n\t\t\t\t// closed.\n\t\t\t\tstate.scrollTopReset = document.documentElement.scrollTop;\n\t\t\t\tstate.scrollLeftReset = document.documentElement.scrollLeft;\n\n\t\t\t\t// Sets the current expanded image in the state and enables the overlay.\n\t\t\t\tstate.overlayEnabled = true;\n\t\t\t\tstate.currentImageId = imageId;\n\n\t\t\t\t// Computes the styles of the overlay for the animation.\n\t\t\t\tcallbacks.setOverlayStyles();\n\t\t\t},\n\t\t\thideLightbox() {\n\t\t\t\tif ( state.overlayEnabled ) {\n\t\t\t\t\tstate.overlayEnabled = false;\n\n\t\t\t\t\t// Waits until the close animation has completed before allowing a\n\t\t\t\t\t// user to scroll again. The duration of this animation is defined in\n\t\t\t\t\t// the `styles.scss` file, but in any case we should wait a few\n\t\t\t\t\t// milliseconds longer than the duration, otherwise a user may scroll\n\t\t\t\t\t// too soon and cause the animation to look sloppy.\n\t\t\t\t\tsetTimeout( function () {\n\t\t\t\t\t\t// Delays before changing the focus. Otherwise the focus ring will\n\t\t\t\t\t\t// appear on Firefox before the image has finished animating, which\n\t\t\t\t\t\t// looks broken.\n\t\t\t\t\t\tstate.currentImage.buttonRef.focus( {\n\t\t\t\t\t\t\tpreventScroll: true,\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t// Resets the current image id to mark the overlay as closed.\n\t\t\t\t\t\tstate.currentImageId = null;\n\t\t\t\t\t}, 450 );\n\t\t\t\t}\n\t\t\t},\n\t\t\thandleKeydown: withSyncEvent( ( event ) => {\n\t\t\t\tif ( state.overlayEnabled ) {\n\t\t\t\t\t// Focuses the close button when the user presses the tab key.\n\t\t\t\t\tif ( event.key === 'Tab' ) {\n\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\tconst { ref } = getElement();\n\t\t\t\t\t\tref.querySelector( 'button' ).focus();\n\t\t\t\t\t}\n\t\t\t\t\t// Closes the lightbox when the user presses the escape key.\n\t\t\t\t\tif ( event.key === 'Escape' ) {\n\t\t\t\t\t\tactions.hideLightbox();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} ),\n\t\t\thandleTouchMove: withSyncEvent( ( event ) => {\n\t\t\t\t// On mobile devices, prevents triggering the scroll event because\n\t\t\t\t// otherwise the page jumps around when it resets the scroll position.\n\t\t\t\t// This also means that closing the lightbox requires that a user\n\t\t\t\t// perform a simple tap. This may be changed in the future if there is a\n\t\t\t\t// better alternative to override or reset the scroll position during\n\t\t\t\t// swipe actions.\n\t\t\t\tif ( state.overlayEnabled ) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\t\t\t} ),\n\t\t\thandleTouchStart() {\n\t\t\t\tisTouching = true;\n\t\t\t},\n\t\t\thandleTouchEnd() {\n\t\t\t\t// Waits a few milliseconds before resetting to ensure that pinch to\n\t\t\t\t// zoom works consistently on mobile devices when the lightbox is open.\n\t\t\t\tlastTouchTime = Date.now();\n\t\t\t\tisTouching = false;\n\t\t\t},\n\t\t\thandleScroll() {\n\t\t\t\t// Prevents scrolling behaviors that trigger content shift while the\n\t\t\t\t// lightbox is open. It would be better to accomplish through CSS alone,\n\t\t\t\t// but using overflow: hidden is currently the only way to do so and\n\t\t\t\t// that causes a layout to shift and prevents the zoom animation from\n\t\t\t\t// working in some cases because it's not possible to account for the\n\t\t\t\t// layout shift when doing the animation calculations. Instead, it uses\n\t\t\t\t// JavaScript to prevent and reset the scrolling behavior.\n\t\t\t\tif ( state.overlayOpened ) {\n\t\t\t\t\t// Avoids overriding the scroll behavior on mobile devices because\n\t\t\t\t\t// doing so breaks the pinch to zoom functionality, and users should\n\t\t\t\t\t// be able to zoom in further on the high-res image.\n\t\t\t\t\tif ( ! isTouching && Date.now() - lastTouchTime > 450 ) {\n\t\t\t\t\t\t// It doesn't rely on `event.preventDefault()` to prevent scrolling\n\t\t\t\t\t\t// because the scroll event can't be canceled, so it resets the\n\t\t\t\t\t\t// position instead.\n\t\t\t\t\t\twindow.scrollTo(\n\t\t\t\t\t\t\tstate.scrollLeftReset,\n\t\t\t\t\t\t\tstate.scrollTopReset\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\tcallbacks: {\n\t\t\tsetOverlayStyles() {\n\t\t\t\tif ( ! state.overlayEnabled ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tlet {\n\t\t\t\t\tnaturalWidth,\n\t\t\t\t\tnaturalHeight,\n\t\t\t\t\toffsetWidth: originalWidth,\n\t\t\t\t\toffsetHeight: originalHeight,\n\t\t\t\t} = state.currentImage.imageRef;\n\t\t\t\tlet { x: screenPosX, y: screenPosY } =\n\t\t\t\t\tstate.currentImage.imageRef.getBoundingClientRect();\n\n\t\t\t\t// Natural ratio of the image clicked to open the lightbox.\n\t\t\t\tconst naturalRatio = naturalWidth / naturalHeight;\n\t\t\t\t// Original ratio of the image clicked to open the lightbox.\n\t\t\t\tlet originalRatio = originalWidth / originalHeight;\n\n\t\t\t\t// If it has object-fit: contain, recalculates the original sizes\n\t\t\t\t// and the screen position without the blank spaces.\n\t\t\t\tif ( state.currentImage.scaleAttr === 'contain' ) {\n\t\t\t\t\tif ( naturalRatio > originalRatio ) {\n\t\t\t\t\t\tconst heightWithoutSpace = originalWidth / naturalRatio;\n\t\t\t\t\t\t// Recalculates screen position without the top space.\n\t\t\t\t\t\tscreenPosY +=\n\t\t\t\t\t\t\t( originalHeight - heightWithoutSpace ) / 2;\n\t\t\t\t\t\toriginalHeight = heightWithoutSpace;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst widthWithoutSpace = originalHeight * naturalRatio;\n\t\t\t\t\t\t// Recalculates screen position without the left space.\n\t\t\t\t\t\tscreenPosX += ( originalWidth - widthWithoutSpace ) / 2;\n\t\t\t\t\t\toriginalWidth = widthWithoutSpace;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\toriginalRatio = originalWidth / originalHeight;\n\n\t\t\t\t// Typically, it uses the image's full-sized dimensions. If those\n\t\t\t\t// dimensions have not been set (i.e. an external image with only one\n\t\t\t\t// size), the image's dimensions in the lightbox are the same\n\t\t\t\t// as those of the image in the content.\n\t\t\t\tlet imgMaxWidth = parseFloat(\n\t\t\t\t\tstate.currentImage.targetWidth !== 'none'\n\t\t\t\t\t\t? state.currentImage.targetWidth\n\t\t\t\t\t\t: naturalWidth\n\t\t\t\t);\n\t\t\t\tlet imgMaxHeight = parseFloat(\n\t\t\t\t\tstate.currentImage.targetHeight !== 'none'\n\t\t\t\t\t\t? state.currentImage.targetHeight\n\t\t\t\t\t\t: naturalHeight\n\t\t\t\t);\n\n\t\t\t\t// Ratio of the biggest image stored in the database.\n\t\t\t\tlet imgRatio = imgMaxWidth / imgMaxHeight;\n\t\t\t\tlet containerMaxWidth = imgMaxWidth;\n\t\t\t\tlet containerMaxHeight = imgMaxHeight;\n\t\t\t\tlet containerWidth = imgMaxWidth;\n\t\t\t\tlet containerHeight = imgMaxHeight;\n\n\t\t\t\t// Checks if the target image has a different ratio than the original\n\t\t\t\t// one (thumbnail). Recalculates the width and height.\n\t\t\t\tif ( naturalRatio.toFixed( 2 ) !== imgRatio.toFixed( 2 ) ) {\n\t\t\t\t\tif ( naturalRatio > imgRatio ) {\n\t\t\t\t\t\t// If the width is reached before the height, it keeps the maxWidth\n\t\t\t\t\t\t// and recalculates the height unless the difference between the\n\t\t\t\t\t\t// maxHeight and the reducedHeight is higher than the maxWidth,\n\t\t\t\t\t\t// where it keeps the reducedHeight and recalculate the width.\n\t\t\t\t\t\tconst reducedHeight = imgMaxWidth / naturalRatio;\n\t\t\t\t\t\tif ( imgMaxHeight - reducedHeight > imgMaxWidth ) {\n\t\t\t\t\t\t\timgMaxHeight = reducedHeight;\n\t\t\t\t\t\t\timgMaxWidth = reducedHeight * naturalRatio;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\timgMaxHeight = imgMaxWidth / naturalRatio;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// If the height is reached before the width, it keeps the maxHeight\n\t\t\t\t\t\t// and recalculate the width unlesss the difference between the\n\t\t\t\t\t\t// maxWidth and the reducedWidth is higher than the maxHeight, where\n\t\t\t\t\t\t// it keeps the reducedWidth and recalculate the height.\n\t\t\t\t\t\tconst reducedWidth = imgMaxHeight * naturalRatio;\n\t\t\t\t\t\tif ( imgMaxWidth - reducedWidth > imgMaxHeight ) {\n\t\t\t\t\t\t\timgMaxWidth = reducedWidth;\n\t\t\t\t\t\t\timgMaxHeight = reducedWidth / naturalRatio;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\timgMaxWidth = imgMaxHeight * naturalRatio;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcontainerWidth = imgMaxWidth;\n\t\t\t\t\tcontainerHeight = imgMaxHeight;\n\t\t\t\t\timgRatio = imgMaxWidth / imgMaxHeight;\n\n\t\t\t\t\t// Calculates the max size of the container.\n\t\t\t\t\tif ( originalRatio > imgRatio ) {\n\t\t\t\t\t\tcontainerMaxWidth = imgMaxWidth;\n\t\t\t\t\t\tcontainerMaxHeight = containerMaxWidth / originalRatio;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontainerMaxHeight = imgMaxHeight;\n\t\t\t\t\t\tcontainerMaxWidth = containerMaxHeight * originalRatio;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// If the image has been pixelated on purpose, it keeps that size.\n\t\t\t\tif (\n\t\t\t\t\toriginalWidth > containerWidth ||\n\t\t\t\t\toriginalHeight > containerHeight\n\t\t\t\t) {\n\t\t\t\t\tcontainerWidth = originalWidth;\n\t\t\t\t\tcontainerHeight = originalHeight;\n\t\t\t\t}\n\n\t\t\t\t// Calculates the final lightbox image size and the scale factor.\n\t\t\t\t// MaxWidth is either the window container (accounting for padding) or\n\t\t\t\t// the image resolution.\n\t\t\t\tlet horizontalPadding = 0;\n\t\t\t\tif ( window.innerWidth > 480 ) {\n\t\t\t\t\thorizontalPadding = 80;\n\t\t\t\t} else if ( window.innerWidth > 1920 ) {\n\t\t\t\t\thorizontalPadding = 160;\n\t\t\t\t}\n\t\t\t\tconst verticalPadding = 80;\n\n\t\t\t\tconst targetMaxWidth = Math.min(\n\t\t\t\t\twindow.innerWidth - horizontalPadding,\n\t\t\t\t\tcontainerWidth\n\t\t\t\t);\n\t\t\t\tconst targetMaxHeight = Math.min(\n\t\t\t\t\twindow.innerHeight - verticalPadding,\n\t\t\t\t\tcontainerHeight\n\t\t\t\t);\n\t\t\t\tconst targetContainerRatio = targetMaxWidth / targetMaxHeight;\n\n\t\t\t\tif ( originalRatio > targetContainerRatio ) {\n\t\t\t\t\t// If targetMaxWidth is reached before targetMaxHeight.\n\t\t\t\t\tcontainerWidth = targetMaxWidth;\n\t\t\t\t\tcontainerHeight = containerWidth / originalRatio;\n\t\t\t\t} else {\n\t\t\t\t\t// If targetMaxHeight is reached before targetMaxWidth.\n\t\t\t\t\tcontainerHeight = targetMaxHeight;\n\t\t\t\t\tcontainerWidth = containerHeight * originalRatio;\n\t\t\t\t}\n\n\t\t\t\tconst containerScale = originalWidth / containerWidth;\n\t\t\t\tconst lightboxImgWidth =\n\t\t\t\t\timgMaxWidth * ( containerWidth / containerMaxWidth );\n\t\t\t\tconst lightboxImgHeight =\n\t\t\t\t\timgMaxHeight * ( containerHeight / containerMaxHeight );\n\n\t\t\t\t// As of this writing, using the calculations above will render the\n\t\t\t\t// lightbox with a small, erroneous whitespace on the left side of the\n\t\t\t\t// image in iOS Safari, perhaps due to an inconsistency in how browsers\n\t\t\t\t// handle absolute positioning and CSS transformation. In any case,\n\t\t\t\t// adding 1 pixel to the container width and height solves the problem,\n\t\t\t\t// though this can be removed if the issue is fixed in the future.\n\t\t\t\tstate.overlayStyles = `\n\t\t\t\t\t--wp--lightbox-initial-top-position: ${ screenPosY }px;\n\t\t\t\t\t--wp--lightbox-initial-left-position: ${ screenPosX }px;\n\t\t\t\t\t--wp--lightbox-container-width: ${ containerWidth + 1 }px;\n\t\t\t\t\t--wp--lightbox-container-height: ${ containerHeight + 1 }px;\n\t\t\t\t\t--wp--lightbox-image-width: ${ lightboxImgWidth }px;\n\t\t\t\t\t--wp--lightbox-image-height: ${ lightboxImgHeight }px;\n\t\t\t\t\t--wp--lightbox-scale: ${ containerScale };\n\t\t\t\t\t--wp--lightbox-scrollbar-width: ${\n\t\t\t\t\t\twindow.innerWidth - document.documentElement.clientWidth\n\t\t\t\t\t}px;\n\t\t\t\t`;\n\t\t\t},\n\t\t\tsetButtonStyles() {\n\t\t\t\tconst { imageId } = getContext();\n\t\t\t\tconst { ref } = getElement();\n\n\t\t\t\tstate.metadata[ imageId ].imageRef = ref;\n\t\t\t\tstate.metadata[ imageId ].currentSrc = ref.currentSrc;\n\n\t\t\t\tconst {\n\t\t\t\t\tnaturalWidth,\n\t\t\t\t\tnaturalHeight,\n\t\t\t\t\toffsetWidth,\n\t\t\t\t\toffsetHeight,\n\t\t\t\t} = ref;\n\n\t\t\t\t// If the image isn't loaded yet, it can't calculate where the button\n\t\t\t\t// should be.\n\t\t\t\tif ( naturalWidth === 0 || naturalHeight === 0 ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst figure = ref.parentElement;\n\t\t\t\tconst figureWidth = ref.parentElement.clientWidth;\n\n\t\t\t\t// It needs special handling for the height because a caption will cause\n\t\t\t\t// the figure to be taller than the image, which means it needs to\n\t\t\t\t// account for that when calculating the placement of the button in the\n\t\t\t\t// top right corner of the image.\n\t\t\t\tlet figureHeight = ref.parentElement.clientHeight;\n\t\t\t\tconst caption = figure.querySelector( 'figcaption' );\n\t\t\t\tif ( caption ) {\n\t\t\t\t\tconst captionComputedStyle =\n\t\t\t\t\t\twindow.getComputedStyle( caption );\n\t\t\t\t\tif (\n\t\t\t\t\t\t! [ 'absolute', 'fixed' ].includes(\n\t\t\t\t\t\t\tcaptionComputedStyle.position\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\tfigureHeight =\n\t\t\t\t\t\t\tfigureHeight -\n\t\t\t\t\t\t\tcaption.offsetHeight -\n\t\t\t\t\t\t\tparseFloat( captionComputedStyle.marginTop ) -\n\t\t\t\t\t\t\tparseFloat( captionComputedStyle.marginBottom );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst buttonOffsetTop = figureHeight - offsetHeight;\n\t\t\t\tconst buttonOffsetRight = figureWidth - offsetWidth;\n\n\t\t\t\tlet imageButtonTop = buttonOffsetTop + 16;\n\t\t\t\tlet imageButtonRight = buttonOffsetRight + 16;\n\n\t\t\t\t// In the case of an image with object-fit: contain, the size of the\n\t\t\t\t// <img> element can be larger than the image itself, so it needs to\n\t\t\t\t// calculate where to place the button.\n\t\t\t\tif ( state.metadata[ imageId ].scaleAttr === 'contain' ) {\n\t\t\t\t\t// Natural ratio of the image.\n\t\t\t\t\tconst naturalRatio = naturalWidth / naturalHeight;\n\t\t\t\t\t// Offset ratio of the image.\n\t\t\t\t\tconst offsetRatio = offsetWidth / offsetHeight;\n\n\t\t\t\t\tif ( naturalRatio >= offsetRatio ) {\n\t\t\t\t\t\t// If it reaches the width first, it keeps the width and compute the\n\t\t\t\t\t\t// height.\n\t\t\t\t\t\tconst referenceHeight = offsetWidth / naturalRatio;\n\t\t\t\t\t\timageButtonTop =\n\t\t\t\t\t\t\t( offsetHeight - referenceHeight ) / 2 +\n\t\t\t\t\t\t\tbuttonOffsetTop +\n\t\t\t\t\t\t\t16;\n\t\t\t\t\t\timageButtonRight = buttonOffsetRight + 16;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// If it reaches the height first, it keeps the height and compute\n\t\t\t\t\t\t// the width.\n\t\t\t\t\t\tconst referenceWidth = offsetHeight * naturalRatio;\n\t\t\t\t\t\timageButtonTop = buttonOffsetTop + 16;\n\t\t\t\t\t\timageButtonRight =\n\t\t\t\t\t\t\t( offsetWidth - referenceWidth ) / 2 +\n\t\t\t\t\t\t\tbuttonOffsetRight +\n\t\t\t\t\t\t\t16;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tstate.metadata[ imageId ].imageButtonTop = imageButtonTop;\n\t\t\t\tstate.metadata[ imageId ].imageButtonRight = imageButtonRight;\n\t\t\t},\n\t\t\tsetOverlayFocus() {\n\t\t\t\tif ( state.overlayEnabled ) {\n\t\t\t\t\t// Moves the focus to the dialog when it opens.\n\t\t\t\t\tconst { ref } = getElement();\n\t\t\t\t\tref.focus();\n\t\t\t\t}\n\t\t\t},\n\t\t\tinitTriggerButton() {\n\t\t\t\tconst { imageId } = getContext();\n\t\t\t\tconst { ref } = getElement();\n\t\t\t\tstate.metadata[ imageId ].buttonRef = ref;\n\t\t\t},\n\t\t},\n\t},\n\t{ lock: true }\n);\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","y","__WEBPACK_EXTERNAL_MODULE__wordpress_interactivity_8e89b257__","x","d","isTouching","lastTouchTime","state","actions","callbacks","store","currentImageId","currentImage","metadata","overlayOpened","roleAttribute","ariaModal","enlargedSrc","uploadedSrc","figureStyles","replace","imgStyles","imageButtonRight","imageId","getContext","imageButtonTop","isContentHidden","ctx","overlayEnabled","isContentVisible","showLightbox","imageRef","complete","scrollTopReset","document","documentElement","scrollTop","scrollLeftReset","scrollLeft","setOverlayStyles","hideLightbox","setTimeout","buttonRef","focus","preventScroll","handleKeydown","withSyncEvent","event","preventDefault","ref","getElement","querySelector","handleTouchMove","handleTouchStart","handleTouchEnd","Date","now","handleScroll","window","scrollTo","naturalWidth","naturalHeight","offsetWidth","originalWidth","offsetHeight","originalHeight","screenPosX","screenPosY","getBoundingClientRect","naturalRatio","originalRatio","scaleAttr","heightWithoutSpace","widthWithoutSpace","imgMaxWidth","parseFloat","targetWidth","imgMaxHeight","targetHeight","imgRatio","containerMaxWidth","containerMaxHeight","containerWidth","containerHeight","toFixed","reducedHeight","reducedWidth","horizontalPadding","innerWidth","targetMaxWidth","Math","min","targetMaxHeight","innerHeight","containerScale","lightboxImgWidth","lightboxImgHeight","overlayStyles","clientWidth","setButtonStyles","currentSrc","figure","parentElement","figureWidth","figureHeight","clientHeight","caption","captionComputedStyle","getComputedStyle","includes","position","marginTop","marginBottom","buttonOffsetTop","buttonOffsetRight","setOverlayFocus","initTriggerButton","lock"],"sourceRoot":""}