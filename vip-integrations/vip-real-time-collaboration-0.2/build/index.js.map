{"version":3,"file":"index.js","mappings":"mBACA,IAAIA,EAAsB,CCA1BA,EAAyBC,IACxB,IAAIC,EAASD,GAAUA,EAAOE,WAC7B,IAAOF,EAAiB,QACxB,IAAM,EAEP,OADAD,EAAoBI,EAAEF,EAAQ,CAAEG,EAAGH,IAC5BA,GCLRF,EAAwB,CAACM,EAASC,KACjC,IAAI,IAAIC,KAAOD,EACXP,EAAoBS,EAAEF,EAAYC,KAASR,EAAoBS,EAAEH,EAASE,IAC5EE,OAAOC,eAAeL,EAASE,EAAK,CAAEI,YAAY,EAAMC,IAAKN,EAAWC,MCJ3ER,EAAwB,CAACc,EAAKC,IAAUL,OAAOM,UAAUC,eAAeC,KAAKJ,EAAKC,ICAlF,MAAM,EAA+BI,OAAW,GAAS,MCC5CC,EAAgBC,EAAwB,SAExCC,EAAUD,EAAwB,UAO/C,SAASA,EACRb,GAEA,MAAK,oBAAuBW,aAAU,IAAuBA,OAAOI,QAC5D,KAIDJ,OAAOI,QAASf,EACxB,CCjBO,IAAKgB,GAAZ,SAAYA,GACXA,EAAAA,EAAA,uBACAA,EAAAA,EAAA,iBACAA,EAAAA,EAAA,qBACAA,EAAAA,EAAA,eACAA,EAAAA,EAAA,gBACA,CAND,CAAYA,IAAAA,EAAQ,KAQpB,MAAMC,EAA2DD,EAASE,QAEpE,MAAOC,EAGZC,WAAAA,CACCC,EAAyB,GACjBC,EAAsBL,GAAtB,KAAAK,UAAAA,EAERC,KAAKC,UAAY,WAAWH,EAAiB,IAAKA,IAAoB,GACvE,CAEUI,GAAAA,CAAKC,KAAoBC,GAClC,GAAKD,EAAQH,KAAKD,UACjB,OAID,MAAMM,EAAWZ,EAAUU,GAG3BG,QAAQJ,IAAK,IAAKF,KAAKC,cAAgBI,QAAiBD,EACzD,CAEOG,KAAAA,IAAUH,GAChBJ,KAAKE,IAAKT,EAASe,SAAUJ,EAC9B,CAEOK,IAAAA,IAASL,GACfJ,KAAKE,IAAKT,EAASiB,QAASN,EAC7B,CAEOO,IAAAA,IAASP,GACfJ,KAAKE,IAAKT,EAASE,WAAYS,EAChC,CAEOQ,KAAAA,IAAUR,GAChBJ,KAAKE,IAAKT,EAASoB,SAAUT,EAC9B,CAEOU,QAAAA,IAAaV,GACnBJ,KAAKE,IAAKT,EAASsB,YAAaX,EACjC,ECpDD,MAAM,EAA+BhB,OAAW,GAAY,S,aCA5D,MAAM,EAA+BA,OAAW,GAAQ,KCAlD,EAA+B4B,GAAGC,KAAKC,ECchCC,EAAS,IAAM,IAAIC,IAgCnBC,EAAiB,CAACC,EAAK7C,EAAK8C,KACvC,IAAIC,EAAMF,EAAIxC,IAAIL,GAIlB,YAHYgD,IAARD,GACFF,EAAIE,IAAI/C,EAAK+C,EAAMD,KAEdC,GC7CI,EAAS,IAAM,IAAIE,ICEnBC,EAAeC,OAAOD,aAe7BE,GAduBD,OAAOE,cAMDH,EAAa,OAQ1B,SAQhBI,EAAqB,WAOdC,EAAgB,CAACC,EAAGC,IATTD,IAAKA,EAAEE,QAAQN,EAAe,IASPO,CAASH,EAAEE,QAAQJ,EAAoBM,GAAS,GAAGH,IAjB9ED,IAAKA,EAAEK,cAiBmFA,CAAYD,OAwB7GE,EAAqE,oBAAhBC,YAA8B,IAAIA,YAAgB,KAmC7G,IAAIC,EAAyC,oBAAhBC,YAA8B,KAAO,IAAIA,YAAY,QAAS,CAAEC,OAAO,EAAMC,WAAW,IAGxHH,GAAuE,IAApDA,EAAgBI,OAAO,IAAIC,YAAcC,SAO9DN,EAAkB,MCvEpB,IAAIO,EAAgB,IAzBpB,MACE,WAAAnD,GACEG,KAAKsB,IAAM,IAAIF,GACjB,CAMA,OAAA6B,CAASxE,EAAKyE,GACZlD,KAAKsB,IAAIE,IAAI/C,EAAKyE,EACpB,CAKA,OAAAC,CAAS1E,GACP,OAAOuB,KAAKsB,IAAIxC,IAAIL,EACtB,GAQE2E,GAAc,EAGlB,IAE8B,oBAAjBC,cAAgCA,eACzCL,EAAgBK,aAChBD,GAAc,EAElB,CAAE,MAAOE,GAAK,CAOP,MAAMC,EAAaP,ECFb,EAAOQ,MAAMC,KCrCbC,GDoHUF,MAAMG,QCpHY,oBAAZC,SAA2BA,QAAQC,SAAW,cAAcC,KAAKF,QAAQC,QAAQE,OAA0F,qBAAjFpF,OAAOM,UAAU+E,SAAS7E,KAAwB,oBAAZyE,QAA0BA,QAAU,IAGpLK,EAA8B,oBAAX7E,QAA8C,oBAAb8E,WAA6BR,EAS9F,IAAIS,EAPsC,oBAAdC,WACxB,MAAMN,KAAKM,UAAUC,UAOzB,MAAMjE,EAAO,GAmDAkE,EAAYP,GAhDH,MACpB,QAAetC,IAAX0C,EACF,GAAIT,EAAQ,CACVS,EAAS,IACT,MAAMI,EAAQX,QAAQY,KACtB,IAAIC,EAAgB,KACpB,IAAK,IAAIC,EAAI,EAAGA,EAAIH,EAAMxB,OAAQ2B,IAAK,CACrC,MAAMC,EAAOJ,EAAMG,GACH,MAAZC,EAAK,IACe,OAAlBF,GACFN,EAAO3C,IAAIiD,EAAe,IAE5BA,EAAgBE,GAEM,OAAlBF,GACFN,EAAO3C,IAAIiD,EAAeE,GAC1BF,EAAgB,MAEhBrE,EAAKwE,KAAKD,EAGhB,CACsB,OAAlBF,GACFN,EAAO3C,IAAIiD,EAAe,GAG9B,KAA+B,iBAAbI,UAChBV,EAAS,KACRU,SAASC,QAAU,KAAKC,MAAM,GAAGC,MAAM,KAAKC,QAASC,IACpD,GAAkB,IAAdA,EAAGnC,OAAc,CACnB,MAAOtE,EAAK0G,GAASD,EAAGF,MAAM,KAC9Bb,EAAO3C,IAAI,KAAK,EAAqB/C,EAAK,OAAQ0G,GAClDhB,EAAO3C,IAAI,IAAI,EAAqB/C,EAAK,OAAQ0G,EACnD,KAGFhB,EAAS,IAGb,OAAOA,GASyBiB,GAAgBC,IAAItB,GAgBzCuB,EAAevB,IAC1BL,YCnFwCjC,KAAX8D,EDmF7B7B,EAC+BE,QAAQ4B,IAAIzB,EAAK0B,cAAcC,WAAW,IAAK,MAC/C,EAAmBvC,QAAQY,ICrFN,KAAOwB,EAA9BA,OD+GlBI,EAAW5B,GACtBO,EAAS,KAAOP,IAA+B,OAAtBuB,EAAYvB,GE4BhB,IAACoB,EFzBEQ,EAAQ,cAGfjC,IEsBKyB,EFrBZvB,QAAQ4B,IAAII,YAAa,CAAC,OAAQ,IAAK,KEqBAC,SAASV,MFVzDb,EAAS,iBACTqB,EAAQ,eACPjC,GAAUE,QAAQkC,OAAOC,UACxBrC,GACDY,EAAS,YACoB,OAA7BgB,EAAY,eACXA,EAAY,SAAW,IAAIO,SAAS,UAPlC,MG7DMG,EAAW,EAzCAC,IACtB,IAAIhE,EAAI,GACR,IAAK,IAAIyC,EAAI,EAAGA,EAAIuB,EAAMC,WAAYxB,IACpCzC,GAAK,EAAoBgE,EAAMvB,IAGjC,OAAOyB,KAAKlE,IAQOgE,GAASG,OAAO3C,KAAKwC,EAAMI,OAAQJ,EAAMK,WAAYL,EAAMC,YAAYlC,SAAS,UA8BxFuC,EAAa,EAvBAtE,IAExB,MAAM3D,EAAIkI,KAAKvE,GACTgE,GA/C+BQ,EA+CCnI,EAAEyE,OA/CI,IAAID,WAAW2D,IAAtBA,MAgDrC,IAAK,IAAI/B,EAAI,EAAGA,EAAIpG,EAAEyE,OAAQ2B,IAC5BuB,EAAMvB,GAAKpG,EAAEoI,WAAWhC,GAE1B,OAAOuB,GAOchE,IACrB,MAAM0E,EAAMP,OAAO3C,KAAKxB,EAAG,UAC3B,OAnDkDoE,EAmDPM,EAAIN,OAnDWC,EAmDHK,EAAIL,WAnDWvD,EAmDC4D,EAAIT,WAnDM,IAAIpD,WAAWuD,EAAQC,EAAYvD,GAAnE,IAACsD,EAAQC,EAAYvD,GCQlE6D,EAAW,IAAIxF,IAmCfyF,EAAiC,oBAArBC,iBAhClB,MAIE,WAAAjH,CAAakH,GNsBSC,MMrBpBhH,KAAK+G,KAAOA,EAIZ/G,KAAKiH,UAAY,KAIjBjH,KAAKkH,UAAY5D,GAAKA,EAAE7E,MAAQsI,GAA2B,OAAnB/G,KAAKiH,WAAsBjH,KAAKiH,UAAU,CAAEE,KAAM,EAAkB7D,EAAEJ,UAAY,MNatG8D,EMZHhH,KAAKkH,UNYc9D,GAAegE,iBAAiB,UAA8B,EMXpG,CAKA,WAAAC,CAAaV,GACX,EAAmB1D,QAAQjD,KAAK+G,KAAM,EDzBe,IAAIjE,WCyBoC6D,IAC/F,CAEA,KAAAW,GNWuBN,QMVHhH,KAAKkH,UNUc9D,GAAemE,oBAAoB,UAA8B,EMTxG,GAM0ET,iBAMtEU,EAAaT,GACjB,EAAmBH,EAAUG,EAAM,KACjC,MAAMU,EAAO,IACPC,EAAK,IAAIb,EAAGE,GAMlB,OADAW,EAAGT,UAAY3D,GAAKmE,EAAKxC,QAAQ0C,GAAOA,EAAIrE,EAAE6D,KAAM,qBAC7C,CACLO,KAAID,UAyCGG,EAAU,CAACb,EAAMI,EAAMU,EAAS,QAC3C,MAAMC,EAAIN,EAAWT,GACrBe,EAAEJ,GAAGL,YAAYF,GACjBW,EAAEL,KAAKxC,QAAQ0C,GAAOA,EAAIR,EAAMU,KC3GrBE,EAAcC,KAAKC,ICfnBC,EAAQC,KAAKD,MAwBbE,GAvBOD,KAAKE,KACNF,KAAKG,IACJH,KAAKI,KACJJ,KAAKK,MACLL,KAAKM,MACNN,KAAKO,KACNP,KAAKjI,IACJiI,KAAKQ,KAgBN,CAACrK,EAAGsK,IAAMtK,EAAIsK,EAAItK,EAAIsK,GAY5BC,GAFQC,OAAOC,MAETZ,KAAKU,KCtBXG,GD+BOb,KAAKc,KC/BL,KAsCPC,EAAQ,ICrBd,MAAMC,EACX,WAAAtJ,GACEG,KAAKoJ,KAAO,EACZpJ,KAAKqJ,KAAO,IAAIvG,WAAW,KAI3B9C,KAAKsJ,KAAO,EACd,EAOK,MAAMC,EAAgB,IAAM,IAAIJ,EAkB1B,EAASK,IACpB,IAAI/C,EAAM+C,EAAQJ,KAClB,IAAK,IAAI1E,EAAI,EAAGA,EAAI8E,EAAQF,KAAKvG,OAAQ2B,IACvC+B,GAAO+C,EAAQF,KAAK5E,GAAG3B,OAEzB,OAAO0D,GAmBIgD,EAAeD,IAC1B,MAAME,EAAW,IAAI5G,WAAW,EAAO0G,IACvC,IAAIG,EAAS,EACb,IAAK,IAAIjF,EAAI,EAAGA,EAAI8E,EAAQF,KAAKvG,OAAQ2B,IAAK,CAC5C,MAAMrG,EAAImL,EAAQF,KAAK5E,GACvBgF,EAASlI,IAAInD,EAAGsL,GAChBA,GAAUtL,EAAE0E,MACd,CAEA,OADA2G,EAASlI,IAAI,IAAIsB,WAAW0G,EAAQH,KAAKhD,OAAQ,EAAGmD,EAAQJ,MAAOO,GAC5DD,GA0BIE,EAAQ,CAACJ,EAASK,KAC7B,MAAMC,EAAYN,EAAQH,KAAKtG,OAC3ByG,EAAQJ,OAASU,IACnBN,EAAQF,KAAK1E,KAAK4E,EAAQH,MAC1BG,EAAQH,KAAO,IAAIvG,WAAuB,EAAZgH,GAC9BN,EAAQJ,KAAO,GAEjBI,EAAQH,KAAKG,EAAQJ,QAAUS,GA2HpBE,EAAe,CAACP,EAASK,KACpC,KAAOA,EAAM,GACXD,EAAMJ,EAAS,EAAe,EAAeK,GAC7CA,EAAM,EAAWA,EAAM,KAEzBD,EAAMJ,EAAS,EAAeK,IA+InBG,GAhHM,IAAIlH,WAAW,KACFC,OA+CD,GAA6C,EAAyBkH,WAgEtE,CAACT,EAASU,KACvC,MAAMJ,EAAYN,EAAQH,KAAKtG,OACzBqG,EAAOI,EAAQJ,KACfe,EAAc,EAASL,EAAYV,EAAMc,EAAWnH,QACpDqH,EAAeF,EAAWnH,OAASoH,EFrXxB,IAAC7L,EAAGsK,EEsXrBY,EAAQH,KAAK7H,IAAI0I,EAAWG,SAAS,EAAGF,GAAcf,GACtDI,EAAQJ,MAAQe,EACZC,EAAe,IAGjBZ,EAAQF,KAAK1E,KAAK4E,EAAQH,MAE1BG,EAAQH,KAAO,IAAIvG,YF7XHxE,EE6XmC,EAAZwL,IF7XpBlB,EE6XmCwB,GF7XrB9L,EAAIsK,GE+XrCY,EAAQH,KAAK7H,IAAI0I,EAAWG,SAASF,IACrCX,EAAQJ,KAAOgB,KAWNE,EAAqB,CAACd,EAASU,KAC1CH,EAAaP,EAASU,EAAWhE,YACjC8D,EAAgBR,EAASU,IAmDN,IAAIK,SAAS,IAAIC,YAAY,IC7d3C,MAAMC,EAAmB3B,OAAO2B,iBCE1B,IDDmB3B,OAAO4B,iBAOd5B,OAAO6B,UACX7B,OAAOC,MACJD,OAAO8B,SCRT3I,GAAK,IAAI4I,MAAM5I,ICwB/B6I,GAA4B,GAAa,2BACzCC,GAAyB,GAAa,wBAKrC,MAAMC,GAIX,WAAAnL,CAAaqK,GAMXlK,KAAKiL,IAAMf,EAMXlK,KAAKkL,IAAM,CACb,EAQK,MAmDMC,GAAoBC,GAhBH,EAACA,EAAS3E,KACtC,MAAM4E,EAAO,IAAIvI,WAAWsI,EAAQH,IAAI5E,OAAQ+E,EAAQF,IAAME,EAAQH,IAAI3E,WAAYG,GAEtF,OADA2E,EAAQF,KAAOzE,EACR4E,GAamCC,CAAeF,EAASG,GAAYH,IA2HnEG,GAAcH,IACzB,IAAIvB,EAAM,EACN2B,EAAO,EACX,MAAM/E,EAAM2E,EAAQH,IAAIlI,OACxB,KAAOqI,EAAQF,IAAMzE,GAAK,CACxB,MAAMgF,EAAIL,EAAQH,IAAIG,EAAQF,OAI9B,GAFArB,IAAa4B,EAAI,GAAgBD,EACjCA,GAAQ,IACJC,EAAI,EACN,OAAO5B,EAGT,GAAIA,EAAM,EACR,MAAMkB,EAGV,CACA,MAAMD,IC5PK,GAAQ3C,KAAKD,MCcb,IDbOC,KAAKE,KACNF,KAAKG,IACJH,KAAKI,KACJJ,KAAKK,MACLL,KAAKM,MACNN,KAAKO,KACNP,KAAKjI,IACJiI,KAAKQ,KA0BJG,OAAOC,MAETZ,KAAKU,IASJV,KAAKc,KC/BL,KAsCP,GAAQ,IClDR,GAAerH,OAAOD,aAsDtB,IArDgBC,OAAOE,cAMD,GAAa,OA+CkC,oBAAhBU,YAA8B,IAAIA,YAAgB,MAavG,GAAa,GAPOkJ,GAAO,GAAgBC,OAAOD,GAjB5BA,IACjC,MAAME,EAAgBC,SAASC,mBAAmBJ,IAC5CjF,EAAMmF,EAAc7I,OACpB4D,EAAM,IAAI7D,WAAW2D,GAC3B,IAAK,IAAI/B,EAAI,EAAGA,EAAI+B,EAAK/B,IACvBiC,EAAIjC,GAA4BkH,EAAcG,YAAYrH,GAE5D,OAAOiC,GAuCF,IAAI,GAAyC,oBAAhBjE,YAA8B,KAAO,IAAIA,YAAY,QAAS,CAAEC,OAAO,EAAMC,WAAW,IAGxH,IAAuE,IAApD,GAAgBC,OAAO,IAAIC,YAAcC,SAO9D,GAAkB,MCtEb,MAAM,GACX,WAAAlD,GACEG,KAAKoJ,KAAO,EACZpJ,KAAKqJ,KAAO,IAAIvG,WAAW,KAI3B9C,KAAKsJ,KAAO,EACd,EAOK,MA6EM,GAAQ,CAACE,EAASK,KAC7B,MAAMC,EAAYN,EAAQH,KAAKtG,OAC3ByG,EAAQJ,OAASU,IACnBN,EAAQF,KAAK1E,KAAK4E,EAAQH,MAC1BG,EAAQH,KAAO,IAAIvG,WAAuB,EAAZgH,GAC9BN,EAAQJ,KAAO,GAEjBI,EAAQH,KAAKG,EAAQJ,QAAUS,GA2HpB,GAAe,CAACL,EAASK,KACpC,KAAOA,EAAM,IACX,GAAML,EAAS,GAAe,GAAeK,GAC7CA,EAAM,GAAWA,EAAM,KAEzB,GAAML,EAAS,GAAeK,IA+B1B,GAAa,IAAI/G,WAAW,KAC5B,GAAe,GAAWC,OAAS,EA+C5B,GAAkB,IAA6C,GAAyBkH,WAtChE,CAACT,EAASkC,KAC7C,GAAIA,EAAI3I,OAAS,GAAc,CAG7B,MAAMiJ,EAAU,GAAuB/B,WAAWyB,EAAK,IAAYM,SAAW,EAC9E,GAAaxC,EAASwC,GACtB,IAAK,IAAItH,EAAI,EAAGA,EAAIsH,EAAStH,IAC3B,GAAM8E,EAAS,GAAW9E,GAE9B,MACE,GAAmB8E,EAAS,GAAkBkC,KAWX,CAAClC,EAASkC,KAC/C,MAAME,EAAgBC,SAASC,mBAAmBJ,IAC5CjF,EAAMmF,EAAc7I,OAC1B,GAAayG,EAAS/C,GACtB,IAAK,IAAI/B,EAAI,EAAGA,EAAI+B,EAAK/B,IACvB,GAAM8E,EAAgCoC,EAAcG,YAAYrH,KAsGvD,GAAqB,CAAC8E,EAASU,KAC1C,GAAaV,EAASU,EAAWhE,YA3BJ,EAACsD,EAASU,KACvC,MAAMJ,EAAYN,EAAQH,KAAKtG,OACzBqG,EAAOI,EAAQJ,KACfe,GH5XY7L,EG4XWwL,EAAYV,IH5XpBR,EG4X0BsB,EAAWnH,QH5XvBzE,EAAIsK,EAAtB,IAACtK,EAAGsK,EG6XrB,MAAMwB,EAAeF,EAAWnH,OAASoH,EACzCX,EAAQH,KAAK7H,IAAI0I,EAAWG,SAAS,EAAGF,GAAcf,GACtDI,EAAQJ,MAAQe,EACZC,EAAe,IAGjBZ,EAAQF,KAAK1E,KAAK4E,EAAQH,MAE1BG,EAAQH,KAAO,IAAIvG,WH7XJ,EAACxE,EAAGsK,IAAMtK,EAAIsK,EAAItK,EAAIsK,EG6XP,CAAqB,EAAZkB,EAAeM,IAEtDZ,EAAQH,KAAK7H,IAAI0I,EAAWG,SAASF,IACrCX,EAAQJ,KAAOgB,IAajB,CAAgBZ,EAASU,IAmDN,IAAIK,SAAS,IAAIC,YAAY,IC7d3C,MAAM,GAAmB1B,OAAO2B,iBCE1B,IDDmB3B,OAAO4B,iBAOd5B,OAAO6B,UACX7B,OAAOC,MACJD,OAAO8B,SCRT3I,GAAK,IAAI4I,MAAM5I,ICwB/B,GAA4B,GAAa,2BACzC,GAAyB,GAAa,wBAKrC,MAAM,GAIX,WAAApC,CAAaqK,GAMXlK,KAAKiL,IAAMf,EAMXlK,KAAKkL,IAAM,CACb,EAQK,MAmDM,GAAoBE,GAhBH,EAACA,EAAS3E,KACtC,MAAM4E,EAAO,IAAIvI,WAAWsI,EAAQH,IAAI5E,OAAQ+E,EAAQF,IAAME,EAAQH,IAAI3E,WAAYG,GAEtF,OADA2E,EAAQF,KAAOzE,EACR4E,GAamC,CAAeD,EAAS,GAAYA,IAwBnE,GAAYA,GAAWA,EAAQH,IAAIG,EAAQF,OAmG3C,GAAcE,IACzB,IAAIvB,EAAM,EACN2B,EAAO,EACX,MAAM/E,EAAM2E,EAAQH,IAAIlI,OACxB,KAAOqI,EAAQF,IAAMzE,GAAK,CACxB,MAAMgF,EAAIL,EAAQH,IAAIG,EAAQF,OAI9B,GAFArB,IAAa4B,EAAI,IAAgBD,EACjCA,GAAQ,IACJC,EAAI,GACN,OAAO5B,EAGT,GAAIA,EAAM,GACR,MAAM,EAGV,CACA,MAAM,IA+HK,GAAgB,GAbOuB,GACjB,GAAyBvI,OAAO,GAAkBuI,IAhC/BA,IACpC,IAAIa,EAAe,GAAYb,GAC/B,GAAqB,IAAjBa,EACF,MAAO,GACF,CACL,IAAIL,EAAgBhK,OAAOE,cAAc,GAAUsJ,IACnD,KAAMa,EAAe,IACnB,KAAOA,KACLL,GAAiBhK,OAAOE,cAAc,GAAUsJ,SAGlD,KAAOa,EAAe,GAAG,CACvB,MAAMC,EAAUD,EAAe,IAAQA,EAAe,IAEhDhG,EAAQmF,EAAQH,IAAIZ,SAASe,EAAQF,IAAKE,EAAQF,IAAMgB,GAC9Dd,EAAQF,KAAOgB,EAEfN,GAAiBhK,OAAOE,cAAcqK,MAAM,KAAyB,GACrEF,GAAgBC,CAClB,CAEF,OAAOE,mBAAmBC,OAAOT,GACnC,GC5TWU,GAAiB,CAAC9C,EAAS+C,KACtC,GAAsB/C,EAXW,GAYjC,MAAMgD,EAAK,oBAAoBD,GAC/B,GAA4B/C,EAASgD,IAQ1BC,GAAiB,CAACjD,EAAS+C,EAAKG,KAC3C,GAAsBlD,EArBW,GAsBjC,GAA4BA,EAAS,sBAAsB+C,EAAKG,KAoBrDC,GAAgB,CAACvB,EAASmB,EAAKK,KAC1C,IACE,cAAcL,EAAK,GAA2BnB,GAAUwB,EAC1D,CAAE,MAAOhM,GAEPN,QAAQM,MAAM,2CAA4CA,EAC5D,GAmBWiM,GAAaF,GCpFb,GAAc3E,KAAKC,ICPnB,GAAS,IAAM,IAAI7G,ICRnB,GAAS,IAAM,IAAIM,IC6CnB,GAAO8B,MAAMC,KA+EHD,MAAMG,QClCtB,MAAMmJ,GACX,WAAAjN,GAKEG,KAAK+M,WAAa,IACpB,CAMA,EAAAC,CAAIjJ,EAAMkJ,GH/DkB,EAAC3L,EAAK7C,EAAK8C,KACvC,IAAIC,EAAMF,EAAIxC,IAAIL,GAIlB,YAHYgD,IAARD,GACFF,EAAIE,IAAI/C,EAAK+C,EAAMD,KAEdC,GG2DL,CAAmBxB,KAAK+M,WAAYhJ,EAAM,IAAYmJ,IAAID,EAC5D,CAMA,IAAAE,CAAMpJ,EAAMkJ,GAIV,MAAMG,EAAK,IAAIhN,KACbJ,KAAKqN,IAAItJ,EAAMqJ,GACfH,KAAK7M,IAEPJ,KAAKgN,GAAGjJ,EAAMqJ,EAChB,CAMA,GAAAC,CAAKtJ,EAAMkJ,GACT,MAAMK,EAAYtN,KAAK+M,WAAWjO,IAAIiF,QACpBtC,IAAd6L,IACFA,EAAUC,OAAON,GACM,IAAnBK,EAAUE,MACZxN,KAAK+M,WAAWQ,OAAOxJ,GAG7B,CAWA,IAAA0J,CAAM1J,EAAM3D,GAEV,OAAO,IAAYJ,KAAK+M,WAAWjO,IAAIiF,IAAS,MAAc2J,UAAUzI,QAAQgI,GAAKA,KAAK7M,GAC5F,CAEA,OAAAuN,GACE3N,KAAK+M,WAAa,IACpB,EChJoBpO,OAAOiP,OALtB,MAUMC,GAAOlP,OAAOkP,KAyCd,IAlCSlP,OAAO+O,OAkCP3O,GAAO8O,GAAK9O,GAAKgE,QAwD1B+K,GAAc,CAAC/O,EAAKN,IAAQE,OAAOM,UAAUC,eAAeC,KAAKJ,EAAKN,GCpHtEsP,IDiISpP,OAAOqP,OCjIMC,OAAO,aCsE7B,GAAe,CAAC3P,EAAGsK,KAC9B,GAAItK,IAAMsK,EACR,OAAO,EAET,GAAS,MAALtK,GAAkB,MAALsK,GAAatK,EAAEuB,cAAgB+I,EAAE/I,YAChD,OAAO,EAET,GAAqC,MAAjCvB,EAAE,IACJ,OAAOA,EAAE,IAA4BsK,GAEvC,OAAQtK,EAAEuB,aACR,KAAK2K,YACHlM,EAAI,IAAIwE,WAAWxE,GACnBsK,EAAI,IAAI9F,WAAW8F,GAErB,KAAK9F,WACH,GAAIxE,EAAE4H,aAAe0C,EAAE1C,WACrB,OAAO,EAET,IAAK,IAAIxB,EAAI,EAAGA,EAAIpG,EAAEyE,OAAQ2B,IAC5B,GAAIpG,EAAEoG,KAAOkE,EAAElE,GACb,OAAO,EAGX,MAEF,KAAKhD,IACH,GAAIpD,EAAEkP,OAAS5E,EAAE4E,KACf,OAAO,EAET,IAAK,MAAMrI,KAAS7G,EAClB,IAAKsK,EAAEvD,IAAIF,GACT,OAAO,EAGX,MAEF,KAAK/D,IACH,GAAI9C,EAAEkP,OAAS5E,EAAE4E,KACf,OAAO,EAET,IAAK,MAAM/O,KAAOH,EAAEuP,OAClB,IAAKjF,EAAEvD,IAAI5G,KAAS,GAAaH,EAAEQ,IAAIL,GAAMmK,EAAE9J,IAAIL,IACjD,OAAO,EAGX,MAEF,KAAKE,OACH,GAAI,GAAcL,KAAO,GAAcsK,GACrC,OAAO,EAET,IAAK,MAAMnK,KAAOH,EAChB,IAAK,GAAmBA,EAAGG,KAAS,GAAaH,EAAEG,GAAMmK,EAAEnK,IACzD,OAAO,EAGX,MACF,KAAK+E,MACH,GAAIlF,EAAEyE,SAAW6F,EAAE7F,OACjB,OAAO,EAET,IAAK,IAAI2B,EAAI,EAAGA,EAAIpG,EAAEyE,OAAQ2B,IAC5B,IAAK,GAAapG,EAAEoG,GAAIkE,EAAElE,IACxB,OAAO,EAGX,MACF,QACE,OAAO,EAEX,OAAO,GCvGF,MAAMwJ,WAAkBpB,GAI7B,WAAAjN,CAAa0M,GACX4B,QACAnO,KAAKuM,IAAMA,EAIXvM,KAAKoO,SAAW7B,EAAI6B,SAKpBpO,KAAKqO,OAAS,IAAIjN,IAIlBpB,KAAKsO,KAAO,IAAIlN,IAChBpB,KAAKuO,eAAqCC,YAAY,KACpD,MAAMvG,EAAM,KACiB,OAAzBjI,KAAKyO,iBAA6BC,MAAuBzG,EAA2CjI,KAAKsO,KAAKxP,IAAIkB,KAAKoO,UAAWO,aAEpI3O,KAAK4O,cAAc5O,KAAKyO,iBAK1B,MAAMI,EAAS,GACf7O,KAAKsO,KAAKrJ,QAAQ,CAACqJ,EAAMQ,KACnBA,IAAa9O,KAAKoO,UAzDC,KAyD8BnG,EAAMqG,EAAKK,aAAe3O,KAAKqO,OAAOhJ,IAAIyJ,IAC7FD,EAAOjK,KAAKkK,KAGZD,EAAO9L,OAAS,GAClBgM,GAAsB/O,KAAM6O,EAAQ,YAErC,GAAWH,MACdnC,EAAIS,GAAG,UAAW,KAChBhN,KAAK2N,YAEP3N,KAAK4O,cAAc,CAAC,EACtB,CAEA,OAAAjB,GACE3N,KAAKyN,KAAK,UAAW,CAACzN,OACtBA,KAAK4O,cAAc,MACnBT,MAAMR,UACNqB,cAAchP,KAAKuO,eACrB,CAKA,aAAAE,GACE,OAAOzO,KAAKqO,OAAOvP,IAAIkB,KAAKoO,WAAa,IAC3C,CAKA,aAAAQ,CAAeK,GACb,MAAMb,EAAWpO,KAAKoO,SAChBc,EAAgBlP,KAAKsO,KAAKxP,IAAIsP,GAC9Be,OAA0B1N,IAAlByN,EAA8B,EAAIA,EAAcC,MAAQ,EAChEC,EAAYpP,KAAKqO,OAAOvP,IAAIsP,GACpB,OAAVa,EACFjP,KAAKqO,OAAOd,OAAOa,GAEnBpO,KAAKqO,OAAO7M,IAAI4M,EAAUa,GAE5BjP,KAAKsO,KAAK9M,IAAI4M,EAAU,CACtBe,QACAR,YAAa,OAEf,MAAMU,EAAQ,GACRC,EAAU,GACVC,EAAkB,GAClBC,EAAU,GACF,OAAVP,EACFO,EAAQ5K,KAAKwJ,GACS,MAAbgB,EACI,MAATH,GACFI,EAAMzK,KAAKwJ,IAGbkB,EAAQ1K,KAAKwJ,GACR,GAAegB,EAAWH,IAC7BM,EAAgB3K,KAAKwJ,KAGrBiB,EAAMtM,OAAS,GAAKwM,EAAgBxM,OAAS,GAAKyM,EAAQzM,OAAS,IACrE/C,KAAKyN,KAAK,SAAU,CAAC,CAAE4B,QAAOC,QAASC,EAAiBC,WAAW,UAErExP,KAAKyN,KAAK,SAAU,CAAC,CAAE4B,QAAOC,UAASE,WAAW,SACpD,CAMA,kBAAAC,CAAoBC,EAAOvK,GACzB,MAAM8J,EAAQjP,KAAKyO,gBACL,OAAVQ,GACFjP,KAAK4O,cAAc,IACdK,EACH,CAACS,GAAQvK,GAGf,CAKA,SAAAwK,GACE,OAAO3P,KAAKqO,MACd,EAWK,MAAMU,GAAwB,CAACa,EAAWC,EAAShI,KACxD,MAAM2H,EAAU,GAChB,IAAK,IAAI9K,EAAI,EAAGA,EAAImL,EAAQ9M,OAAQ2B,IAAK,CACvC,MAAM0J,EAAWyB,EAAQnL,GACzB,GAAIkL,EAAUvB,OAAOhJ,IAAI+I,GAAW,CAElC,GADAwB,EAAUvB,OAAOd,OAAOa,GACpBA,IAAawB,EAAUxB,SAAU,CACnC,MAAM0B,EAA0CF,EAAUtB,KAAKxP,IAAIsP,GACnEwB,EAAUtB,KAAK9M,IAAI4M,EAAU,CAC3Be,MAAOW,EAAQX,MAAQ,EACvBR,YAAa,MAEjB,CACAa,EAAQ5K,KAAKwJ,EACf,CACF,CACIoB,EAAQzM,OAAS,IACnB6M,EAAUnC,KAAK,SAAU,CAAC,CAAE4B,MAAO,GAAIC,QAAS,GAAIE,WAAW3H,IAC/D+H,EAAUnC,KAAK,SAAU,CAAC,CAAE4B,MAAO,GAAIC,QAAS,GAAIE,WAAW3H,MAStDkI,GAAwB,CAACH,EAAWC,EAASxB,EAASuB,EAAUvB,UAC3E,MAAM5H,EAAMoJ,EAAQ9M,OACdyG,Eb/I2B,IAAI,GagJrC,GAAsBA,EAAS/C,GAC/B,IAAK,IAAI/B,EAAI,EAAGA,EAAI+B,EAAK/B,IAAK,CAC5B,MAAM0J,EAAWyB,EAAQnL,GACnBuK,EAAQZ,EAAOvP,IAAIsP,IAAa,KAChCe,EAAwCS,EAAUtB,KAAKxP,IAAIsP,GAAWe,MAC5E,GAAsB3F,EAAS4E,GAC/B,GAAsB5E,EAAS2F,GAC/B,GAAwB3F,EAASwG,KAAKC,UAAUhB,GAClD,CACA,Mb/G0BzF,KAC1B,MAAME,EAAW,IAAI5G,WAzBD0G,KACpB,IAAI/C,EAAM+C,EAAQJ,KAClB,IAAK,IAAI1E,EAAI,EAAGA,EAAI8E,EAAQF,KAAKvG,OAAQ2B,IACvC+B,GAAO+C,EAAQF,KAAK5E,GAAG3B,OAEzB,OAAO0D,GAoByB,CAAO+C,IACvC,IAAIG,EAAS,EACb,IAAK,IAAIjF,EAAI,EAAGA,EAAI8E,EAAQF,KAAKvG,OAAQ2B,IAAK,CAC5C,MAAMrG,EAAImL,EAAQF,KAAK5E,GACvBgF,EAASlI,IAAInD,EAAGsL,GAChBA,GAAUtL,EAAE0E,MACd,CAEA,OADA2G,EAASlI,IAAI,IAAIsB,WAAW0G,EAAQH,KAAKhD,OAAQ,EAAGmD,EAAQJ,MAAOO,GAC5DD,GasGA,CAAsBF,IC1LxB,MAAM,GACX,WAAA3J,GAKEG,KAAK+M,WAAa,GACpB,CAOA,EAAAC,CAAIjJ,EAAMkJ,GAER,OADA,EAAmBjN,KAAK+M,WAAkC,EAAQ,GAAYG,IAAID,GAC3EA,CACT,CAOA,IAAAE,CAAMpJ,EAAMkJ,GAIV,MAAMG,EAAK,IAAIhN,KACbJ,KAAKqN,IAAItJ,EAAyB,GAClCkJ,KAAK7M,IAEPJ,KAAKgN,GAAGjJ,EAAyB,EACnC,CAOA,GAAAsJ,CAAKtJ,EAAMkJ,GACT,MAAMK,EAAYtN,KAAK+M,WAAWjO,IAAIiF,QACpBtC,IAAd6L,IACFA,EAAUC,OAAON,GACM,IAAnBK,EAAUE,MACZxN,KAAK+M,WAAWQ,OAAOxJ,GAG7B,CAYA,IAAA0J,CAAM1J,EAAM3D,GAEV,OAAO,GAAYJ,KAAK+M,WAAWjO,IAAIiF,IAAS,KAAc2J,UAAUzI,QAAQgI,GAAKA,KAAK7M,GAC5F,CAEA,OAAAuN,GACE3N,KAAK+M,WAAa,GACpB,ECxEoBpO,OAAOiP,OAKTjP,OAAOkP,KAOLlP,OAAO+O,OAuGP/O,OAAOqP,OAxHtB,MCmBDkC,GAAkB,GAExBA,GAX2B,GAWI,CAC7B1G,EACA4B,EACA+E,EACAC,EACAC,KAEA,EAAsB7G,EAlBG,GAmBzB,MAAM8G,EZ2EuB,EAAClF,EAAS5B,EAAS+C,EAAKK,KACrD,MAAM2D,EAAc,GAAqBnF,GACzC,OAAQmF,GACN,KA/E+B,EAiCN,EAACnF,EAAS5B,EAAS+C,KAC9CE,GAAejD,EAAS+C,EAAK,GAA2BnB,KA8CpDoF,CAAcpF,EAAS5B,EAAS+C,GAChC,MACF,KAjF+B,EAkF7BI,GAAcvB,EAASmB,EAAKK,GAC5B,MACF,KAnF4B,EAoF1BC,GAAWzB,EAASmB,EAAKK,GACzB,MACF,QACE,MAAM,IAAI/B,MAAM,wBAEpB,OAAO0F,GY1FiB,CACtBnF,EACA5B,EACA2G,EAAS5D,IACT4D,GAGAC,GZP+B,IYOjBE,IACbH,EAASM,SAEVN,EAASM,QAAS,IAItBP,GAhCqC,GAgCI,CACvC1G,EACAkH,EACAP,EACAQ,EACAN,KAEA,EAAsB7G,EAtCQ,GAuC9B,EACEA,EACA,GACE2G,EAASP,UACTpM,MAAMC,KAAK0M,EAASP,UAAUD,YAAY9B,WAKhDqC,GAhDgC,GAgDI,CAClCU,EACAxF,EACA+E,EACAQ,EACAN,KHsKkC,EAACT,EAAWiB,EAAQhJ,KACtD,MAAMuD,EV/KmC,IAAI,GU+KNyF,GACjCC,EAAY,KACZzB,EAAQ,GACRC,EAAU,GACVC,EAAkB,GAClBC,EAAU,GACV/I,EAAM,GAAqB2E,GACjC,IAAK,IAAI1G,EAAI,EAAGA,EAAI+B,EAAK/B,IAAK,CAC5B,MAAM0J,EAAW,GAAqBhD,GACtC,IAAI+D,EAAQ,GAAqB/D,GACjC,MAAM6D,EAAQe,KAAKe,MAAM,GAAuB3F,IAC1C4F,EAAapB,EAAUtB,KAAKxP,IAAIsP,GAChCgB,EAAYQ,EAAUvB,OAAOvP,IAAIsP,GACjC6C,OAA2BxP,IAAfuP,EAA2B,EAAIA,EAAW7B,OACxD8B,EAAY9B,GAAU8B,IAAc9B,GAAmB,OAAVF,GAAkBW,EAAUvB,OAAOhJ,IAAI+I,MACxE,OAAVa,EAEEb,IAAawB,EAAUxB,UAAyC,MAA7BwB,EAAUnB,gBAG/CU,IAEAS,EAAUvB,OAAOd,OAAOa,GAG1BwB,EAAUvB,OAAO7M,IAAI4M,EAAUa,GAEjCW,EAAUtB,KAAK9M,IAAI4M,EAAU,CAC3Be,QACAR,YAAamC,SAEIrP,IAAfuP,GAAsC,OAAV/B,EAC9BI,EAAMzK,KAAKwJ,QACa3M,IAAfuP,GAAsC,OAAV/B,EACrCO,EAAQ5K,KAAKwJ,GACM,OAAVa,IACJ,GAAeA,EAAOG,IACzBG,EAAgB3K,KAAKwJ,GAEvBkB,EAAQ1K,KAAKwJ,IAGnB,EACIiB,EAAMtM,OAAS,GAAKwM,EAAgBxM,OAAS,GAAKyM,EAAQzM,OAAS,IACrE6M,EAAUnC,KAAK,SAAU,CAAC,CACxB4B,QAAOC,QAASC,EAAiBC,WAChC3H,KAEDwH,EAAMtM,OAAS,GAAKuM,EAAQvM,OAAS,GAAKyM,EAAQzM,OAAS,IAC7D6M,EAAUnC,KAAK,SAAU,CAAC,CACxB4B,QAAOC,UAASE,WACf3H,KGxNL,CACEsI,EAASP,UACT,GAA2BxE,GAC3B+E,IAIJD,GA7D2B,GA6DI,CAC7BU,EACAxF,EACA+E,EACAQ,EACAN,KC5D6B,EAACjF,EAAS8F,EAAGC,KAvBL,IAwB7B,GAAqB/F,IACG+F,EAAwBD,EAAG,GAAuB9F,KD4DlF,CACEA,EACA+E,EAAS5D,IACT,CAAC6E,EAAOC,IAAWF,GAAwBhB,EAAUkB,KAKzD,MAMMF,GAA0B,CAAChB,EAAUkB,IACzC/Q,QAAQK,KAAK,+BAA+BwP,EAASmB,SAASD,KAQ1DE,GAAc,CAACpB,EAAUxJ,EAAKyJ,KAClC,MAAMhF,EpBhDmC,IAAIJ,GoBgDNrE,GACjC6C,EAAU,IACV+G,EAAc,GAAqBnF,GACnCoG,EAAiBrB,EAASD,gBAAgBK,GAMhD,OALuB,EACrBiB,EAAehI,EAAS4B,EAAS+E,EAAUC,EAAYG,GAEvDjQ,QAAQM,MAAM,6BAET4I,GAWHiI,GAA2B,CAACtB,EAAUuB,EAAIC,KAC1CD,IAAOvB,EAASuB,KAClBvB,EAAS1C,KAAK,mBAAoB,CAACkE,EAAOxB,IAC1CA,EAASuB,GAAK,KACdA,EAAGpK,QACH6I,EAASyB,cAAe,EACpBzB,EAAS0B,aACX1B,EAAS0B,aAAc,EACvB1B,EAASM,QAAS,EAElB,GACEN,EAASP,UACTpM,MAAMC,KAAK0M,EAASP,UAAUD,YAAY9B,QAAQiE,OAAQC,GACxDA,IAAW5B,EAAS5D,IAAI6B,UAE1B+B,GAEFA,EAAS1C,KAAK,SAAU,CAAC,CACvBuE,OAAQ,mBAGV7B,EAAS8B,2BAIXC,WACEC,GACA,EACmD,IAAjD,EAAS,EAAGhC,EAAS8B,0BACrB9B,EAASiC,gBAEXjC,KAQAgC,GAAWhC,IACf,GAAIA,EAASkC,eAAiC,OAAhBlC,EAASuB,GAAa,CAClD,MAAMY,EAAY,IAAInC,EAASoC,IAAIpC,EAASmB,IAAKnB,EAASqC,WAC1DF,EAAUG,WAAa,cACvBtC,EAASuB,GAAKY,EACdnC,EAASyB,cAAe,EACxBzB,EAAS0B,aAAc,EACvB1B,EAASM,QAAS,EAElB6B,EAAUrL,UAAa0K,IACrBxB,EAASuC,sBAAwB,IACjC,MAAMlJ,EAAU+H,GAAYpB,EAAU,IAAIrN,WAAW6O,EAAMxK,OAAO,GAC9D,EAAgBqC,GAAW,GAC7B8I,EAAUK,KAAK,EAAsBnJ,KAGzC8I,EAAUM,QAAWjB,IACnBxB,EAAS1C,KAAK,mBAAoB,CAACkE,EAAOxB,KAE5CmC,EAAUO,QAAWlB,IACnBF,GAAyBtB,EAAUmC,EAAWX,IAEhDW,EAAUQ,OAAS,KACjB3C,EAASuC,sBAAwB,IACjCvC,EAASyB,cAAe,EACxBzB,EAAS0B,aAAc,EACvB1B,EAAS8B,yBAA2B,EACpC9B,EAAS1C,KAAK,SAAU,CAAC,CACvBuE,OAAQ,eAGV,MAAMxI,EAAU,IAKhB,GAJA,EAAsBA,EA1LD,GA2LrB,GAA4BA,EAAS2G,EAAS5D,KAC9C+F,EAAUK,KAAK,EAAsBnJ,IAEM,OAAvC2G,EAASP,UAAUnB,gBAA0B,CAC/C,MAAMsE,EAAwB,IAC9B,EAAsBA,EA9LE,GA+LxB,EACEA,EACA,GAAwC5C,EAASP,UAAW,CAC1DO,EAAS5D,IAAI6B,YAGjBkE,EAAUK,KAAK,EAAsBI,GACvC,GAEF5C,EAAS1C,KAAK,SAAU,CAAC,CACvBuE,OAAQ,eAEZ,GAOIgB,GAAmB,CAAC7C,EAAUxJ,KAClC,MAAM+K,EAAKvB,EAASuB,GAChBvB,EAAS0B,aAAeH,GAAMA,EAAGuB,aAAevB,EAAGwB,MACrDxB,EAAGiB,KAAKhM,GAENwJ,EAASgD,aACX,EAAWhD,EAASiD,UAAWzM,EAAKwJ,IAiBjC,MAAMkD,WAA0B,GAerC,WAAAxT,CAAayT,EAAWC,EAAUhH,GAAK,QACrCiH,GAAU,EAAI,UACd5D,EAAY,IAAI,GAA4BrD,GAAI,OAChDpI,EAAS,CAAC,EAAC,UACXqO,EAAY,GAAE,kBACdiB,EAAoBC,UAAS,eAC7BC,GAAiB,EAAE,eACnBvB,EAAiB,KAAI,UACrBwB,GAAY,GACV,CAAC,GAGH,IAFAzF,QAE2C,MAApCmF,EAAUA,EAAUvQ,OAAS,IAClCuQ,EAAYA,EAAUvO,MAAM,EAAGuO,EAAUvQ,OAAS,GAEpD/C,KAAKsT,UAAYA,EACjBtT,KAAKoT,UAAYE,EAAY,IAAMC,EACnCvT,KAAKoS,eAAiBA,EAMtBpS,KAAKmE,OAASA,EACdnE,KAAKwS,UAAYA,EACjBxS,KAAKuT,SAAWA,EAChBvT,KAAKuM,IAAMA,EACXvM,KAAKuS,IAAMkB,EACXzT,KAAK4P,UAAYA,EACjB5P,KAAK6R,aAAc,EACnB7R,KAAK4R,cAAe,EACpB5R,KAAKmT,aAAc,EACnBnT,KAAK4T,UAAYA,EACjB5T,KAAKiS,yBAA2B,EAChCjS,KAAKkQ,gBAAkBA,GAAgBnL,QAIvC/E,KAAK6T,SAAU,EAIf7T,KAAK0R,GAAK,KACV1R,KAAK0S,sBAAwB,EAK7B1S,KAAKqS,cAAgBmB,EAKrBxT,KAAK8T,gBAAkB,EACnBH,EAAiB,IACnB3T,KAAK8T,gBAAsCtF,YAAY,KACrD,GAAIxO,KAAK0R,IAAM1R,KAAK0R,GAAGuB,aAAeS,UAAUR,KAAM,CAEpD,MAAM1J,EAAU,IAChB,EAAsBA,EArTL,GAsTjB,GAA4BA,EAAS+C,GACrCvM,KAAK0R,GAAGiB,KAAK,EAAsBnJ,GACrC,GACCmK,IAOL3T,KAAK+T,cAAgB,CAAC5M,EAAMU,KAC1B,GAAIA,IAAW7H,KAAM,CACnB,MAAMwJ,EAAU+H,GAAYvR,KAAM,IAAI8C,WAAWqE,IAAO,GACpD,EAAgBqC,GAAW,GAC7B,EAAWxJ,KAAKoT,UAAW,EAAsB5J,GAAUxJ,KAE/D,GAOFA,KAAKgU,eAAiB,CAACnD,EAAQhJ,KAC7B,GAAIA,IAAW7H,KAAM,CACnB,MAAMwJ,EAAU,IAChB,EAAsBA,EAhVH,GZ0EA,EAACA,EAASqH,KACnC,GAAsBrH,EAvDQ,GAwD9B,GAA4BA,EAASqH,IYqQ/B,CAAyBrH,EAASqH,GAClCmC,GAAiBhT,KAAM,EAAsBwJ,GAC/C,GAEFxJ,KAAKuM,IAAIS,GAAG,SAAUhN,KAAKgU,gBAK3BhU,KAAKiU,wBAA0B,EAAG5E,QAAOC,UAASE,WAAW0E,KAC3D,MAAMC,EAAiB9E,EAAM+E,OAAO9E,GAAS8E,OAAO5E,GAC9ChG,EAAU,IAChB,EAAsBA,EA3VI,GA4V1B,EACEA,EACA,GAAwCoG,EAAWuE,IAErDnB,GAAiBhT,KAAM,EAAsBwJ,KAE/CxJ,KAAKqU,aAAe,KAClB,GACErU,KAAK4P,UACL,CAACrD,EAAI6B,UACL,eAGA,GAAiC,oBAAZxK,SACvBA,QAAQoJ,GAAG,OAAQhN,KAAKqU,cAE1BzE,EAAU5C,GAAG,SAAUhN,KAAKiU,yBAC5BjU,KAAKuO,eAAqCC,YAAY,KAElDxO,KAAK6R,aAlSmB,IAoStB,IAAqB7R,KAAK0S,uBAI5BjB,GAAyBzR,KAAgCA,KAAO,GAAG,OAEpEsU,KACCd,GACFxT,KAAKwT,SAET,CAEA,OAAIlC,GACF,MAAMiD,EEhXuBpQ,KHYd,EAACpF,EAAKkO,KACvB,MAAMuH,EAAU,GAChB,IAAK,MAAM/V,KAAOM,EAChByV,EAAQ5P,KAAKqI,EAAElO,EAAIN,GAAMA,IAE3B,OAAO+V,GGhBP,CF+W8CxU,KAAKmE,OE/WhC,CAACsQ,EAAKhW,IAAQ,GAAGqN,mBAAmBrN,MAAQqN,mBAAmB2I,MAAQC,KAAK,KF+WvE,GACtB,OAAO1U,KAAKsT,UAAY,IAAMtT,KAAKuT,UACP,IAAzBgB,EAAcxR,OAAe,GAAK,IAAMwR,EAC7C,CAKA,UAAI9D,GACF,OAAOzQ,KAAK6T,OACd,CAEA,UAAIpD,CAAQxB,GACNjP,KAAK6T,UAAY5E,IACnBjP,KAAK6T,QAAU5E,EAEfjP,KAAKyN,KAAK,SAAU,CAACwB,IACrBjP,KAAKyN,KAAK,OAAQ,CAACwB,IAEvB,CAEA,OAAAtB,GAC+B,IAAzB3N,KAAK8T,iBACP9E,cAAchP,KAAK8T,iBAErB9E,cAAchP,KAAKuO,gBACnBvO,KAAK2U,aACD,GAAiC,oBAAZ/Q,SACvBA,QAAQyJ,IAAI,OAAQrN,KAAKqU,cAE3BrU,KAAK4P,UAAUvC,IAAI,SAAUrN,KAAKiU,yBAClCjU,KAAKuM,IAAIc,IAAI,SAAUrN,KAAKgU,gBAC5B7F,MAAMR,SACR,CAEA,SAAAiH,GACE,GAAI5U,KAAK4T,UACP,O3BzVmB,IAAC7M,EAAMkG,E2B2VvBjN,KAAKmT,c3B3VYpM,E2B4VP/G,KAAKoT,U3B5VQnG,E2B4VGjN,KAAK+T,c3B3VtCvM,EAAWT,GAAMU,KAAKyF,IAAID,G2B4VtBjN,KAAKmT,aAAc,GAIrB,MAAM0B,EAAc,IACpB,EAAsBA,EA9aC,GA+avB,GAA4BA,EAAa7U,KAAKuM,KAC9C,EAAWvM,KAAKoT,UAAW,EAAsByB,GAAc7U,MAE/D,MAAM8U,EAAe,IACrB,EAAsBA,EAnbC,GAobvB,GAA4BA,EAAc9U,KAAKuM,KAC/C,EAAWvM,KAAKoT,UAAW,EAAsB0B,GAAe9U,MAEhE,MAAM+U,EAAwB,IAC9B,EAAsBA,EAvbW,GAwbjC,EACE/U,KAAKoT,UACL,EAAsB2B,GACtB/U,MAGF,MAAM+S,EAAwB,IAC9B,EAAsBA,EA9bM,GA+b5B,EACEA,EACA,GAAwC/S,KAAK4P,UAAW,CACtD5P,KAAKuM,IAAI6B,YAGb,EACEpO,KAAKoT,UACL,EAAsBL,GACtB/S,KAEJ,CAEA,YAAAgV,GAEE,MAAMxL,EAAU,IAChB,EAAsBA,EA/cM,GAgd5B,EACEA,EACA,GAAwCxJ,KAAK4P,UAAW,CACtD5P,KAAKuM,IAAI6B,UACR,IAAIhN,MAET4R,GAAiBhT,KAAM,EAAsBwJ,IACzCxJ,KAAKmT,c3BjYc,EAACpM,EAAMkG,KAChC,MAAMgI,EAAUzN,EAAWT,GACNkO,EAAQxN,KAAK8F,OAAON,IACC,IAAtBgI,EAAQxN,KAAK+F,OAC/ByH,EAAQvN,GAAGJ,QACXV,EAAS2G,OAAOxG,K2B6Xd,CAAe/G,KAAKoT,UAAWpT,KAAK+T,eACpC/T,KAAKmT,aAAc,EAEvB,CAEA,UAAAwB,GACE3U,KAAKqS,eAAgB,EACrBrS,KAAKgV,eACW,OAAZhV,KAAK0R,IACPD,GAAyBzR,KAAMA,KAAK0R,GAAI,KAE5C,CAEA,OAAA8B,GACExT,KAAKqS,eAAgB,EAChBrS,KAAK6R,aAA2B,OAAZ7R,KAAK0R,KAC5BS,GAAQnS,MACRA,KAAK4U,YAET,EG7fI,SAAUM,GAAiBtU,EAAgBuU,GAChD,OAAKvU,aAAiBiK,MACdjK,EAAMwU,QAKbxU,GACiB,iBAAVA,GACP,SAAUA,GACVA,EAAMuG,MACgB,iBAAfvG,EAAMuG,MACb,UAAWvG,EAAMuG,KAEV+N,GAAiBtU,EAAMuG,KAAKvG,MAAOuU,GAK1CvU,GACiB,iBAAVA,GACP,YAAaA,GACY,iBAAlBA,EAAMwU,QAENxU,EAAMwU,QAGPD,QAAAA,GAAkBE,EAAAA,EAAAA,IAAI,gBAAiB,8BAC/C,CC5Be,IAAIzV,EAAQ,UD8BrB,MAAO0V,WAAuBzK,MAGnChL,WAAAA,CACQ0V,EACPH,GAEAjH,MAAOiH,GAHA,KAAAG,KAAAA,EAHD,KAAAxR,KAAO,gBAOd,EE5BK,MAAOyR,GAAb3V,WAAAA,GACS,KAAA4V,UAA6C,IAAI/T,GAiB1D,CAfQ+L,IAAAA,CAAMuE,GACZhS,KAAKyV,UAAUxQ,QAASyQ,GAAYA,EAAU1D,GAC/C,CAEOhF,EAAAA,CAAI2I,GACV3V,KAAKyV,UAAUvI,IAAKyI,EACrB,CAEOtI,GAAAA,CAAKsI,GACX3V,KAAKyV,UAAUlI,OAAQoI,EACxB,CAEOhI,OAAAA,GACN3N,KAAKyV,UAAUG,OAChB,E,kTCGD,MAAMC,GAAuC,CAC5ClI,QAASA,OACTX,GAAIA,QAMC8I,GCzCA,WACL,MAAMC,EAAQ,IAAI3U,IAElB,MAAS,IAAKhB,KACb,MAAM3B,EAAMuR,KAAKC,UAAW7P,GAC5B,GAAK2V,EAAM1Q,IAAK5G,GACf,OAAOsX,EAAMjX,IAAKL,GAGnB,MAAMuX,EDgCyB,KF5B3B,WACL,GAAK5W,OAAO6W,gBACX,OAAO7W,OAAO8W,OAAOC,aAgBtB,MAAM,IAAItL,MAAO,6EAClB,CES+CuL,GChC9BC,IAAOjW,GAEtB,OADA2V,EAAMvU,IAAK/C,EAAKuX,GACTA,EAET,CD4BsBM,GAEhBC,GAAS,IAAI3W,EAAQ,oBAgD3B,SAAS4W,GAAuBjB,GAC/B,OAASA,GACR,KAAK,KAEJ,OAAO,IAAID,GAAgB,sBAC5B,KAAK,KAEJ,OAAO,IAAIA,GAAgB,6BAC5B,QAEC,OAAO,IAAIA,GAAgB,iBAE9B,CAOA,SAASmB,GACRtG,EACAuG,EACAC,GAEA,IAAIC,EAAoB,EAExB,OAAO,W,yCACN,GAAKA,EAAoB,EAAI,CAC5B,MAAMC,EAAmB1O,KAAKC,IAC7B,IAAOD,KAAAU,IAAA,EAAK+N,G/CxHoC,M+C4HjDL,GAAO5V,KACN,2CAA4CwH,KAAKD,MAAO2O,EAAmB,kBAGtE,IAAIC,QAASC,GAAW7E,WAAY6E,EAASF,GACpD,CAEAD,GAAqB,EAErB,IACC,MAAMI,QAtFT,SAA+BN,EAAwBC,G,yCACtD,MAAMxP,QAAa8P,IAA+B,CACjDC,KAAM,6BACNC,OAAQ,OACRhQ,KAAM,CACLuP,iBACAC,eACAS,WAAYtB,QAId,IAAO3O,EAAKkQ,MACX,MAAM,IAAIxM,OAAOwK,EAAAA,EAAAA,IAAI,yBAA0B,gCAGhD,OAAOlO,EAAKkQ,KACb,E,CAsE2BC,CAAgBZ,EAAgBC,GAExDxG,EAAShM,OAAS,CACjBoT,KAAMP,GAEP7G,EAASqD,UAKTrD,EAASkC,eAAgB,EA3E5B,SAAwBlC,G,MACvB,MAAMqH,EAAmB,CACxBC,cAAc,EACd1Q,KAAM,GAAIoJ,EAASoD,iBAAkC,QAAfmE,EAAAvH,EAAShM,cAAM,IAAAuT,OAAA,EAAAA,EAAEH,OACvDpH,SAAU,cACVmB,IAAKjS,GAIAsY,EAAa,sCAAuC7L,mBACzDkE,KAAKC,UAAWuH,MAGjBjB,GAAO9V,KAAM,qBAAsB0P,EAASoD,aAAeoE,IAC5D,CA+DGC,CAAezH,EAChB,CAAE,MAAQvP,GACT2V,GAAO3V,MACN,IAAIyU,EAAAA,EAAAA,IACH,sDACA,mCACOH,GAAiBtU,KAE3B,CACD,E,CACD,CAQM,SAAUiX,GAA2BvE,GAC1C,MAAMwE,EAAoC,CACzCxE,YACAyE,QAAS,CAKRvE,SAAS,IAIX,OAAO,SAAAkE,G,2CAAiB,UACvB9H,EAAS,WACToI,EAAU,SACVC,EAAQ,KACRC,IAEA,IAMC,KAHC,OAASD,GACLD,EAAWG,WAAY,cAAmBvN,SAAUqN,EAAU,KAOlE,OAJA1B,GAAOhW,MAAO,sDAAuD,CACpEyX,aACAC,aAEMpC,GAWR,MAAMuC,EAAW,QAAS7Y,QAAAA,EAAW,KAAOyY,KAAgBC,QAAAA,EAAY,eAClEF,EAAOpZ,OAAAiP,OAAAjP,OAAAiP,OAAA,GACTkK,EAAOC,SAAO,CACjBnI,cAEKO,EAAW,IAAIkD,GAAmByE,EAAOxE,UAAW8E,EAAUF,EAAMH,GACpEvE,EAAUiD,GAAetG,EAAU6H,EAAYC,QAAAA,EAAY,cAG3DI,EAAoB,IAAI7C,GAExB8C,EAA0B3G,IAE/B0G,EAAkB5K,KAAM,CACvBuE,OAAQ,eACRpR,MAAO4V,GAAuB7E,aAAK,EAALA,EAAO4D,QAGjC/B,KA2CN,OAxCArD,EAASnD,GAAI,mBAAoBsL,GAGjCnI,EAASnD,GAAI,SAAY2E,IAKF,iBAAjBA,EAAMK,QACVqG,EAAkB5K,KAAM,CAAEuE,OAAQL,EAAMK,iBA6BpCwB,IAEC,CACN7F,QAASA,KACR0K,EAAkB1K,UAClBwC,EAASxC,WAEVX,GAAIA,CACH2E,EACAgE,KAEK,WAAahE,GACjB0G,EAAkBrL,GAAI2I,IAI1B,CAAE,MAAQ4C,GACThC,GAAOzV,SAAU,wCAAyC,CAAEF,MAAO2X,GACpE,CAEA,OAAO1C,EACR,E,CACD,EEvRA2C,EAAAA,EAAAA,WAAW,iBAAkB,UAAW,IAGhCnZ,EAOA,CAAEwY,GAA2BxY,MANnC,IAAIO,GAASkB,SACZ,oHAEM,I","sources":["webpack://vip-real-time-collaboration/webpack/bootstrap","webpack://vip-real-time-collaboration/webpack/runtime/compat get default export","webpack://vip-real-time-collaboration/webpack/runtime/define property getters","webpack://vip-real-time-collaboration/webpack/runtime/hasOwnProperty shorthand","webpack://vip-real-time-collaboration/external window [\"wp\",\"hooks\"]","webpack://vip-real-time-collaboration/./src/utilities/config.ts","webpack://vip-real-time-collaboration/./src/utilities/logger.ts","webpack://vip-real-time-collaboration/external window [\"wp\",\"apiFetch\"]","webpack://vip-real-time-collaboration/external window [\"wp\",\"i18n\"]","webpack://vip-real-time-collaboration/external var \"wp.sync.Y\"","webpack://vip-real-time-collaboration/./node_modules/y-websocket/node_modules/lib0/map.js","webpack://vip-real-time-collaboration/./node_modules/y-websocket/node_modules/lib0/set.js","webpack://vip-real-time-collaboration/./node_modules/y-websocket/node_modules/lib0/string.js","webpack://vip-real-time-collaboration/./node_modules/y-websocket/node_modules/lib0/storage.js","webpack://vip-real-time-collaboration/./node_modules/y-websocket/node_modules/lib0/array.js","webpack://vip-real-time-collaboration/./node_modules/y-websocket/node_modules/lib0/environment.js","webpack://vip-real-time-collaboration/./node_modules/y-websocket/node_modules/lib0/conditions.js","webpack://vip-real-time-collaboration/./node_modules/y-websocket/node_modules/lib0/function.js","webpack://vip-real-time-collaboration/./node_modules/y-websocket/node_modules/lib0/buffer.js","webpack://vip-real-time-collaboration/./node_modules/y-websocket/node_modules/lib0/broadcastchannel.js","webpack://vip-real-time-collaboration/./node_modules/y-websocket/node_modules/lib0/time.js","webpack://vip-real-time-collaboration/./node_modules/y-websocket/node_modules/lib0/math.js","webpack://vip-real-time-collaboration/./node_modules/y-websocket/node_modules/lib0/binary.js","webpack://vip-real-time-collaboration/./node_modules/y-websocket/node_modules/lib0/encoding.js","webpack://vip-real-time-collaboration/./node_modules/y-websocket/node_modules/lib0/number.js","webpack://vip-real-time-collaboration/./node_modules/y-websocket/node_modules/lib0/error.js","webpack://vip-real-time-collaboration/./node_modules/y-websocket/node_modules/lib0/decoding.js","webpack://vip-real-time-collaboration/./node_modules/y-protocols/node_modules/lib0/math.js","webpack://vip-real-time-collaboration/./node_modules/y-protocols/node_modules/lib0/binary.js","webpack://vip-real-time-collaboration/./node_modules/y-protocols/node_modules/lib0/string.js","webpack://vip-real-time-collaboration/./node_modules/y-protocols/node_modules/lib0/encoding.js","webpack://vip-real-time-collaboration/./node_modules/y-protocols/node_modules/lib0/number.js","webpack://vip-real-time-collaboration/./node_modules/y-protocols/node_modules/lib0/error.js","webpack://vip-real-time-collaboration/./node_modules/y-protocols/node_modules/lib0/decoding.js","webpack://vip-real-time-collaboration/./node_modules/y-protocols/sync.js","webpack://vip-real-time-collaboration/./node_modules/y-protocols/node_modules/lib0/time.js","webpack://vip-real-time-collaboration/./node_modules/y-protocols/node_modules/lib0/map.js","webpack://vip-real-time-collaboration/./node_modules/y-protocols/node_modules/lib0/set.js","webpack://vip-real-time-collaboration/./node_modules/y-protocols/node_modules/lib0/array.js","webpack://vip-real-time-collaboration/./node_modules/y-protocols/node_modules/lib0/observable.js","webpack://vip-real-time-collaboration/./node_modules/y-protocols/node_modules/lib0/object.js","webpack://vip-real-time-collaboration/./node_modules/y-protocols/node_modules/lib0/traits.js","webpack://vip-real-time-collaboration/./node_modules/y-protocols/node_modules/lib0/function.js","webpack://vip-real-time-collaboration/./node_modules/y-protocols/awareness.js","webpack://vip-real-time-collaboration/./node_modules/y-websocket/node_modules/lib0/observable.js","webpack://vip-real-time-collaboration/./node_modules/y-websocket/node_modules/lib0/object.js","webpack://vip-real-time-collaboration/./node_modules/y-websocket/src/y-websocket.js","webpack://vip-real-time-collaboration/./node_modules/y-protocols/auth.js","webpack://vip-real-time-collaboration/./node_modules/y-websocket/node_modules/lib0/url.js","webpack://vip-real-time-collaboration/./src/utilities/error.ts","webpack://vip-real-time-collaboration/./src/utilities/crypto.ts","webpack://vip-real-time-collaboration/./src/utilities/sync-event-emitter.ts","webpack://vip-real-time-collaboration/./src/websocket-client.ts","webpack://vip-real-time-collaboration/./src/utilities/function.ts","webpack://vip-real-time-collaboration/./src/index.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","const __WEBPACK_NAMESPACE_OBJECT__ = window[\"wp\"][\"hooks\"];","export const WEBSOCKET_PROVIDER_MAX_BACKOFF_IN_MS = 15000;\nexport const WEBSOCKET_URL = getVipConfigFromWindow( 'wsUrl' );\n\nexport const BLOG_ID = getVipConfigFromWindow( 'blogId' );\n\n// Exporting this as a function allows for easier testing/mocking.\nexport function isDevelopment(): boolean {\n\treturn 'development' === process.env.NODE_ENV;\n}\n\nfunction getVipConfigFromWindow< Key extends keyof VIPRTCConfig >(\n\tkey: Key\n): VIPRTCConfig[ Key ] | null {\n\tif ( 'undefined' === typeof window || 'undefined' === typeof window.VIP_RTC ) {\n\t\treturn null;\n\t}\n\n\t// eslint-disable-next-line security/detect-object-injection\n\treturn window.VIP_RTC[ key ];\n}\n","import { isDevelopment } from '@/utilities/config';\n\nexport enum LogLevel {\n\tCRITICAL = 5,\n\tERROR = 4,\n\tWARNING = 3,\n\tINFO = 2,\n\tDEBUG = 1,\n}\n\nconst DEFAULT_LOG_THRESHOLD = isDevelopment() ? LogLevel.DEBUG : LogLevel.WARNING;\n\nexport class Logger {\n\tprivate namespace: string;\n\n\tpublic constructor(\n\t\tlocalNamespace: string = '',\n\t\tprivate threshold: LogLevel = DEFAULT_LOG_THRESHOLD\n\t) {\n\t\tthis.namespace = `vip-rtc${ localNamespace ? `:${ localNamespace }` : '' }`;\n\t}\n\n\tprotected log( level: LogLevel, ...args: unknown[] ): void {\n\t\tif ( level < this.threshold ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// eslint-disable-next-line security/detect-object-injection\n\t\tconst levelStr = LogLevel[ level ];\n\n\t\t// eslint-disable-next-line no-console\n\t\tconsole.log( `[${ this.namespace }][${ levelStr }]`, ...args );\n\t}\n\n\tpublic debug( ...args: unknown[] ): void {\n\t\tthis.log( LogLevel.DEBUG, ...args );\n\t}\n\n\tpublic info( ...args: unknown[] ): void {\n\t\tthis.log( LogLevel.INFO, ...args );\n\t}\n\n\tpublic warn( ...args: unknown[] ): void {\n\t\tthis.log( LogLevel.WARNING, ...args );\n\t}\n\n\tpublic error( ...args: unknown[] ): void {\n\t\tthis.log( LogLevel.ERROR, ...args );\n\t}\n\n\tpublic critical( ...args: unknown[] ): void {\n\t\tthis.log( LogLevel.CRITICAL, ...args );\n\t}\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = window[\"wp\"][\"apiFetch\"];","const __WEBPACK_NAMESPACE_OBJECT__ = window[\"wp\"][\"i18n\"];","const __WEBPACK_NAMESPACE_OBJECT__ = wp.sync.Y;","/**\n * Utility module to work with key-value stores.\n *\n * @module map\n */\n\n/**\n * Creates a new Map instance.\n *\n * @function\n * @return {Map<any, any>}\n *\n * @function\n */\nexport const create = () => new Map()\n\n/**\n * Copy a Map object into a fresh Map object.\n *\n * @function\n * @template K,V\n * @param {Map<K,V>} m\n * @return {Map<K,V>}\n */\nexport const copy = m => {\n  const r = create()\n  m.forEach((v, k) => { r.set(k, v) })\n  return r\n}\n\n/**\n * Get map property. Create T if property is undefined and set T on map.\n *\n * ```js\n * const listeners = map.setIfUndefined(events, 'eventName', set.create)\n * listeners.add(listener)\n * ```\n *\n * @function\n * @template {Map<any, any>} MAP\n * @template {MAP extends Map<any,infer V> ? function():V : unknown} CF\n * @param {MAP} map\n * @param {MAP extends Map<infer K,any> ? K : unknown} key\n * @param {CF} createT\n * @return {ReturnType<CF>}\n */\nexport const setIfUndefined = (map, key, createT) => {\n  let set = map.get(key)\n  if (set === undefined) {\n    map.set(key, set = createT())\n  }\n  return set\n}\n\n/**\n * Creates an Array and populates it with the content of all key-value pairs using the `f(value, key)` function.\n *\n * @function\n * @template K\n * @template V\n * @template R\n * @param {Map<K,V>} m\n * @param {function(V,K):R} f\n * @return {Array<R>}\n */\nexport const map = (m, f) => {\n  const res = []\n  for (const [key, value] of m) {\n    res.push(f(value, key))\n  }\n  return res\n}\n\n/**\n * Tests whether any key-value pairs pass the test implemented by `f(value, key)`.\n *\n * @todo should rename to some - similarly to Array.some\n *\n * @function\n * @template K\n * @template V\n * @param {Map<K,V>} m\n * @param {function(V,K):boolean} f\n * @return {boolean}\n */\nexport const any = (m, f) => {\n  for (const [key, value] of m) {\n    if (f(value, key)) {\n      return true\n    }\n  }\n  return false\n}\n\n/**\n * Tests whether all key-value pairs pass the test implemented by `f(value, key)`.\n *\n * @function\n * @template K\n * @template V\n * @param {Map<K,V>} m\n * @param {function(V,K):boolean} f\n * @return {boolean}\n */\nexport const all = (m, f) => {\n  for (const [key, value] of m) {\n    if (!f(value, key)) {\n      return false\n    }\n  }\n  return true\n}\n","/**\n * Utility module to work with sets.\n *\n * @module set\n */\n\nexport const create = () => new Set()\n\n/**\n * @template T\n * @param {Set<T>} set\n * @return {Array<T>}\n */\nexport const toArray = set => Array.from(set)\n\n/**\n * @template T\n * @param {Set<T>} set\n * @return {T|undefined}\n */\nexport const first = set => set.values().next().value\n\n/**\n * @template T\n * @param {Iterable<T>} entries\n * @return {Set<T>}\n */\nexport const from = entries => new Set(entries)\n","import * as array from './array.js'\n\n/**\n * Utility module to work with strings.\n *\n * @module string\n */\n\nexport const fromCharCode = String.fromCharCode\nexport const fromCodePoint = String.fromCodePoint\n\n/**\n * The largest utf16 character.\n * Corresponds to Uint8Array([255, 255]) or charcodeof(2x2^8)\n */\nexport const MAX_UTF16_CHARACTER = fromCharCode(65535)\n\n/**\n * @param {string} s\n * @return {string}\n */\nconst toLowerCase = s => s.toLowerCase()\n\nconst trimLeftRegex = /^\\s*/g\n\n/**\n * @param {string} s\n * @return {string}\n */\nexport const trimLeft = s => s.replace(trimLeftRegex, '')\n\nconst fromCamelCaseRegex = /([A-Z])/g\n\n/**\n * @param {string} s\n * @param {string} separator\n * @return {string}\n */\nexport const fromCamelCase = (s, separator) => trimLeft(s.replace(fromCamelCaseRegex, match => `${separator}${toLowerCase(match)}`))\n\n/**\n * Compute the utf8ByteLength\n * @param {string} str\n * @return {number}\n */\nexport const utf8ByteLength = str => unescape(encodeURIComponent(str)).length\n\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\nexport const _encodeUtf8Polyfill = str => {\n  const encodedString = unescape(encodeURIComponent(str))\n  const len = encodedString.length\n  const buf = new Uint8Array(len)\n  for (let i = 0; i < len; i++) {\n    buf[i] = /** @type {number} */ (encodedString.codePointAt(i))\n  }\n  return buf\n}\n\n/* c8 ignore next */\nexport const utf8TextEncoder = /** @type {TextEncoder} */ (typeof TextEncoder !== 'undefined' ? new TextEncoder() : null)\n\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\nexport const _encodeUtf8Native = str => utf8TextEncoder.encode(str)\n\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\n/* c8 ignore next */\nexport const encodeUtf8 = utf8TextEncoder ? _encodeUtf8Native : _encodeUtf8Polyfill\n\n/**\n * @param {Uint8Array} buf\n * @return {string}\n */\nexport const _decodeUtf8Polyfill = buf => {\n  let remainingLen = buf.length\n  let encodedString = ''\n  let bufPos = 0\n  while (remainingLen > 0) {\n    const nextLen = remainingLen < 10000 ? remainingLen : 10000\n    const bytes = buf.subarray(bufPos, bufPos + nextLen)\n    bufPos += nextLen\n    // Starting with ES5.1 we can supply a generic array-like object as arguments\n    encodedString += String.fromCodePoint.apply(null, /** @type {any} */ (bytes))\n    remainingLen -= nextLen\n  }\n  return decodeURIComponent(escape(encodedString))\n}\n\n/* c8 ignore next */\nexport let utf8TextDecoder = typeof TextDecoder === 'undefined' ? null : new TextDecoder('utf-8', { fatal: true, ignoreBOM: true })\n\n/* c8 ignore start */\nif (utf8TextDecoder && utf8TextDecoder.decode(new Uint8Array()).length === 1) {\n  // Safari doesn't handle BOM correctly.\n  // This fixes a bug in Safari 13.0.5 where it produces a BOM the first time it is called.\n  // utf8TextDecoder.decode(new Uint8Array()).length === 1 on the first call and\n  // utf8TextDecoder.decode(new Uint8Array()).length === 1 on the second call\n  // Another issue is that from then on no BOM chars are recognized anymore\n  /* c8 ignore next */\n  utf8TextDecoder = null\n}\n/* c8 ignore stop */\n\n/**\n * @param {Uint8Array} buf\n * @return {string}\n */\nexport const _decodeUtf8Native = buf => /** @type {TextDecoder} */ (utf8TextDecoder).decode(buf)\n\n/**\n * @param {Uint8Array} buf\n * @return {string}\n */\n/* c8 ignore next */\nexport const decodeUtf8 = utf8TextDecoder ? _decodeUtf8Native : _decodeUtf8Polyfill\n\n/**\n * @param {string} str The initial string\n * @param {number} index Starting position\n * @param {number} remove Number of characters to remove\n * @param {string} insert New content to insert\n */\nexport const splice = (str, index, remove, insert = '') => str.slice(0, index) + insert + str.slice(index + remove)\n\n/**\n * @param {string} source\n * @param {number} n\n */\nexport const repeat = (source, n) => array.unfold(n, () => source).join('')\n\n/**\n * Escape HTML characters &,<,>,',\" to their respective HTML entities &amp;,&lt;,&gt;,&#39;,&quot;\n *\n * @param {string} str\n */\nexport const escapeHTML = str =>\n  str.replace(/[&<>'\"]/g, r => /** @type {string} */ ({\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    \"'\": '&#39;',\n    '\"': '&quot;'\n  }[r]))\n\n/**\n * Reverse of `escapeHTML`\n *\n * @param {string} str\n */\nexport const unescapeHTML = str =>\n  str.replace(/&amp;|&lt;|&gt;|&#39;|&quot;/g, r => /** @type {string} */ ({\n    '&amp;': '&',\n    '&lt;': '<',\n    '&gt;': '>',\n    '&#39;': \"'\",\n    '&quot;': '\"'\n  }[r]))\n","/* eslint-env browser */\n\n/**\n * Isomorphic variable storage.\n *\n * Uses LocalStorage in the browser and falls back to in-memory storage.\n *\n * @module storage\n */\n\n/* c8 ignore start */\nclass VarStoragePolyfill {\n  constructor () {\n    this.map = new Map()\n  }\n\n  /**\n   * @param {string} key\n   * @param {any} newValue\n   */\n  setItem (key, newValue) {\n    this.map.set(key, newValue)\n  }\n\n  /**\n   * @param {string} key\n   */\n  getItem (key) {\n    return this.map.get(key)\n  }\n}\n/* c8 ignore stop */\n\n/**\n * @type {any}\n */\nlet _localStorage = new VarStoragePolyfill()\nlet usePolyfill = true\n\n/* c8 ignore start */\ntry {\n  // if the same-origin rule is violated, accessing localStorage might thrown an error\n  if (typeof localStorage !== 'undefined' && localStorage) {\n    _localStorage = localStorage\n    usePolyfill = false\n  }\n} catch (e) { }\n/* c8 ignore stop */\n\n/**\n * This is basically localStorage in browser, or a polyfill in nodejs\n */\n/* c8 ignore next */\nexport const varStorage = _localStorage\n\n/**\n * A polyfill for `addEventListener('storage', event => {..})` that does nothing if the polyfill is being used.\n *\n * @param {function({ key: string, newValue: string, oldValue: string }): void} eventHandler\n * @function\n */\n/* c8 ignore next */\nexport const onChange = eventHandler => usePolyfill || addEventListener('storage', /** @type {any} */ (eventHandler))\n\n/**\n * A polyfill for `removeEventListener('storage', event => {..})` that does nothing if the polyfill is being used.\n *\n * @param {function({ key: string, newValue: string, oldValue: string }): void} eventHandler\n * @function\n */\n/* c8 ignore next */\nexport const offChange = eventHandler => usePolyfill || removeEventListener('storage', /** @type {any} */ (eventHandler))\n","/**\n * Utility module to work with Arrays.\n *\n * @module array\n */\n\nimport * as set from './set.js'\n\n/**\n * Return the last element of an array. The element must exist\n *\n * @template L\n * @param {ArrayLike<L>} arr\n * @return {L}\n */\nexport const last = arr => arr[arr.length - 1]\n\n/**\n * @template C\n * @return {Array<C>}\n */\nexport const create = () => /** @type {Array<C>} */ ([])\n\n/**\n * @template D\n * @param {Array<D>} a\n * @return {Array<D>}\n */\nexport const copy = a => /** @type {Array<D>} */ (a.slice())\n\n/**\n * Append elements from src to dest\n *\n * @template M\n * @param {Array<M>} dest\n * @param {Array<M>} src\n */\nexport const appendTo = (dest, src) => {\n  for (let i = 0; i < src.length; i++) {\n    dest.push(src[i])\n  }\n}\n\n/**\n * Transforms something array-like to an actual Array.\n *\n * @function\n * @template T\n * @param {ArrayLike<T>|Iterable<T>} arraylike\n * @return {T}\n */\nexport const from = Array.from\n\n/**\n * True iff condition holds on every element in the Array.\n *\n * @function\n * @template {ArrayLike<any>} ARR\n *\n * @param {ARR} arr\n * @param {ARR extends ArrayLike<infer S> ? ((value:S, index:number, arr:ARR) => boolean) : any} f\n * @return {boolean}\n */\nexport const every = (arr, f) => {\n  for (let i = 0; i < arr.length; i++) {\n    if (!f(arr[i], i, arr)) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * True iff condition holds on some element in the Array.\n *\n * @function\n * @template {ArrayLike<any>} ARR\n *\n * @param {ARR} arr\n * @param {ARR extends ArrayLike<infer S> ? ((value:S, index:number, arr:ARR) => boolean) : never} f\n * @return {boolean}\n */\nexport const some = (arr, f) => {\n  for (let i = 0; i < arr.length; i++) {\n    if (f(arr[i], i, arr)) {\n      return true\n    }\n  }\n  return false\n}\n\n/**\n * @template ELEM\n *\n * @param {ArrayLike<ELEM>} a\n * @param {ArrayLike<ELEM>} b\n * @return {boolean}\n */\nexport const equalFlat = (a, b) => a.length === b.length && every(a, (item, index) => item === b[index])\n\n/**\n * @template ELEM\n * @param {Array<Array<ELEM>>} arr\n * @return {Array<ELEM>}\n */\nexport const flatten = arr => fold(arr, /** @type {Array<ELEM>} */ ([]), (acc, val) => acc.concat(val))\n\n/**\n * @template T\n * @param {number} len\n * @param {function(number, Array<T>):T} f\n * @return {Array<T>}\n */\nexport const unfold = (len, f) => {\n  const array = new Array(len)\n  for (let i = 0; i < len; i++) {\n    array[i] = f(i, array)\n  }\n  return array\n}\n\n/**\n * @template T\n * @template RESULT\n * @param {Array<T>} arr\n * @param {RESULT} seed\n * @param {function(RESULT, T, number):RESULT} folder\n */\nexport const fold = (arr, seed, folder) => arr.reduce(folder, seed)\n\nexport const isArray = Array.isArray\n\n/**\n * @template T\n * @param {Array<T>} arr\n * @return {Array<T>}\n */\nexport const unique = arr => from(set.from(arr))\n\n/**\n * @template T\n * @template M\n * @param {ArrayLike<T>} arr\n * @param {function(T):M} mapper\n * @return {Array<T>}\n */\nexport const uniqueBy = (arr, mapper) => {\n  /**\n   * @type {Set<M>}\n   */\n  const happened = set.create()\n  /**\n   * @type {Array<T>}\n   */\n  const result = []\n  for (let i = 0; i < arr.length; i++) {\n    const el = arr[i]\n    const mapped = mapper(el)\n    if (!happened.has(mapped)) {\n      happened.add(mapped)\n      result.push(el)\n    }\n  }\n  return result\n}\n\n/**\n * @template {ArrayLike<any>} ARR\n * @template {function(ARR extends ArrayLike<infer T> ? T : never, number, ARR):any} MAPPER\n * @param {ARR} arr\n * @param {MAPPER} mapper\n * @return {Array<MAPPER extends function(...any): infer M ? M : never>}\n */\nexport const map = (arr, mapper) => {\n  /**\n   * @type {Array<any>}\n   */\n  const res = Array(arr.length)\n  for (let i = 0; i < arr.length; i++) {\n    res[i] = mapper(/** @type {any} */ (arr[i]), i, /** @type {any} */ (arr))\n  }\n  return /** @type {any} */ (res)\n}\n\n/**\n * This function bubble-sorts a single item to the correct position. The sort happens in-place and\n * might be useful to ensure that a single item is at the correct position in an otherwise sorted\n * array.\n *\n * @example\n *  const arr = [3, 2, 5]\n *  arr.sort((a, b) => a - b)\n *  arr // => [2, 3, 5]\n *  arr.splice(1, 0, 7)\n *  array.bubbleSortItem(arr, 1, (a, b) => a - b)\n *  arr // => [2, 3, 5, 7]\n *\n * @template T\n * @param {Array<T>} arr\n * @param {number} i\n * @param {(a:T,b:T) => number} compareFn\n */\nexport const bubblesortItem = (arr, i, compareFn) => {\n  const n = arr[i]\n  let j = i\n  // try to sort to the right\n  while (j + 1 < arr.length && compareFn(n, arr[j + 1]) > 0) {\n    arr[j] = arr[j + 1]\n    arr[++j] = n\n  }\n  if (i === j && j > 0) { // no change yet\n    // sort to the left\n    while (j > 0 && compareFn(arr[j - 1], n) > 0) {\n      arr[j] = arr[j - 1]\n      arr[--j] = n\n    }\n  }\n  return j\n}\n","/**\n * Isomorphic module to work access the environment (query params, env variables).\n *\n * @module environment\n */\n\nimport * as map from './map.js'\nimport * as string from './string.js'\nimport * as conditions from './conditions.js'\nimport * as storage from './storage.js'\nimport * as f from './function.js'\n\n/* c8 ignore next 2 */\n// @ts-ignore\nexport const isNode = typeof process !== 'undefined' && process.release && /node|io\\.js/.test(process.release.name) && Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]'\n\n/* c8 ignore next */\nexport const isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && !isNode\n/* c8 ignore next 3 */\nexport const isMac = typeof navigator !== 'undefined'\n  ? /Mac/.test(navigator.platform)\n  : false\n\n/**\n * @type {Map<string,string>}\n */\nlet params\nconst args = []\n\n/* c8 ignore start */\nconst computeParams = () => {\n  if (params === undefined) {\n    if (isNode) {\n      params = map.create()\n      const pargs = process.argv\n      let currParamName = null\n      for (let i = 0; i < pargs.length; i++) {\n        const parg = pargs[i]\n        if (parg[0] === '-') {\n          if (currParamName !== null) {\n            params.set(currParamName, '')\n          }\n          currParamName = parg\n        } else {\n          if (currParamName !== null) {\n            params.set(currParamName, parg)\n            currParamName = null\n          } else {\n            args.push(parg)\n          }\n        }\n      }\n      if (currParamName !== null) {\n        params.set(currParamName, '')\n      }\n      // in ReactNative for example this would not be true (unless connected to the Remote Debugger)\n    } else if (typeof location === 'object') {\n      params = map.create(); // eslint-disable-next-line no-undef\n      (location.search || '?').slice(1).split('&').forEach((kv) => {\n        if (kv.length !== 0) {\n          const [key, value] = kv.split('=')\n          params.set(`--${string.fromCamelCase(key, '-')}`, value)\n          params.set(`-${string.fromCamelCase(key, '-')}`, value)\n        }\n      })\n    } else {\n      params = map.create()\n    }\n  }\n  return params\n}\n/* c8 ignore stop */\n\n/**\n * @param {string} name\n * @return {boolean}\n */\n/* c8 ignore next */\nexport const hasParam = (name) => computeParams().has(name)\n\n/**\n * @param {string} name\n * @param {string} defaultVal\n * @return {string}\n */\n/* c8 ignore next 2 */\nexport const getParam = (name, defaultVal) =>\n  computeParams().get(name) || defaultVal\n\n/**\n * @param {string} name\n * @return {string|null}\n */\n/* c8 ignore next 4 */\nexport const getVariable = (name) =>\n  isNode\n    ? conditions.undefinedToNull(process.env[name.toUpperCase().replaceAll('-', '_')])\n    : conditions.undefinedToNull(storage.varStorage.getItem(name))\n\n/**\n * @param {string} name\n * @return {string|null}\n */\n/* c8 ignore next 2 */\nexport const getConf = (name) =>\n  computeParams().get('--' + name) || getVariable(name)\n\n/**\n * @param {string} name\n * @return {string}\n */\n/* c8 ignore next 5 */\nexport const ensureConf = (name) => {\n  const c = getConf(name)\n  if (c == null) throw new Error(`Expected configuration \"${name.toUpperCase().replaceAll('-', '_')}\"`)\n  return c\n}\n\n/**\n * @param {string} name\n * @return {boolean}\n */\n/* c8 ignore next 2 */\nexport const hasConf = (name) =>\n  hasParam('--' + name) || getVariable(name) !== null\n\n/* c8 ignore next */\nexport const production = hasConf('production')\n\n/* c8 ignore next 2 */\nconst forceColor = isNode &&\n  f.isOneOf(process.env.FORCE_COLOR, ['true', '1', '2'])\n\n/* c8 ignore start */\n/**\n * Color is enabled by default if the terminal supports it.\n *\n * Explicitly enable color using `--color` parameter\n * Disable color using `--no-color` parameter or using `NO_COLOR=1` environment variable.\n * `FORCE_COLOR=1` enables color and takes precedence over all.\n */\nexport const supportsColor = forceColor || (\n  !hasParam('--no-colors') && // @todo deprecate --no-colors\n  !hasConf('no-color') &&\n  (!isNode || process.stdout.isTTY) && (\n    !isNode ||\n    hasParam('--color') ||\n    getVariable('COLORTERM') !== null ||\n    (getVariable('TERM') || '').includes('color')\n  )\n)\n/* c8 ignore stop */\n","/**\n * Often used conditions.\n *\n * @module conditions\n */\n\n/**\n * @template T\n * @param {T|null|undefined} v\n * @return {T|null}\n */\n/* c8 ignore next */\nexport const undefinedToNull = v => v === undefined ? null : v\n","/**\n * Common functions and function call helpers.\n *\n * @module function\n */\n\nimport * as array from './array.js'\nimport * as object from './object.js'\nimport * as traits from './traits.js'\n\n/**\n * Calls all functions in `fs` with args. Only throws after all functions were called.\n *\n * @param {Array<function>} fs\n * @param {Array<any>} args\n */\nexport const callAll = (fs, args, i = 0) => {\n  try {\n    for (; i < fs.length; i++) {\n      fs[i](...args)\n    }\n  } finally {\n    if (i < fs.length) {\n      callAll(fs, args, i + 1)\n    }\n  }\n}\n\nexport const nop = () => {}\n\n/**\n * @template T\n * @param {function():T} f\n * @return {T}\n */\nexport const apply = f => f()\n\n/**\n * @template A\n *\n * @param {A} a\n * @return {A}\n */\nexport const id = a => a\n\n/**\n * @template T\n *\n * @param {T} a\n * @param {T} b\n * @return {boolean}\n */\nexport const equalityStrict = (a, b) => a === b\n\n/**\n * @template T\n *\n * @param {Array<T>|object} a\n * @param {Array<T>|object} b\n * @return {boolean}\n */\nexport const equalityFlat = (a, b) => a === b || (a != null && b != null && a.constructor === b.constructor && ((array.isArray(a) && array.equalFlat(a, /** @type {Array<T>} */ (b))) || (typeof a === 'object' && object.equalFlat(a, b))))\n\n/* c8 ignore start */\n\n/**\n * @param {any} a\n * @param {any} b\n * @return {boolean}\n */\nexport const equalityDeep = (a, b) => {\n  if (a === b) {\n    return true\n  }\n  if (a == null || b == null || a.constructor !== b.constructor) {\n    return false\n  }\n  if (a[traits.EqualityTraitSymbol] != null) {\n    return a[traits.EqualityTraitSymbol](b)\n  }\n  switch (a.constructor) {\n    case ArrayBuffer:\n      a = new Uint8Array(a)\n      b = new Uint8Array(b)\n    // eslint-disable-next-line no-fallthrough\n    case Uint8Array: {\n      if (a.byteLength !== b.byteLength) {\n        return false\n      }\n      for (let i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) {\n          return false\n        }\n      }\n      break\n    }\n    case Set: {\n      if (a.size !== b.size) {\n        return false\n      }\n      for (const value of a) {\n        if (!b.has(value)) {\n          return false\n        }\n      }\n      break\n    }\n    case Map: {\n      if (a.size !== b.size) {\n        return false\n      }\n      for (const key of a.keys()) {\n        if (!b.has(key) || !equalityDeep(a.get(key), b.get(key))) {\n          return false\n        }\n      }\n      break\n    }\n    case Object:\n      if (object.length(a) !== object.length(b)) {\n        return false\n      }\n      for (const key in a) {\n        if (!object.hasProperty(a, key) || !equalityDeep(a[key], b[key])) {\n          return false\n        }\n      }\n      break\n    case Array:\n      if (a.length !== b.length) {\n        return false\n      }\n      for (let i = 0; i < a.length; i++) {\n        if (!equalityDeep(a[i], b[i])) {\n          return false\n        }\n      }\n      break\n    default:\n      return false\n  }\n  return true\n}\n\n/**\n * @template V\n * @template {V} OPTS\n *\n * @param {V} value\n * @param {Array<OPTS>} options\n */\n// @ts-ignore\nexport const isOneOf = (value, options) => options.includes(value)\n/* c8 ignore stop */\n\nexport const isArray = array.isArray\n\n/**\n * @param {any} s\n * @return {s is String}\n */\nexport const isString = (s) => s && s.constructor === String\n\n/**\n * @param {any} n\n * @return {n is Number}\n */\nexport const isNumber = n => n != null && n.constructor === Number\n\n/**\n * @template {abstract new (...args: any) => any} TYPE\n * @param {any} n\n * @param {TYPE} T\n * @return {n is InstanceType<TYPE>}\n */\nexport const is = (n, T) => n && n.constructor === T\n\n/**\n * @template {abstract new (...args: any) => any} TYPE\n * @param {TYPE} T\n */\nexport const isTemplate = (T) =>\n  /**\n   * @param {any} n\n   * @return {n is InstanceType<TYPE>}\n   **/\n  n => n && n.constructor === T\n","/**\n * Utility functions to work with buffers (Uint8Array).\n *\n * @module buffer\n */\n\nimport * as string from './string.js'\nimport * as env from './environment.js'\nimport * as array from './array.js'\nimport * as math from './math.js'\nimport * as encoding from './encoding.js'\nimport * as decoding from './decoding.js'\n\n/**\n * @param {number} len\n */\nexport const createUint8ArrayFromLen = len => new Uint8Array(len)\n\n/**\n * Create Uint8Array with initial content from buffer\n *\n * @param {ArrayBuffer} buffer\n * @param {number} byteOffset\n * @param {number} length\n */\nexport const createUint8ArrayViewFromArrayBuffer = (buffer, byteOffset, length) => new Uint8Array(buffer, byteOffset, length)\n\n/**\n * Create Uint8Array with initial content from buffer\n *\n * @param {ArrayBuffer} buffer\n */\nexport const createUint8ArrayFromArrayBuffer = buffer => new Uint8Array(buffer)\n\n/* c8 ignore start */\n/**\n * @param {Uint8Array} bytes\n * @return {string}\n */\nconst toBase64Browser = bytes => {\n  let s = ''\n  for (let i = 0; i < bytes.byteLength; i++) {\n    s += string.fromCharCode(bytes[i])\n  }\n  // eslint-disable-next-line no-undef\n  return btoa(s)\n}\n/* c8 ignore stop */\n\n/**\n * @param {Uint8Array} bytes\n * @return {string}\n */\nconst toBase64Node = bytes => Buffer.from(bytes.buffer, bytes.byteOffset, bytes.byteLength).toString('base64')\n\n/* c8 ignore start */\n/**\n * @param {string} s\n * @return {Uint8Array}\n */\nconst fromBase64Browser = s => {\n  // eslint-disable-next-line no-undef\n  const a = atob(s)\n  const bytes = createUint8ArrayFromLen(a.length)\n  for (let i = 0; i < a.length; i++) {\n    bytes[i] = a.charCodeAt(i)\n  }\n  return bytes\n}\n/* c8 ignore stop */\n\n/**\n * @param {string} s\n */\nconst fromBase64Node = s => {\n  const buf = Buffer.from(s, 'base64')\n  return createUint8ArrayViewFromArrayBuffer(buf.buffer, buf.byteOffset, buf.byteLength)\n}\n\n/* c8 ignore next */\nexport const toBase64 = env.isBrowser ? toBase64Browser : toBase64Node\n\n/* c8 ignore next */\nexport const fromBase64 = env.isBrowser ? fromBase64Browser : fromBase64Node\n\n/**\n * Implements base64url - see https://datatracker.ietf.org/doc/html/rfc4648#section-5\n * @param {Uint8Array} buf\n */\nexport const toBase64UrlEncoded = buf => toBase64(buf).replaceAll('+', '-').replaceAll('/', '_').replaceAll('=', '')\n\n/**\n * @param {string} base64\n */\nexport const fromBase64UrlEncoded = base64 => fromBase64(base64.replaceAll('-', '+').replaceAll('_', '/'))\n\n/**\n * Base64 is always a more efficient choice. This exists for utility purposes only.\n *\n * @param {Uint8Array} buf\n */\nexport const toHexString = buf => array.map(buf, b => b.toString(16).padStart(2, '0')).join('')\n\n/**\n * Note: This function expects that the hex doesn't start with 0x..\n *\n * @param {string} hex\n */\nexport const fromHexString = hex => {\n  const hlen = hex.length\n  const buf = new Uint8Array(math.ceil(hlen / 2))\n  for (let i = 0; i < hlen; i += 2) {\n    buf[buf.length - i / 2 - 1] = Number.parseInt(hex.slice(hlen - i - 2, hlen - i), 16)\n  }\n  return buf\n}\n\n/**\n * Copy the content of an Uint8Array view to a new ArrayBuffer.\n *\n * @param {Uint8Array} uint8Array\n * @return {Uint8Array}\n */\nexport const copyUint8Array = uint8Array => {\n  const newBuf = createUint8ArrayFromLen(uint8Array.byteLength)\n  newBuf.set(uint8Array)\n  return newBuf\n}\n\n/**\n * Encode anything as a UInt8Array. It's a pun on typescripts's `any` type.\n * See encoding.writeAny for more information.\n *\n * @param {any} data\n * @return {Uint8Array}\n */\nexport const encodeAny = data =>\n  encoding.encode(encoder => encoding.writeAny(encoder, data))\n\n/**\n * Decode an any-encoded value.\n *\n * @param {Uint8Array} buf\n * @return {any}\n */\nexport const decodeAny = buf => decoding.readAny(decoding.createDecoder(buf))\n\n/**\n * Shift Byte Array {N} bits to the left. Does not expand byte array.\n *\n * @param {Uint8Array} bs\n * @param {number} N should be in the range of [0-7]\n */\nexport const shiftNBitsLeft = (bs, N) => {\n  if (N === 0) return bs\n  bs = new Uint8Array(bs)\n  bs[0] <<= N\n  for (let i = 1; i < bs.length; i++) {\n    bs[i - 1] |= bs[i] >>> (8 - N)\n    bs[i] <<= N\n  }\n  return bs\n}\n","/* eslint-env browser */\n\n/**\n * Helpers for cross-tab communication using broadcastchannel with LocalStorage fallback.\n *\n * ```js\n * // In browser window A:\n * broadcastchannel.subscribe('my events', data => console.log(data))\n * broadcastchannel.publish('my events', 'Hello world!') // => A: 'Hello world!' fires synchronously in same tab\n *\n * // In browser window B:\n * broadcastchannel.publish('my events', 'hello from tab B') // => A: 'hello from tab B'\n * ```\n *\n * @module broadcastchannel\n */\n\n// @todo before next major: use Uint8Array instead as buffer object\n\nimport * as map from './map.js'\nimport * as set from './set.js'\nimport * as buffer from './buffer.js'\nimport * as storage from './storage.js'\n\n/**\n * @typedef {Object} Channel\n * @property {Set<function(any, any):any>} Channel.subs\n * @property {any} Channel.bc\n */\n\n/**\n * @type {Map<string, Channel>}\n */\nconst channels = new Map()\n\n/* c8 ignore start */\nclass LocalStoragePolyfill {\n  /**\n   * @param {string} room\n   */\n  constructor (room) {\n    this.room = room\n    /**\n     * @type {null|function({data:ArrayBuffer}):void}\n     */\n    this.onmessage = null\n    /**\n     * @param {any} e\n     */\n    this._onChange = e => e.key === room && this.onmessage !== null && this.onmessage({ data: buffer.fromBase64(e.newValue || '') })\n    storage.onChange(this._onChange)\n  }\n\n  /**\n   * @param {ArrayBuffer} buf\n   */\n  postMessage (buf) {\n    storage.varStorage.setItem(this.room, buffer.toBase64(buffer.createUint8ArrayFromArrayBuffer(buf)))\n  }\n\n  close () {\n    storage.offChange(this._onChange)\n  }\n}\n/* c8 ignore stop */\n\n// Use BroadcastChannel or Polyfill\n/* c8 ignore next */\nconst BC = typeof BroadcastChannel === 'undefined' ? LocalStoragePolyfill : BroadcastChannel\n\n/**\n * @param {string} room\n * @return {Channel}\n */\nconst getChannel = room =>\n  map.setIfUndefined(channels, room, () => {\n    const subs = set.create()\n    const bc = new BC(room)\n    /**\n     * @param {{data:ArrayBuffer}} e\n     */\n    /* c8 ignore next */\n    bc.onmessage = e => subs.forEach(sub => sub(e.data, 'broadcastchannel'))\n    return {\n      bc, subs\n    }\n  })\n\n/**\n * Subscribe to global `publish` events.\n *\n * @function\n * @param {string} room\n * @param {function(any, any):any} f\n */\nexport const subscribe = (room, f) => {\n  getChannel(room).subs.add(f)\n  return f\n}\n\n/**\n * Unsubscribe from `publish` global events.\n *\n * @function\n * @param {string} room\n * @param {function(any, any):any} f\n */\nexport const unsubscribe = (room, f) => {\n  const channel = getChannel(room)\n  const unsubscribed = channel.subs.delete(f)\n  if (unsubscribed && channel.subs.size === 0) {\n    channel.bc.close()\n    channels.delete(room)\n  }\n  return unsubscribed\n}\n\n/**\n * Publish data to all subscribers (including subscribers on this tab)\n *\n * @function\n * @param {string} room\n * @param {any} data\n * @param {any} [origin]\n */\nexport const publish = (room, data, origin = null) => {\n  const c = getChannel(room)\n  c.bc.postMessage(data)\n  c.subs.forEach(sub => sub(data, origin))\n}\n","/**\n * Utility module to work with time.\n *\n * @module time\n */\n\nimport * as metric from './metric.js'\nimport * as math from './math.js'\n\n/**\n * Return current time.\n *\n * @return {Date}\n */\nexport const getDate = () => new Date()\n\n/**\n * Return current unix time.\n *\n * @return {number}\n */\nexport const getUnixTime = Date.now\n\n/**\n * Transform time (in ms) to a human readable format. E.g. 1100 => 1.1s. 60s => 1min. .001 => 10s.\n *\n * @param {number} d duration in milliseconds\n * @return {string} humanized approximation of time\n */\nexport const humanizeDuration = d => {\n  if (d < 60000) {\n    const p = metric.prefix(d, -1)\n    return math.round(p.n * 100) / 100 + p.prefix + 's'\n  }\n  d = math.floor(d / 1000)\n  const seconds = d % 60\n  const minutes = math.floor(d / 60) % 60\n  const hours = math.floor(d / 3600) % 24\n  const days = math.floor(d / 86400)\n  if (days > 0) {\n    return days + 'd' + ((hours > 0 || minutes > 30) ? ' ' + (minutes > 30 ? hours + 1 : hours) + 'h' : '')\n  }\n  if (hours > 0) {\n    /* c8 ignore next */\n    return hours + 'h' + ((minutes > 0 || seconds > 30) ? ' ' + (seconds > 30 ? minutes + 1 : minutes) + 'min' : '')\n  }\n  return minutes + 'min' + (seconds > 0 ? ' ' + seconds + 's' : '')\n}\n","/**\n * Common Math expressions.\n *\n * @module math\n */\n\nexport const floor = Math.floor\nexport const ceil = Math.ceil\nexport const abs = Math.abs\nexport const imul = Math.imul\nexport const round = Math.round\nexport const log10 = Math.log10\nexport const log2 = Math.log2\nexport const log = Math.log\nexport const sqrt = Math.sqrt\n\n/**\n * @function\n * @param {number} a\n * @param {number} b\n * @return {number} The sum of a and b\n */\nexport const add = (a, b) => a + b\n\n/**\n * @function\n * @param {number} a\n * @param {number} b\n * @return {number} The smaller element of a and b\n */\nexport const min = (a, b) => a < b ? a : b\n\n/**\n * @function\n * @param {number} a\n * @param {number} b\n * @return {number} The bigger element of a and b\n */\nexport const max = (a, b) => a > b ? a : b\n\nexport const isNaN = Number.isNaN\n\nexport const pow = Math.pow\n/**\n * Base 10 exponential function. Returns the value of 10 raised to the power of pow.\n *\n * @param {number} exp\n * @return {number}\n */\nexport const exp10 = exp => Math.pow(10, exp)\n\nexport const sign = Math.sign\n\n/**\n * @param {number} n\n * @return {boolean} Wether n is negative. This function also differentiates between -0 and +0\n */\nexport const isNegativeZero = n => n !== 0 ? n < 0 : 1 / n < 0\n","/* eslint-env browser */\n\n/**\n * Binary data constants.\n *\n * @module binary\n */\n\n/**\n * n-th bit activated.\n *\n * @type {number}\n */\nexport const BIT1 = 1\nexport const BIT2 = 2\nexport const BIT3 = 4\nexport const BIT4 = 8\nexport const BIT5 = 16\nexport const BIT6 = 32\nexport const BIT7 = 64\nexport const BIT8 = 128\nexport const BIT9 = 256\nexport const BIT10 = 512\nexport const BIT11 = 1024\nexport const BIT12 = 2048\nexport const BIT13 = 4096\nexport const BIT14 = 8192\nexport const BIT15 = 16384\nexport const BIT16 = 32768\nexport const BIT17 = 65536\nexport const BIT18 = 1 << 17\nexport const BIT19 = 1 << 18\nexport const BIT20 = 1 << 19\nexport const BIT21 = 1 << 20\nexport const BIT22 = 1 << 21\nexport const BIT23 = 1 << 22\nexport const BIT24 = 1 << 23\nexport const BIT25 = 1 << 24\nexport const BIT26 = 1 << 25\nexport const BIT27 = 1 << 26\nexport const BIT28 = 1 << 27\nexport const BIT29 = 1 << 28\nexport const BIT30 = 1 << 29\nexport const BIT31 = 1 << 30\nexport const BIT32 = 1 << 31\n\n/**\n * First n bits activated.\n *\n * @type {number}\n */\nexport const BITS0 = 0\nexport const BITS1 = 1\nexport const BITS2 = 3\nexport const BITS3 = 7\nexport const BITS4 = 15\nexport const BITS5 = 31\nexport const BITS6 = 63\nexport const BITS7 = 127\nexport const BITS8 = 255\nexport const BITS9 = 511\nexport const BITS10 = 1023\nexport const BITS11 = 2047\nexport const BITS12 = 4095\nexport const BITS13 = 8191\nexport const BITS14 = 16383\nexport const BITS15 = 32767\nexport const BITS16 = 65535\nexport const BITS17 = BIT18 - 1\nexport const BITS18 = BIT19 - 1\nexport const BITS19 = BIT20 - 1\nexport const BITS20 = BIT21 - 1\nexport const BITS21 = BIT22 - 1\nexport const BITS22 = BIT23 - 1\nexport const BITS23 = BIT24 - 1\nexport const BITS24 = BIT25 - 1\nexport const BITS25 = BIT26 - 1\nexport const BITS26 = BIT27 - 1\nexport const BITS27 = BIT28 - 1\nexport const BITS28 = BIT29 - 1\nexport const BITS29 = BIT30 - 1\nexport const BITS30 = BIT31 - 1\n/**\n * @type {number}\n */\nexport const BITS31 = 0x7FFFFFFF\n/**\n * @type {number}\n */\nexport const BITS32 = 0xFFFFFFFF\n","/**\n * Efficient schema-less binary encoding with support for variable length encoding.\n *\n * Use [lib0/encoding] with [lib0/decoding]. Every encoding function has a corresponding decoding function.\n *\n * Encodes numbers in little-endian order (least to most significant byte order)\n * and is compatible with Golang's binary encoding (https://golang.org/pkg/encoding/binary/)\n * which is also used in Protocol Buffers.\n *\n * ```js\n * // encoding step\n * const encoder = encoding.createEncoder()\n * encoding.writeVarUint(encoder, 256)\n * encoding.writeVarString(encoder, 'Hello world!')\n * const buf = encoding.toUint8Array(encoder)\n * ```\n *\n * ```js\n * // decoding step\n * const decoder = decoding.createDecoder(buf)\n * decoding.readVarUint(decoder) // => 256\n * decoding.readVarString(decoder) // => 'Hello world!'\n * decoding.hasContent(decoder) // => false - all data is read\n * ```\n *\n * @module encoding\n */\n\nimport * as math from './math.js'\nimport * as number from './number.js'\nimport * as binary from './binary.js'\nimport * as string from './string.js'\nimport * as array from './array.js'\n\n/**\n * A BinaryEncoder handles the encoding to an Uint8Array.\n */\nexport class Encoder {\n  constructor () {\n    this.cpos = 0\n    this.cbuf = new Uint8Array(100)\n    /**\n     * @type {Array<Uint8Array>}\n     */\n    this.bufs = []\n  }\n}\n\n/**\n * @function\n * @return {Encoder}\n */\nexport const createEncoder = () => new Encoder()\n\n/**\n * @param {function(Encoder):void} f\n */\nexport const encode = (f) => {\n  const encoder = createEncoder()\n  f(encoder)\n  return toUint8Array(encoder)\n}\n\n/**\n * The current length of the encoded data.\n *\n * @function\n * @param {Encoder} encoder\n * @return {number}\n */\nexport const length = encoder => {\n  let len = encoder.cpos\n  for (let i = 0; i < encoder.bufs.length; i++) {\n    len += encoder.bufs[i].length\n  }\n  return len\n}\n\n/**\n * Check whether encoder is empty.\n *\n * @function\n * @param {Encoder} encoder\n * @return {boolean}\n */\nexport const hasContent = encoder => encoder.cpos > 0 || encoder.bufs.length > 0\n\n/**\n * Transform to Uint8Array.\n *\n * @function\n * @param {Encoder} encoder\n * @return {Uint8Array} The created ArrayBuffer.\n */\nexport const toUint8Array = encoder => {\n  const uint8arr = new Uint8Array(length(encoder))\n  let curPos = 0\n  for (let i = 0; i < encoder.bufs.length; i++) {\n    const d = encoder.bufs[i]\n    uint8arr.set(d, curPos)\n    curPos += d.length\n  }\n  uint8arr.set(new Uint8Array(encoder.cbuf.buffer, 0, encoder.cpos), curPos)\n  return uint8arr\n}\n\n/**\n * Verify that it is possible to write `len` bytes wtihout checking. If\n * necessary, a new Buffer with the required length is attached.\n *\n * @param {Encoder} encoder\n * @param {number} len\n */\nexport const verifyLen = (encoder, len) => {\n  const bufferLen = encoder.cbuf.length\n  if (bufferLen - encoder.cpos < len) {\n    encoder.bufs.push(new Uint8Array(encoder.cbuf.buffer, 0, encoder.cpos))\n    encoder.cbuf = new Uint8Array(math.max(bufferLen, len) * 2)\n    encoder.cpos = 0\n  }\n}\n\n/**\n * Write one byte to the encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The byte that is to be encoded.\n */\nexport const write = (encoder, num) => {\n  const bufferLen = encoder.cbuf.length\n  if (encoder.cpos === bufferLen) {\n    encoder.bufs.push(encoder.cbuf)\n    encoder.cbuf = new Uint8Array(bufferLen * 2)\n    encoder.cpos = 0\n  }\n  encoder.cbuf[encoder.cpos++] = num\n}\n\n/**\n * Write one byte at a specific position.\n * Position must already be written (i.e. encoder.length > pos)\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos Position to which to write data\n * @param {number} num Unsigned 8-bit integer\n */\nexport const set = (encoder, pos, num) => {\n  let buffer = null\n  // iterate all buffers and adjust position\n  for (let i = 0; i < encoder.bufs.length && buffer === null; i++) {\n    const b = encoder.bufs[i]\n    if (pos < b.length) {\n      buffer = b // found buffer\n    } else {\n      pos -= b.length\n    }\n  }\n  if (buffer === null) {\n    // use current buffer\n    buffer = encoder.cbuf\n  }\n  buffer[pos] = num\n}\n\n/**\n * Write one byte as an unsigned integer.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeUint8 = write\n\n/**\n * Write one byte as an unsigned Integer at a specific location.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos The location where the data will be written.\n * @param {number} num The number that is to be encoded.\n */\nexport const setUint8 = set\n\n/**\n * Write two bytes as an unsigned integer.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeUint16 = (encoder, num) => {\n  write(encoder, num & binary.BITS8)\n  write(encoder, (num >>> 8) & binary.BITS8)\n}\n/**\n * Write two bytes as an unsigned integer at a specific location.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos The location where the data will be written.\n * @param {number} num The number that is to be encoded.\n */\nexport const setUint16 = (encoder, pos, num) => {\n  set(encoder, pos, num & binary.BITS8)\n  set(encoder, pos + 1, (num >>> 8) & binary.BITS8)\n}\n\n/**\n * Write two bytes as an unsigned integer\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeUint32 = (encoder, num) => {\n  for (let i = 0; i < 4; i++) {\n    write(encoder, num & binary.BITS8)\n    num >>>= 8\n  }\n}\n\n/**\n * Write two bytes as an unsigned integer in big endian order.\n * (most significant byte first)\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeUint32BigEndian = (encoder, num) => {\n  for (let i = 3; i >= 0; i--) {\n    write(encoder, (num >>> (8 * i)) & binary.BITS8)\n  }\n}\n\n/**\n * Write two bytes as an unsigned integer at a specific location.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos The location where the data will be written.\n * @param {number} num The number that is to be encoded.\n */\nexport const setUint32 = (encoder, pos, num) => {\n  for (let i = 0; i < 4; i++) {\n    set(encoder, pos + i, num & binary.BITS8)\n    num >>>= 8\n  }\n}\n\n/**\n * Write a variable length unsigned integer. Max encodable integer is 2^53.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeVarUint = (encoder, num) => {\n  while (num > binary.BITS7) {\n    write(encoder, binary.BIT8 | (binary.BITS7 & num))\n    num = math.floor(num / 128) // shift >>> 7\n  }\n  write(encoder, binary.BITS7 & num)\n}\n\n/**\n * Write a variable length integer.\n *\n * We use the 7th bit instead for signaling that this is a negative number.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeVarInt = (encoder, num) => {\n  const isNegative = math.isNegativeZero(num)\n  if (isNegative) {\n    num = -num\n  }\n  //             |- whether to continue reading         |- whether is negative     |- number\n  write(encoder, (num > binary.BITS6 ? binary.BIT8 : 0) | (isNegative ? binary.BIT7 : 0) | (binary.BITS6 & num))\n  num = math.floor(num / 64) // shift >>> 6\n  // We don't need to consider the case of num === 0 so we can use a different\n  // pattern here than above.\n  while (num > 0) {\n    write(encoder, (num > binary.BITS7 ? binary.BIT8 : 0) | (binary.BITS7 & num))\n    num = math.floor(num / 128) // shift >>> 7\n  }\n}\n\n/**\n * A cache to store strings temporarily\n */\nconst _strBuffer = new Uint8Array(30000)\nconst _maxStrBSize = _strBuffer.length / 3\n\n/**\n * Write a variable length string.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\nexport const _writeVarStringNative = (encoder, str) => {\n  if (str.length < _maxStrBSize) {\n    // We can encode the string into the existing buffer\n    /* c8 ignore next */\n    const written = string.utf8TextEncoder.encodeInto(str, _strBuffer).written || 0\n    writeVarUint(encoder, written)\n    for (let i = 0; i < written; i++) {\n      write(encoder, _strBuffer[i])\n    }\n  } else {\n    writeVarUint8Array(encoder, string.encodeUtf8(str))\n  }\n}\n\n/**\n * Write a variable length string.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\nexport const _writeVarStringPolyfill = (encoder, str) => {\n  const encodedString = unescape(encodeURIComponent(str))\n  const len = encodedString.length\n  writeVarUint(encoder, len)\n  for (let i = 0; i < len; i++) {\n    write(encoder, /** @type {number} */ (encodedString.codePointAt(i)))\n  }\n}\n\n/**\n * Write a variable length string.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\n/* c8 ignore next */\nexport const writeVarString = (string.utf8TextEncoder && /** @type {any} */ (string.utf8TextEncoder).encodeInto) ? _writeVarStringNative : _writeVarStringPolyfill\n\n/**\n * Write a string terminated by a special byte sequence. This is not very performant and is\n * generally discouraged. However, the resulting byte arrays are lexiographically ordered which\n * makes this a nice feature for databases.\n *\n * The string will be encoded using utf8 and then terminated and escaped using writeTerminatingUint8Array.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\nexport const writeTerminatedString = (encoder, str) =>\n  writeTerminatedUint8Array(encoder, string.encodeUtf8(str))\n\n/**\n * Write a terminating Uint8Array. Note that this is not performant and is generally\n * discouraged. There are few situations when this is needed.\n *\n * We use 0x0 as a terminating character. 0x1 serves as an escape character for 0x0 and 0x1.\n *\n * Example: [0,1,2] is encoded to [1,0,1,1,2,0]. 0x0, and 0x1 needed to be escaped using 0x1. Then\n * the result is terminated using the 0x0 character.\n *\n * This is basically how many systems implement null terminated strings. However, we use an escape\n * character 0x1 to avoid issues and potenial attacks on our database (if this is used as a key\n * encoder for NoSql databases).\n *\n * @function\n * @param {Encoder} encoder\n * @param {Uint8Array} buf The string that is to be encoded.\n */\nexport const writeTerminatedUint8Array = (encoder, buf) => {\n  for (let i = 0; i < buf.length; i++) {\n    const b = buf[i]\n    if (b === 0 || b === 1) {\n      write(encoder, 1)\n    }\n    write(encoder, buf[i])\n  }\n  write(encoder, 0)\n}\n\n/**\n * Write the content of another Encoder.\n *\n * @TODO: can be improved!\n *        - Note: Should consider that when appending a lot of small Encoders, we should rather clone than referencing the old structure.\n *                Encoders start with a rather big initial buffer.\n *\n * @function\n * @param {Encoder} encoder The enUint8Arr\n * @param {Encoder} append The BinaryEncoder to be written.\n */\nexport const writeBinaryEncoder = (encoder, append) => writeUint8Array(encoder, toUint8Array(append))\n\n/**\n * Append fixed-length Uint8Array to the encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {Uint8Array} uint8Array\n */\nexport const writeUint8Array = (encoder, uint8Array) => {\n  const bufferLen = encoder.cbuf.length\n  const cpos = encoder.cpos\n  const leftCopyLen = math.min(bufferLen - cpos, uint8Array.length)\n  const rightCopyLen = uint8Array.length - leftCopyLen\n  encoder.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos)\n  encoder.cpos += leftCopyLen\n  if (rightCopyLen > 0) {\n    // Still something to write, write right half..\n    // Append new buffer\n    encoder.bufs.push(encoder.cbuf)\n    // must have at least size of remaining buffer\n    encoder.cbuf = new Uint8Array(math.max(bufferLen * 2, rightCopyLen))\n    // copy array\n    encoder.cbuf.set(uint8Array.subarray(leftCopyLen))\n    encoder.cpos = rightCopyLen\n  }\n}\n\n/**\n * Append an Uint8Array to Encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {Uint8Array} uint8Array\n */\nexport const writeVarUint8Array = (encoder, uint8Array) => {\n  writeVarUint(encoder, uint8Array.byteLength)\n  writeUint8Array(encoder, uint8Array)\n}\n\n/**\n * Create an DataView of the next `len` bytes. Use it to write data after\n * calling this function.\n *\n * ```js\n * // write float32 using DataView\n * const dv = writeOnDataView(encoder, 4)\n * dv.setFloat32(0, 1.1)\n * // read float32 using DataView\n * const dv = readFromDataView(encoder, 4)\n * dv.getFloat32(0) // => 1.100000023841858 (leaving it to the reader to find out why this is the correct result)\n * ```\n *\n * @param {Encoder} encoder\n * @param {number} len\n * @return {DataView}\n */\nexport const writeOnDataView = (encoder, len) => {\n  verifyLen(encoder, len)\n  const dview = new DataView(encoder.cbuf.buffer, encoder.cpos, len)\n  encoder.cpos += len\n  return dview\n}\n\n/**\n * @param {Encoder} encoder\n * @param {number} num\n */\nexport const writeFloat32 = (encoder, num) => writeOnDataView(encoder, 4).setFloat32(0, num, false)\n\n/**\n * @param {Encoder} encoder\n * @param {number} num\n */\nexport const writeFloat64 = (encoder, num) => writeOnDataView(encoder, 8).setFloat64(0, num, false)\n\n/**\n * @param {Encoder} encoder\n * @param {bigint} num\n */\nexport const writeBigInt64 = (encoder, num) => /** @type {any} */ (writeOnDataView(encoder, 8)).setBigInt64(0, num, false)\n\n/**\n * @param {Encoder} encoder\n * @param {bigint} num\n */\nexport const writeBigUint64 = (encoder, num) => /** @type {any} */ (writeOnDataView(encoder, 8)).setBigUint64(0, num, false)\n\nconst floatTestBed = new DataView(new ArrayBuffer(4))\n/**\n * Check if a number can be encoded as a 32 bit float.\n *\n * @param {number} num\n * @return {boolean}\n */\nconst isFloat32 = num => {\n  floatTestBed.setFloat32(0, num)\n  return floatTestBed.getFloat32(0) === num\n}\n\n/**\n * Encode data with efficient binary format.\n *\n * Differences to JSON:\n *  Transforms data to a binary format (not to a string)\n *  Encodes undefined, NaN, and ArrayBuffer (these can't be represented in JSON)\n *  Numbers are efficiently encoded either as a variable length integer, as a\n *   32 bit float, as a 64 bit float, or as a 64 bit bigint.\n *\n * Encoding table:\n *\n * | Data Type           | Prefix   | Encoding Method    | Comment |\n * | ------------------- | -------- | ------------------ | ------- |\n * | undefined           | 127      |                    | Functions, symbol, and everything that cannot be identified is encoded as undefined |\n * | null                | 126      |                    | |\n * | integer             | 125      | writeVarInt        | Only encodes 32 bit signed integers |\n * | float32             | 124      | writeFloat32       | |\n * | float64             | 123      | writeFloat64       | |\n * | bigint              | 122      | writeBigInt64      | |\n * | boolean (false)     | 121      |                    | True and false are different data types so we save the following byte |\n * | boolean (true)      | 120      |                    | - 0b01111000 so the last bit determines whether true or false |\n * | string              | 119      | writeVarString     | |\n * | object<string,any>  | 118      | custom             | Writes {length} then {length} key-value pairs |\n * | array<any>          | 117      | custom             | Writes {length} then {length} json values |\n * | Uint8Array          | 116      | writeVarUint8Array | We use Uint8Array for any kind of binary data |\n *\n * Reasons for the decreasing prefix:\n * We need the first bit for extendability (later we may want to encode the\n * prefix with writeVarUint). The remaining 7 bits are divided as follows:\n * [0-30]   the beginning of the data range is used for custom purposes\n *          (defined by the function that uses this library)\n * [31-127] the end of the data range is used for data encoding by\n *          lib0/encoding.js\n *\n * @param {Encoder} encoder\n * @param {undefined|null|number|bigint|boolean|string|Object<string,any>|Array<any>|Uint8Array} data\n */\nexport const writeAny = (encoder, data) => {\n  switch (typeof data) {\n    case 'string':\n      // TYPE 119: STRING\n      write(encoder, 119)\n      writeVarString(encoder, data)\n      break\n    case 'number':\n      if (number.isInteger(data) && math.abs(data) <= binary.BITS31) {\n        // TYPE 125: INTEGER\n        write(encoder, 125)\n        writeVarInt(encoder, data)\n      } else if (isFloat32(data)) {\n        // TYPE 124: FLOAT32\n        write(encoder, 124)\n        writeFloat32(encoder, data)\n      } else {\n        // TYPE 123: FLOAT64\n        write(encoder, 123)\n        writeFloat64(encoder, data)\n      }\n      break\n    case 'bigint':\n      // TYPE 122: BigInt\n      write(encoder, 122)\n      writeBigInt64(encoder, data)\n      break\n    case 'object':\n      if (data === null) {\n        // TYPE 126: null\n        write(encoder, 126)\n      } else if (array.isArray(data)) {\n        // TYPE 117: Array\n        write(encoder, 117)\n        writeVarUint(encoder, data.length)\n        for (let i = 0; i < data.length; i++) {\n          writeAny(encoder, data[i])\n        }\n      } else if (data instanceof Uint8Array) {\n        // TYPE 116: ArrayBuffer\n        write(encoder, 116)\n        writeVarUint8Array(encoder, data)\n      } else {\n        // TYPE 118: Object\n        write(encoder, 118)\n        const keys = Object.keys(data)\n        writeVarUint(encoder, keys.length)\n        for (let i = 0; i < keys.length; i++) {\n          const key = keys[i]\n          writeVarString(encoder, key)\n          writeAny(encoder, data[key])\n        }\n      }\n      break\n    case 'boolean':\n      // TYPE 120/121: boolean (true/false)\n      write(encoder, data ? 120 : 121)\n      break\n    default:\n      // TYPE 127: undefined\n      write(encoder, 127)\n  }\n}\n\n/**\n * Now come a few stateful encoder that have their own classes.\n */\n\n/**\n * Basic Run Length Encoder - a basic compression implementation.\n *\n * Encodes [1,1,1,7] to [1,3,7,1] (3 times 1, 1 time 7). This encoder might do more harm than good if there are a lot of values that are not repeated.\n *\n * It was originally used for image compression. Cool .. article http://csbruce.com/cbm/transactor/pdfs/trans_v7_i06.pdf\n *\n * @note T must not be null!\n *\n * @template T\n */\nexport class RleEncoder extends Encoder {\n  /**\n   * @param {function(Encoder, T):void} writer\n   */\n  constructor (writer) {\n    super()\n    /**\n     * The writer\n     */\n    this.w = writer\n    /**\n     * Current state\n     * @type {T|null}\n     */\n    this.s = null\n    this.count = 0\n  }\n\n  /**\n   * @param {T} v\n   */\n  write (v) {\n    if (this.s === v) {\n      this.count++\n    } else {\n      if (this.count > 0) {\n        // flush counter, unless this is the first value (count = 0)\n        writeVarUint(this, this.count - 1) // since count is always > 0, we can decrement by one. non-standard encoding ftw\n      }\n      this.count = 1\n      // write first value\n      this.w(this, v)\n      this.s = v\n    }\n  }\n}\n\n/**\n * Basic diff decoder using variable length encoding.\n *\n * Encodes the values [3, 1100, 1101, 1050, 0] to [3, 1097, 1, -51, -1050] using writeVarInt.\n */\nexport class IntDiffEncoder extends Encoder {\n  /**\n   * @param {number} start\n   */\n  constructor (start) {\n    super()\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    writeVarInt(this, v - this.s)\n    this.s = v\n  }\n}\n\n/**\n * A combination of IntDiffEncoder and RleEncoder.\n *\n * Basically first writes the IntDiffEncoder and then counts duplicate diffs using RleEncoding.\n *\n * Encodes the values [1,1,1,2,3,4,5,6] as [1,1,0,2,1,5] (RLE([1,0,0,1,1,1,1,1])  RleIntDiff[1,1,0,2,1,5])\n */\nexport class RleIntDiffEncoder extends Encoder {\n  /**\n   * @param {number} start\n   */\n  constructor (start) {\n    super()\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start\n    this.count = 0\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.s === v && this.count > 0) {\n      this.count++\n    } else {\n      if (this.count > 0) {\n        // flush counter, unless this is the first value (count = 0)\n        writeVarUint(this, this.count - 1) // since count is always > 0, we can decrement by one. non-standard encoding ftw\n      }\n      this.count = 1\n      // write first value\n      writeVarInt(this, v - this.s)\n      this.s = v\n    }\n  }\n}\n\n/**\n * @param {UintOptRleEncoder} encoder\n */\nconst flushUintOptRleEncoder = encoder => {\n  if (encoder.count > 0) {\n    // flush counter, unless this is the first value (count = 0)\n    // case 1: just a single value. set sign to positive\n    // case 2: write several values. set sign to negative to indicate that there is a length coming\n    writeVarInt(encoder.encoder, encoder.count === 1 ? encoder.s : -encoder.s)\n    if (encoder.count > 1) {\n      writeVarUint(encoder.encoder, encoder.count - 2) // since count is always > 1, we can decrement by one. non-standard encoding ftw\n    }\n  }\n}\n\n/**\n * Optimized Rle encoder that does not suffer from the mentioned problem of the basic Rle encoder.\n *\n * Internally uses VarInt encoder to write unsigned integers. If the input occurs multiple times, we write\n * write it as a negative number. The UintOptRleDecoder then understands that it needs to read a count.\n *\n * Encodes [1,2,3,3,3] as [1,2,-3,3] (once 1, once 2, three times 3)\n */\nexport class UintOptRleEncoder {\n  constructor () {\n    this.encoder = new Encoder()\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.s === v) {\n      this.count++\n    } else {\n      flushUintOptRleEncoder(this)\n      this.count = 1\n      this.s = v\n    }\n  }\n\n  /**\n   * Flush the encoded state and transform this to a Uint8Array.\n   *\n   * Note that this should only be called once.\n   */\n  toUint8Array () {\n    flushUintOptRleEncoder(this)\n    return toUint8Array(this.encoder)\n  }\n}\n\n/**\n * Increasing Uint Optimized RLE Encoder\n *\n * The RLE encoder counts the number of same occurences of the same value.\n * The IncUintOptRle encoder counts if the value increases.\n * I.e. 7, 8, 9, 10 will be encoded as [-7, 4]. 1, 3, 5 will be encoded\n * as [1, 3, 5].\n */\nexport class IncUintOptRleEncoder {\n  constructor () {\n    this.encoder = new Encoder()\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.s + this.count === v) {\n      this.count++\n    } else {\n      flushUintOptRleEncoder(this)\n      this.count = 1\n      this.s = v\n    }\n  }\n\n  /**\n   * Flush the encoded state and transform this to a Uint8Array.\n   *\n   * Note that this should only be called once.\n   */\n  toUint8Array () {\n    flushUintOptRleEncoder(this)\n    return toUint8Array(this.encoder)\n  }\n}\n\n/**\n * @param {IntDiffOptRleEncoder} encoder\n */\nconst flushIntDiffOptRleEncoder = encoder => {\n  if (encoder.count > 0) {\n    //          31 bit making up the diff | wether to write the counter\n    // const encodedDiff = encoder.diff << 1 | (encoder.count === 1 ? 0 : 1)\n    const encodedDiff = encoder.diff * 2 + (encoder.count === 1 ? 0 : 1)\n    // flush counter, unless this is the first value (count = 0)\n    // case 1: just a single value. set first bit to positive\n    // case 2: write several values. set first bit to negative to indicate that there is a length coming\n    writeVarInt(encoder.encoder, encodedDiff)\n    if (encoder.count > 1) {\n      writeVarUint(encoder.encoder, encoder.count - 2) // since count is always > 1, we can decrement by one. non-standard encoding ftw\n    }\n  }\n}\n\n/**\n * A combination of the IntDiffEncoder and the UintOptRleEncoder.\n *\n * The count approach is similar to the UintDiffOptRleEncoder, but instead of using the negative bitflag, it encodes\n * in the LSB whether a count is to be read. Therefore this Encoder only supports 31 bit integers!\n *\n * Encodes [1, 2, 3, 2] as [3, 1, 6, -1] (more specifically [(1 << 1) | 1, (3 << 0) | 0, -1])\n *\n * Internally uses variable length encoding. Contrary to normal UintVar encoding, the first byte contains:\n * * 1 bit that denotes whether the next value is a count (LSB)\n * * 1 bit that denotes whether this value is negative (MSB - 1)\n * * 1 bit that denotes whether to continue reading the variable length integer (MSB)\n *\n * Therefore, only five bits remain to encode diff ranges.\n *\n * Use this Encoder only when appropriate. In most cases, this is probably a bad idea.\n */\nexport class IntDiffOptRleEncoder {\n  constructor () {\n    this.encoder = new Encoder()\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n    this.diff = 0\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.diff === v - this.s) {\n      this.s = v\n      this.count++\n    } else {\n      flushIntDiffOptRleEncoder(this)\n      this.count = 1\n      this.diff = v - this.s\n      this.s = v\n    }\n  }\n\n  /**\n   * Flush the encoded state and transform this to a Uint8Array.\n   *\n   * Note that this should only be called once.\n   */\n  toUint8Array () {\n    flushIntDiffOptRleEncoder(this)\n    return toUint8Array(this.encoder)\n  }\n}\n\n/**\n * Optimized String Encoder.\n *\n * Encoding many small strings in a simple Encoder is not very efficient. The function call to decode a string takes some time and creates references that must be eventually deleted.\n * In practice, when decoding several million small strings, the GC will kick in more and more often to collect orphaned string objects (or maybe there is another reason?).\n *\n * This string encoder solves the above problem. All strings are concatenated and written as a single string using a single encoding call.\n *\n * The lengths are encoded using a UintOptRleEncoder.\n */\nexport class StringEncoder {\n  constructor () {\n    /**\n     * @type {Array<string>}\n     */\n    this.sarr = []\n    this.s = ''\n    this.lensE = new UintOptRleEncoder()\n  }\n\n  /**\n   * @param {string} string\n   */\n  write (string) {\n    this.s += string\n    if (this.s.length > 19) {\n      this.sarr.push(this.s)\n      this.s = ''\n    }\n    this.lensE.write(string.length)\n  }\n\n  toUint8Array () {\n    const encoder = new Encoder()\n    this.sarr.push(this.s)\n    this.s = ''\n    writeVarString(encoder, this.sarr.join(''))\n    writeUint8Array(encoder, this.lensE.toUint8Array())\n    return toUint8Array(encoder)\n  }\n}\n","/**\n * Utility helpers for working with numbers.\n *\n * @module number\n */\n\nimport * as math from './math.js'\nimport * as binary from './binary.js'\n\nexport const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER\nexport const MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER\n\nexport const LOWEST_INT32 = 1 << 31\nexport const HIGHEST_INT32 = binary.BITS31\nexport const HIGHEST_UINT32 = binary.BITS32\n\n/* c8 ignore next */\nexport const isInteger = Number.isInteger || (num => typeof num === 'number' && isFinite(num) && math.floor(num) === num)\nexport const isNaN = Number.isNaN\nexport const parseInt = Number.parseInt\n\n/**\n * Count the number of \"1\" bits in an unsigned 32bit number.\n *\n * Super fun bitcount algorithm by Brian Kernighan.\n *\n * @param {number} n\n */\nexport const countBits = n => {\n  n &= binary.BITS32\n  let count = 0\n  while (n) {\n    n &= (n - 1)\n    count++\n  }\n  return count\n}\n","/**\n * Error helpers.\n *\n * @module error\n */\n\n/**\n * @param {string} s\n * @return {Error}\n */\n/* c8 ignore next */\nexport const create = s => new Error(s)\n\n/**\n * @throws {Error}\n * @return {never}\n */\n/* c8 ignore next 3 */\nexport const methodUnimplemented = () => {\n  throw create('Method unimplemented')\n}\n\n/**\n * @throws {Error}\n * @return {never}\n */\n/* c8 ignore next 3 */\nexport const unexpectedCase = () => {\n  throw create('Unexpected case')\n}\n","/**\n * Efficient schema-less binary decoding with support for variable length encoding.\n *\n * Use [lib0/decoding] with [lib0/encoding]. Every encoding function has a corresponding decoding function.\n *\n * Encodes numbers in little-endian order (least to most significant byte order)\n * and is compatible with Golang's binary encoding (https://golang.org/pkg/encoding/binary/)\n * which is also used in Protocol Buffers.\n *\n * ```js\n * // encoding step\n * const encoder = encoding.createEncoder()\n * encoding.writeVarUint(encoder, 256)\n * encoding.writeVarString(encoder, 'Hello world!')\n * const buf = encoding.toUint8Array(encoder)\n * ```\n *\n * ```js\n * // decoding step\n * const decoder = decoding.createDecoder(buf)\n * decoding.readVarUint(decoder) // => 256\n * decoding.readVarString(decoder) // => 'Hello world!'\n * decoding.hasContent(decoder) // => false - all data is read\n * ```\n *\n * @module decoding\n */\n\nimport * as binary from './binary.js'\nimport * as math from './math.js'\nimport * as number from './number.js'\nimport * as string from './string.js'\nimport * as error from './error.js'\nimport * as encoding from './encoding.js'\n\nconst errorUnexpectedEndOfArray = error.create('Unexpected end of array')\nconst errorIntegerOutOfRange = error.create('Integer out of Range')\n\n/**\n * A Decoder handles the decoding of an Uint8Array.\n */\nexport class Decoder {\n  /**\n   * @param {Uint8Array} uint8Array Binary data to decode\n   */\n  constructor (uint8Array) {\n    /**\n     * Decoding target.\n     *\n     * @type {Uint8Array}\n     */\n    this.arr = uint8Array\n    /**\n     * Current decoding position.\n     *\n     * @type {number}\n     */\n    this.pos = 0\n  }\n}\n\n/**\n * @function\n * @param {Uint8Array} uint8Array\n * @return {Decoder}\n */\nexport const createDecoder = uint8Array => new Decoder(uint8Array)\n\n/**\n * @function\n * @param {Decoder} decoder\n * @return {boolean}\n */\nexport const hasContent = decoder => decoder.pos !== decoder.arr.length\n\n/**\n * Clone a decoder instance.\n * Optionally set a new position parameter.\n *\n * @function\n * @param {Decoder} decoder The decoder instance\n * @param {number} [newPos] Defaults to current position\n * @return {Decoder} A clone of `decoder`\n */\nexport const clone = (decoder, newPos = decoder.pos) => {\n  const _decoder = createDecoder(decoder.arr)\n  _decoder.pos = newPos\n  return _decoder\n}\n\n/**\n * Create an Uint8Array view of the next `len` bytes and advance the position by `len`.\n *\n * Important: The Uint8Array still points to the underlying ArrayBuffer. Make sure to discard the result as soon as possible to prevent any memory leaks.\n *            Use `buffer.copyUint8Array` to copy the result into a new Uint8Array.\n *\n * @function\n * @param {Decoder} decoder The decoder instance\n * @param {number} len The length of bytes to read\n * @return {Uint8Array}\n */\nexport const readUint8Array = (decoder, len) => {\n  const view = new Uint8Array(decoder.arr.buffer, decoder.pos + decoder.arr.byteOffset, len)\n  decoder.pos += len\n  return view\n}\n\n/**\n * Read variable length Uint8Array.\n *\n * Important: The Uint8Array still points to the underlying ArrayBuffer. Make sure to discard the result as soon as possible to prevent any memory leaks.\n *            Use `buffer.copyUint8Array` to copy the result into a new Uint8Array.\n *\n * @function\n * @param {Decoder} decoder\n * @return {Uint8Array}\n */\nexport const readVarUint8Array = decoder => readUint8Array(decoder, readVarUint(decoder))\n\n/**\n * Read the rest of the content as an ArrayBuffer\n * @function\n * @param {Decoder} decoder\n * @return {Uint8Array}\n */\nexport const readTailAsUint8Array = decoder => readUint8Array(decoder, decoder.arr.length - decoder.pos)\n\n/**\n * Skip one byte, jump to the next position.\n * @function\n * @param {Decoder} decoder The decoder instance\n * @return {number} The next position\n */\nexport const skip8 = decoder => decoder.pos++\n\n/**\n * Read one byte as unsigned integer.\n * @function\n * @param {Decoder} decoder The decoder instance\n * @return {number} Unsigned 8-bit integer\n */\nexport const readUint8 = decoder => decoder.arr[decoder.pos++]\n\n/**\n * Read 2 bytes as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const readUint16 = decoder => {\n  const uint =\n    decoder.arr[decoder.pos] +\n    (decoder.arr[decoder.pos + 1] << 8)\n  decoder.pos += 2\n  return uint\n}\n\n/**\n * Read 4 bytes as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const readUint32 = decoder => {\n  const uint =\n    (decoder.arr[decoder.pos] +\n    (decoder.arr[decoder.pos + 1] << 8) +\n    (decoder.arr[decoder.pos + 2] << 16) +\n    (decoder.arr[decoder.pos + 3] << 24)) >>> 0\n  decoder.pos += 4\n  return uint\n}\n\n/**\n * Read 4 bytes as unsigned integer in big endian order.\n * (most significant byte first)\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const readUint32BigEndian = decoder => {\n  const uint =\n    (decoder.arr[decoder.pos + 3] +\n    (decoder.arr[decoder.pos + 2] << 8) +\n    (decoder.arr[decoder.pos + 1] << 16) +\n    (decoder.arr[decoder.pos] << 24)) >>> 0\n  decoder.pos += 4\n  return uint\n}\n\n/**\n * Look ahead without incrementing the position\n * to the next byte and read it as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const peekUint8 = decoder => decoder.arr[decoder.pos]\n\n/**\n * Look ahead without incrementing the position\n * to the next byte and read it as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const peekUint16 = decoder =>\n  decoder.arr[decoder.pos] +\n  (decoder.arr[decoder.pos + 1] << 8)\n\n/**\n * Look ahead without incrementing the position\n * to the next byte and read it as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const peekUint32 = decoder => (\n  decoder.arr[decoder.pos] +\n  (decoder.arr[decoder.pos + 1] << 8) +\n  (decoder.arr[decoder.pos + 2] << 16) +\n  (decoder.arr[decoder.pos + 3] << 24)\n) >>> 0\n\n/**\n * Read unsigned integer (32bit) with variable length.\n * 1/8th of the storage is used as encoding overhead.\n *  * numbers < 2^7 is stored in one bytlength\n *  * numbers < 2^14 is stored in two bylength\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.length\n */\nexport const readVarUint = decoder => {\n  let num = 0\n  let mult = 1\n  const len = decoder.arr.length\n  while (decoder.pos < len) {\n    const r = decoder.arr[decoder.pos++]\n    // num = num | ((r & binary.BITS7) << len)\n    num = num + (r & binary.BITS7) * mult // shift $r << (7*#iterations) and add it to num\n    mult *= 128 // next iteration, shift 7 \"more\" to the left\n    if (r < binary.BIT8) {\n      return num\n    }\n    /* c8 ignore start */\n    if (num > number.MAX_SAFE_INTEGER) {\n      throw errorIntegerOutOfRange\n    }\n    /* c8 ignore stop */\n  }\n  throw errorUnexpectedEndOfArray\n}\n\n/**\n * Read signed integer (32bit) with variable length.\n * 1/8th of the storage is used as encoding overhead.\n *  * numbers < 2^7 is stored in one bytlength\n *  * numbers < 2^14 is stored in two bylength\n * @todo This should probably create the inverse ~num if number is negative - but this would be a breaking change.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.length\n */\nexport const readVarInt = decoder => {\n  let r = decoder.arr[decoder.pos++]\n  let num = r & binary.BITS6\n  let mult = 64\n  const sign = (r & binary.BIT7) > 0 ? -1 : 1\n  if ((r & binary.BIT8) === 0) {\n    // don't continue reading\n    return sign * num\n  }\n  const len = decoder.arr.length\n  while (decoder.pos < len) {\n    r = decoder.arr[decoder.pos++]\n    // num = num | ((r & binary.BITS7) << len)\n    num = num + (r & binary.BITS7) * mult\n    mult *= 128\n    if (r < binary.BIT8) {\n      return sign * num\n    }\n    /* c8 ignore start */\n    if (num > number.MAX_SAFE_INTEGER) {\n      throw errorIntegerOutOfRange\n    }\n    /* c8 ignore stop */\n  }\n  throw errorUnexpectedEndOfArray\n}\n\n/**\n * Look ahead and read varUint without incrementing position\n *\n * @function\n * @param {Decoder} decoder\n * @return {number}\n */\nexport const peekVarUint = decoder => {\n  const pos = decoder.pos\n  const s = readVarUint(decoder)\n  decoder.pos = pos\n  return s\n}\n\n/**\n * Look ahead and read varUint without incrementing position\n *\n * @function\n * @param {Decoder} decoder\n * @return {number}\n */\nexport const peekVarInt = decoder => {\n  const pos = decoder.pos\n  const s = readVarInt(decoder)\n  decoder.pos = pos\n  return s\n}\n\n/**\n * We don't test this function anymore as we use native decoding/encoding by default now.\n * Better not modify this anymore..\n *\n * Transforming utf8 to a string is pretty expensive. The code performs 10x better\n * when String.fromCodePoint is fed with all characters as arguments.\n * But most environments have a maximum number of arguments per functions.\n * For effiency reasons we apply a maximum of 10000 characters at once.\n *\n * @function\n * @param {Decoder} decoder\n * @return {String} The read String.\n */\n/* c8 ignore start */\nexport const _readVarStringPolyfill = decoder => {\n  let remainingLen = readVarUint(decoder)\n  if (remainingLen === 0) {\n    return ''\n  } else {\n    let encodedString = String.fromCodePoint(readUint8(decoder)) // remember to decrease remainingLen\n    if (--remainingLen < 100) { // do not create a Uint8Array for small strings\n      while (remainingLen--) {\n        encodedString += String.fromCodePoint(readUint8(decoder))\n      }\n    } else {\n      while (remainingLen > 0) {\n        const nextLen = remainingLen < 10000 ? remainingLen : 10000\n        // this is dangerous, we create a fresh array view from the existing buffer\n        const bytes = decoder.arr.subarray(decoder.pos, decoder.pos + nextLen)\n        decoder.pos += nextLen\n        // Starting with ES5.1 we can supply a generic array-like object as arguments\n        encodedString += String.fromCodePoint.apply(null, /** @type {any} */ (bytes))\n        remainingLen -= nextLen\n      }\n    }\n    return decodeURIComponent(escape(encodedString))\n  }\n}\n/* c8 ignore stop */\n\n/**\n * @function\n * @param {Decoder} decoder\n * @return {String} The read String\n */\nexport const _readVarStringNative = decoder =>\n  /** @type any */ (string.utf8TextDecoder).decode(readVarUint8Array(decoder))\n\n/**\n * Read string of variable length\n * * varUint is used to store the length of the string\n *\n * @function\n * @param {Decoder} decoder\n * @return {String} The read String\n *\n */\n/* c8 ignore next */\nexport const readVarString = string.utf8TextDecoder ? _readVarStringNative : _readVarStringPolyfill\n\n/**\n * @param {Decoder} decoder\n * @return {Uint8Array}\n */\nexport const readTerminatedUint8Array = decoder => {\n  const encoder = encoding.createEncoder()\n  let b\n  while (true) {\n    b = readUint8(decoder)\n    if (b === 0) {\n      return encoding.toUint8Array(encoder)\n    }\n    if (b === 1) {\n      b = readUint8(decoder)\n    }\n    encoding.write(encoder, b)\n  }\n}\n\n/**\n * @param {Decoder} decoder\n * @return {string}\n */\nexport const readTerminatedString = decoder => string.decodeUtf8(readTerminatedUint8Array(decoder))\n\n/**\n * Look ahead and read varString without incrementing position\n *\n * @function\n * @param {Decoder} decoder\n * @return {string}\n */\nexport const peekVarString = decoder => {\n  const pos = decoder.pos\n  const s = readVarString(decoder)\n  decoder.pos = pos\n  return s\n}\n\n/**\n * @param {Decoder} decoder\n * @param {number} len\n * @return {DataView}\n */\nexport const readFromDataView = (decoder, len) => {\n  const dv = new DataView(decoder.arr.buffer, decoder.arr.byteOffset + decoder.pos, len)\n  decoder.pos += len\n  return dv\n}\n\n/**\n * @param {Decoder} decoder\n */\nexport const readFloat32 = decoder => readFromDataView(decoder, 4).getFloat32(0, false)\n\n/**\n * @param {Decoder} decoder\n */\nexport const readFloat64 = decoder => readFromDataView(decoder, 8).getFloat64(0, false)\n\n/**\n * @param {Decoder} decoder\n */\nexport const readBigInt64 = decoder => /** @type {any} */ (readFromDataView(decoder, 8)).getBigInt64(0, false)\n\n/**\n * @param {Decoder} decoder\n */\nexport const readBigUint64 = decoder => /** @type {any} */ (readFromDataView(decoder, 8)).getBigUint64(0, false)\n\n/**\n * @type {Array<function(Decoder):any>}\n */\nconst readAnyLookupTable = [\n  decoder => undefined, // CASE 127: undefined\n  decoder => null, // CASE 126: null\n  readVarInt, // CASE 125: integer\n  readFloat32, // CASE 124: float32\n  readFloat64, // CASE 123: float64\n  readBigInt64, // CASE 122: bigint\n  decoder => false, // CASE 121: boolean (false)\n  decoder => true, // CASE 120: boolean (true)\n  readVarString, // CASE 119: string\n  decoder => { // CASE 118: object<string,any>\n    const len = readVarUint(decoder)\n    /**\n     * @type {Object<string,any>}\n     */\n    const obj = {}\n    for (let i = 0; i < len; i++) {\n      const key = readVarString(decoder)\n      obj[key] = readAny(decoder)\n    }\n    return obj\n  },\n  decoder => { // CASE 117: array<any>\n    const len = readVarUint(decoder)\n    const arr = []\n    for (let i = 0; i < len; i++) {\n      arr.push(readAny(decoder))\n    }\n    return arr\n  },\n  readVarUint8Array // CASE 116: Uint8Array\n]\n\n/**\n * @param {Decoder} decoder\n */\nexport const readAny = decoder => readAnyLookupTable[127 - readUint8(decoder)](decoder)\n\n/**\n * T must not be null.\n *\n * @template T\n */\nexport class RleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   * @param {function(Decoder):T} reader\n   */\n  constructor (uint8Array, reader) {\n    super(uint8Array)\n    /**\n     * The reader\n     */\n    this.reader = reader\n    /**\n     * Current state\n     * @type {T|null}\n     */\n    this.s = null\n    this.count = 0\n  }\n\n  read () {\n    if (this.count === 0) {\n      this.s = this.reader(this)\n      if (hasContent(this)) {\n        this.count = readVarUint(this) + 1 // see encoder implementation for the reason why this is incremented\n      } else {\n        this.count = -1 // read the current value forever\n      }\n    }\n    this.count--\n    return /** @type {T} */ (this.s)\n  }\n}\n\nexport class IntDiffDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   * @param {number} start\n   */\n  constructor (uint8Array, start) {\n    super(uint8Array)\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start\n  }\n\n  /**\n   * @return {number}\n   */\n  read () {\n    this.s += readVarInt(this)\n    return this.s\n  }\n}\n\nexport class RleIntDiffDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   * @param {number} start\n   */\n  constructor (uint8Array, start) {\n    super(uint8Array)\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start\n    this.count = 0\n  }\n\n  /**\n   * @return {number}\n   */\n  read () {\n    if (this.count === 0) {\n      this.s += readVarInt(this)\n      if (hasContent(this)) {\n        this.count = readVarUint(this) + 1 // see encoder implementation for the reason why this is incremented\n      } else {\n        this.count = -1 // read the current value forever\n      }\n    }\n    this.count--\n    return /** @type {number} */ (this.s)\n  }\n}\n\nexport class UintOptRleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    super(uint8Array)\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n  }\n\n  read () {\n    if (this.count === 0) {\n      this.s = readVarInt(this)\n      // if the sign is negative, we read the count too, otherwise count is 1\n      const isNegative = math.isNegativeZero(this.s)\n      this.count = 1\n      if (isNegative) {\n        this.s = -this.s\n        this.count = readVarUint(this) + 2\n      }\n    }\n    this.count--\n    return /** @type {number} */ (this.s)\n  }\n}\n\nexport class IncUintOptRleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    super(uint8Array)\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n  }\n\n  read () {\n    if (this.count === 0) {\n      this.s = readVarInt(this)\n      // if the sign is negative, we read the count too, otherwise count is 1\n      const isNegative = math.isNegativeZero(this.s)\n      this.count = 1\n      if (isNegative) {\n        this.s = -this.s\n        this.count = readVarUint(this) + 2\n      }\n    }\n    this.count--\n    return /** @type {number} */ (this.s++)\n  }\n}\n\nexport class IntDiffOptRleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    super(uint8Array)\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n    this.diff = 0\n  }\n\n  /**\n   * @return {number}\n   */\n  read () {\n    if (this.count === 0) {\n      const diff = readVarInt(this)\n      // if the first bit is set, we read more data\n      const hasCount = diff & 1\n      this.diff = math.floor(diff / 2) // shift >> 1\n      this.count = 1\n      if (hasCount) {\n        this.count = readVarUint(this) + 2\n      }\n    }\n    this.s += this.diff\n    this.count--\n    return this.s\n  }\n}\n\nexport class StringDecoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    this.decoder = new UintOptRleDecoder(uint8Array)\n    this.str = readVarString(this.decoder)\n    /**\n     * @type {number}\n     */\n    this.spos = 0\n  }\n\n  /**\n   * @return {string}\n   */\n  read () {\n    const end = this.spos + this.decoder.read()\n    const res = this.str.slice(this.spos, end)\n    this.spos = end\n    return res\n  }\n}\n","/**\n * Common Math expressions.\n *\n * @module math\n */\n\nexport const floor = Math.floor\nexport const ceil = Math.ceil\nexport const abs = Math.abs\nexport const imul = Math.imul\nexport const round = Math.round\nexport const log10 = Math.log10\nexport const log2 = Math.log2\nexport const log = Math.log\nexport const sqrt = Math.sqrt\n\n/**\n * @function\n * @param {number} a\n * @param {number} b\n * @return {number} The sum of a and b\n */\nexport const add = (a, b) => a + b\n\n/**\n * @function\n * @param {number} a\n * @param {number} b\n * @return {number} The smaller element of a and b\n */\nexport const min = (a, b) => a < b ? a : b\n\n/**\n * @function\n * @param {number} a\n * @param {number} b\n * @return {number} The bigger element of a and b\n */\nexport const max = (a, b) => a > b ? a : b\n\nexport const isNaN = Number.isNaN\n\nexport const pow = Math.pow\n/**\n * Base 10 exponential function. Returns the value of 10 raised to the power of pow.\n *\n * @param {number} exp\n * @return {number}\n */\nexport const exp10 = exp => Math.pow(10, exp)\n\nexport const sign = Math.sign\n\n/**\n * @param {number} n\n * @return {boolean} Wether n is negative. This function also differentiates between -0 and +0\n */\nexport const isNegativeZero = n => n !== 0 ? n < 0 : 1 / n < 0\n","/* eslint-env browser */\n\n/**\n * Binary data constants.\n *\n * @module binary\n */\n\n/**\n * n-th bit activated.\n *\n * @type {number}\n */\nexport const BIT1 = 1\nexport const BIT2 = 2\nexport const BIT3 = 4\nexport const BIT4 = 8\nexport const BIT5 = 16\nexport const BIT6 = 32\nexport const BIT7 = 64\nexport const BIT8 = 128\nexport const BIT9 = 256\nexport const BIT10 = 512\nexport const BIT11 = 1024\nexport const BIT12 = 2048\nexport const BIT13 = 4096\nexport const BIT14 = 8192\nexport const BIT15 = 16384\nexport const BIT16 = 32768\nexport const BIT17 = 65536\nexport const BIT18 = 1 << 17\nexport const BIT19 = 1 << 18\nexport const BIT20 = 1 << 19\nexport const BIT21 = 1 << 20\nexport const BIT22 = 1 << 21\nexport const BIT23 = 1 << 22\nexport const BIT24 = 1 << 23\nexport const BIT25 = 1 << 24\nexport const BIT26 = 1 << 25\nexport const BIT27 = 1 << 26\nexport const BIT28 = 1 << 27\nexport const BIT29 = 1 << 28\nexport const BIT30 = 1 << 29\nexport const BIT31 = 1 << 30\nexport const BIT32 = 1 << 31\n\n/**\n * First n bits activated.\n *\n * @type {number}\n */\nexport const BITS0 = 0\nexport const BITS1 = 1\nexport const BITS2 = 3\nexport const BITS3 = 7\nexport const BITS4 = 15\nexport const BITS5 = 31\nexport const BITS6 = 63\nexport const BITS7 = 127\nexport const BITS8 = 255\nexport const BITS9 = 511\nexport const BITS10 = 1023\nexport const BITS11 = 2047\nexport const BITS12 = 4095\nexport const BITS13 = 8191\nexport const BITS14 = 16383\nexport const BITS15 = 32767\nexport const BITS16 = 65535\nexport const BITS17 = BIT18 - 1\nexport const BITS18 = BIT19 - 1\nexport const BITS19 = BIT20 - 1\nexport const BITS20 = BIT21 - 1\nexport const BITS21 = BIT22 - 1\nexport const BITS22 = BIT23 - 1\nexport const BITS23 = BIT24 - 1\nexport const BITS24 = BIT25 - 1\nexport const BITS25 = BIT26 - 1\nexport const BITS26 = BIT27 - 1\nexport const BITS27 = BIT28 - 1\nexport const BITS28 = BIT29 - 1\nexport const BITS29 = BIT30 - 1\nexport const BITS30 = BIT31 - 1\n/**\n * @type {number}\n */\nexport const BITS31 = 0x7FFFFFFF\n/**\n * @type {number}\n */\nexport const BITS32 = 0xFFFFFFFF\n","import * as array from './array.js'\n\n/**\n * Utility module to work with strings.\n *\n * @module string\n */\n\nexport const fromCharCode = String.fromCharCode\nexport const fromCodePoint = String.fromCodePoint\n\n/**\n * The largest utf16 character.\n * Corresponds to Uint8Array([255, 255]) or charcodeof(2x2^8)\n */\nexport const MAX_UTF16_CHARACTER = fromCharCode(65535)\n\n/**\n * @param {string} s\n * @return {string}\n */\nconst toLowerCase = s => s.toLowerCase()\n\nconst trimLeftRegex = /^\\s*/g\n\n/**\n * @param {string} s\n * @return {string}\n */\nexport const trimLeft = s => s.replace(trimLeftRegex, '')\n\nconst fromCamelCaseRegex = /([A-Z])/g\n\n/**\n * @param {string} s\n * @param {string} separator\n * @return {string}\n */\nexport const fromCamelCase = (s, separator) => trimLeft(s.replace(fromCamelCaseRegex, match => `${separator}${toLowerCase(match)}`))\n\n/**\n * Compute the utf8ByteLength\n * @param {string} str\n * @return {number}\n */\nexport const utf8ByteLength = str => unescape(encodeURIComponent(str)).length\n\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\nexport const _encodeUtf8Polyfill = str => {\n  const encodedString = unescape(encodeURIComponent(str))\n  const len = encodedString.length\n  const buf = new Uint8Array(len)\n  for (let i = 0; i < len; i++) {\n    buf[i] = /** @type {number} */ (encodedString.codePointAt(i))\n  }\n  return buf\n}\n\n/* c8 ignore next */\nexport const utf8TextEncoder = /** @type {TextEncoder} */ (typeof TextEncoder !== 'undefined' ? new TextEncoder() : null)\n\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\nexport const _encodeUtf8Native = str => utf8TextEncoder.encode(str)\n\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\n/* c8 ignore next */\nexport const encodeUtf8 = utf8TextEncoder ? _encodeUtf8Native : _encodeUtf8Polyfill\n\n/**\n * @param {Uint8Array} buf\n * @return {string}\n */\nexport const _decodeUtf8Polyfill = buf => {\n  let remainingLen = buf.length\n  let encodedString = ''\n  let bufPos = 0\n  while (remainingLen > 0) {\n    const nextLen = remainingLen < 10000 ? remainingLen : 10000\n    const bytes = buf.subarray(bufPos, bufPos + nextLen)\n    bufPos += nextLen\n    // Starting with ES5.1 we can supply a generic array-like object as arguments\n    encodedString += String.fromCodePoint.apply(null, /** @type {any} */ (bytes))\n    remainingLen -= nextLen\n  }\n  return decodeURIComponent(escape(encodedString))\n}\n\n/* c8 ignore next */\nexport let utf8TextDecoder = typeof TextDecoder === 'undefined' ? null : new TextDecoder('utf-8', { fatal: true, ignoreBOM: true })\n\n/* c8 ignore start */\nif (utf8TextDecoder && utf8TextDecoder.decode(new Uint8Array()).length === 1) {\n  // Safari doesn't handle BOM correctly.\n  // This fixes a bug in Safari 13.0.5 where it produces a BOM the first time it is called.\n  // utf8TextDecoder.decode(new Uint8Array()).length === 1 on the first call and\n  // utf8TextDecoder.decode(new Uint8Array()).length === 1 on the second call\n  // Another issue is that from then on no BOM chars are recognized anymore\n  /* c8 ignore next */\n  utf8TextDecoder = null\n}\n/* c8 ignore stop */\n\n/**\n * @param {Uint8Array} buf\n * @return {string}\n */\nexport const _decodeUtf8Native = buf => /** @type {TextDecoder} */ (utf8TextDecoder).decode(buf)\n\n/**\n * @param {Uint8Array} buf\n * @return {string}\n */\n/* c8 ignore next */\nexport const decodeUtf8 = utf8TextDecoder ? _decodeUtf8Native : _decodeUtf8Polyfill\n\n/**\n * @param {string} str The initial string\n * @param {number} index Starting position\n * @param {number} remove Number of characters to remove\n * @param {string} insert New content to insert\n */\nexport const splice = (str, index, remove, insert = '') => str.slice(0, index) + insert + str.slice(index + remove)\n\n/**\n * @param {string} source\n * @param {number} n\n */\nexport const repeat = (source, n) => array.unfold(n, () => source).join('')\n\n/**\n * Escape HTML characters &,<,>,',\" to their respective HTML entities &amp;,&lt;,&gt;,&#39;,&quot;\n *\n * @param {string} str\n */\nexport const escapeHTML = str =>\n  str.replace(/[&<>'\"]/g, r => /** @type {string} */ ({\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    \"'\": '&#39;',\n    '\"': '&quot;'\n  }[r]))\n\n/**\n * Reverse of `escapeHTML`\n *\n * @param {string} str\n */\nexport const unescapeHTML = str =>\n  str.replace(/&amp;|&lt;|&gt;|&#39;|&quot;/g, r => /** @type {string} */ ({\n    '&amp;': '&',\n    '&lt;': '<',\n    '&gt;': '>',\n    '&#39;': \"'\",\n    '&quot;': '\"'\n  }[r]))\n","/**\n * Efficient schema-less binary encoding with support for variable length encoding.\n *\n * Use [lib0/encoding] with [lib0/decoding]. Every encoding function has a corresponding decoding function.\n *\n * Encodes numbers in little-endian order (least to most significant byte order)\n * and is compatible with Golang's binary encoding (https://golang.org/pkg/encoding/binary/)\n * which is also used in Protocol Buffers.\n *\n * ```js\n * // encoding step\n * const encoder = encoding.createEncoder()\n * encoding.writeVarUint(encoder, 256)\n * encoding.writeVarString(encoder, 'Hello world!')\n * const buf = encoding.toUint8Array(encoder)\n * ```\n *\n * ```js\n * // decoding step\n * const decoder = decoding.createDecoder(buf)\n * decoding.readVarUint(decoder) // => 256\n * decoding.readVarString(decoder) // => 'Hello world!'\n * decoding.hasContent(decoder) // => false - all data is read\n * ```\n *\n * @module encoding\n */\n\nimport * as math from './math.js'\nimport * as number from './number.js'\nimport * as binary from './binary.js'\nimport * as string from './string.js'\nimport * as array from './array.js'\n\n/**\n * A BinaryEncoder handles the encoding to an Uint8Array.\n */\nexport class Encoder {\n  constructor () {\n    this.cpos = 0\n    this.cbuf = new Uint8Array(100)\n    /**\n     * @type {Array<Uint8Array>}\n     */\n    this.bufs = []\n  }\n}\n\n/**\n * @function\n * @return {Encoder}\n */\nexport const createEncoder = () => new Encoder()\n\n/**\n * @param {function(Encoder):void} f\n */\nexport const encode = (f) => {\n  const encoder = createEncoder()\n  f(encoder)\n  return toUint8Array(encoder)\n}\n\n/**\n * The current length of the encoded data.\n *\n * @function\n * @param {Encoder} encoder\n * @return {number}\n */\nexport const length = encoder => {\n  let len = encoder.cpos\n  for (let i = 0; i < encoder.bufs.length; i++) {\n    len += encoder.bufs[i].length\n  }\n  return len\n}\n\n/**\n * Check whether encoder is empty.\n *\n * @function\n * @param {Encoder} encoder\n * @return {boolean}\n */\nexport const hasContent = encoder => encoder.cpos > 0 || encoder.bufs.length > 0\n\n/**\n * Transform to Uint8Array.\n *\n * @function\n * @param {Encoder} encoder\n * @return {Uint8Array} The created ArrayBuffer.\n */\nexport const toUint8Array = encoder => {\n  const uint8arr = new Uint8Array(length(encoder))\n  let curPos = 0\n  for (let i = 0; i < encoder.bufs.length; i++) {\n    const d = encoder.bufs[i]\n    uint8arr.set(d, curPos)\n    curPos += d.length\n  }\n  uint8arr.set(new Uint8Array(encoder.cbuf.buffer, 0, encoder.cpos), curPos)\n  return uint8arr\n}\n\n/**\n * Verify that it is possible to write `len` bytes wtihout checking. If\n * necessary, a new Buffer with the required length is attached.\n *\n * @param {Encoder} encoder\n * @param {number} len\n */\nexport const verifyLen = (encoder, len) => {\n  const bufferLen = encoder.cbuf.length\n  if (bufferLen - encoder.cpos < len) {\n    encoder.bufs.push(new Uint8Array(encoder.cbuf.buffer, 0, encoder.cpos))\n    encoder.cbuf = new Uint8Array(math.max(bufferLen, len) * 2)\n    encoder.cpos = 0\n  }\n}\n\n/**\n * Write one byte to the encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The byte that is to be encoded.\n */\nexport const write = (encoder, num) => {\n  const bufferLen = encoder.cbuf.length\n  if (encoder.cpos === bufferLen) {\n    encoder.bufs.push(encoder.cbuf)\n    encoder.cbuf = new Uint8Array(bufferLen * 2)\n    encoder.cpos = 0\n  }\n  encoder.cbuf[encoder.cpos++] = num\n}\n\n/**\n * Write one byte at a specific position.\n * Position must already be written (i.e. encoder.length > pos)\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos Position to which to write data\n * @param {number} num Unsigned 8-bit integer\n */\nexport const set = (encoder, pos, num) => {\n  let buffer = null\n  // iterate all buffers and adjust position\n  for (let i = 0; i < encoder.bufs.length && buffer === null; i++) {\n    const b = encoder.bufs[i]\n    if (pos < b.length) {\n      buffer = b // found buffer\n    } else {\n      pos -= b.length\n    }\n  }\n  if (buffer === null) {\n    // use current buffer\n    buffer = encoder.cbuf\n  }\n  buffer[pos] = num\n}\n\n/**\n * Write one byte as an unsigned integer.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeUint8 = write\n\n/**\n * Write one byte as an unsigned Integer at a specific location.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos The location where the data will be written.\n * @param {number} num The number that is to be encoded.\n */\nexport const setUint8 = set\n\n/**\n * Write two bytes as an unsigned integer.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeUint16 = (encoder, num) => {\n  write(encoder, num & binary.BITS8)\n  write(encoder, (num >>> 8) & binary.BITS8)\n}\n/**\n * Write two bytes as an unsigned integer at a specific location.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos The location where the data will be written.\n * @param {number} num The number that is to be encoded.\n */\nexport const setUint16 = (encoder, pos, num) => {\n  set(encoder, pos, num & binary.BITS8)\n  set(encoder, pos + 1, (num >>> 8) & binary.BITS8)\n}\n\n/**\n * Write two bytes as an unsigned integer\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeUint32 = (encoder, num) => {\n  for (let i = 0; i < 4; i++) {\n    write(encoder, num & binary.BITS8)\n    num >>>= 8\n  }\n}\n\n/**\n * Write two bytes as an unsigned integer in big endian order.\n * (most significant byte first)\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeUint32BigEndian = (encoder, num) => {\n  for (let i = 3; i >= 0; i--) {\n    write(encoder, (num >>> (8 * i)) & binary.BITS8)\n  }\n}\n\n/**\n * Write two bytes as an unsigned integer at a specific location.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos The location where the data will be written.\n * @param {number} num The number that is to be encoded.\n */\nexport const setUint32 = (encoder, pos, num) => {\n  for (let i = 0; i < 4; i++) {\n    set(encoder, pos + i, num & binary.BITS8)\n    num >>>= 8\n  }\n}\n\n/**\n * Write a variable length unsigned integer. Max encodable integer is 2^53.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeVarUint = (encoder, num) => {\n  while (num > binary.BITS7) {\n    write(encoder, binary.BIT8 | (binary.BITS7 & num))\n    num = math.floor(num / 128) // shift >>> 7\n  }\n  write(encoder, binary.BITS7 & num)\n}\n\n/**\n * Write a variable length integer.\n *\n * We use the 7th bit instead for signaling that this is a negative number.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeVarInt = (encoder, num) => {\n  const isNegative = math.isNegativeZero(num)\n  if (isNegative) {\n    num = -num\n  }\n  //             |- whether to continue reading         |- whether is negative     |- number\n  write(encoder, (num > binary.BITS6 ? binary.BIT8 : 0) | (isNegative ? binary.BIT7 : 0) | (binary.BITS6 & num))\n  num = math.floor(num / 64) // shift >>> 6\n  // We don't need to consider the case of num === 0 so we can use a different\n  // pattern here than above.\n  while (num > 0) {\n    write(encoder, (num > binary.BITS7 ? binary.BIT8 : 0) | (binary.BITS7 & num))\n    num = math.floor(num / 128) // shift >>> 7\n  }\n}\n\n/**\n * A cache to store strings temporarily\n */\nconst _strBuffer = new Uint8Array(30000)\nconst _maxStrBSize = _strBuffer.length / 3\n\n/**\n * Write a variable length string.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\nexport const _writeVarStringNative = (encoder, str) => {\n  if (str.length < _maxStrBSize) {\n    // We can encode the string into the existing buffer\n    /* c8 ignore next */\n    const written = string.utf8TextEncoder.encodeInto(str, _strBuffer).written || 0\n    writeVarUint(encoder, written)\n    for (let i = 0; i < written; i++) {\n      write(encoder, _strBuffer[i])\n    }\n  } else {\n    writeVarUint8Array(encoder, string.encodeUtf8(str))\n  }\n}\n\n/**\n * Write a variable length string.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\nexport const _writeVarStringPolyfill = (encoder, str) => {\n  const encodedString = unescape(encodeURIComponent(str))\n  const len = encodedString.length\n  writeVarUint(encoder, len)\n  for (let i = 0; i < len; i++) {\n    write(encoder, /** @type {number} */ (encodedString.codePointAt(i)))\n  }\n}\n\n/**\n * Write a variable length string.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\n/* c8 ignore next */\nexport const writeVarString = (string.utf8TextEncoder && /** @type {any} */ (string.utf8TextEncoder).encodeInto) ? _writeVarStringNative : _writeVarStringPolyfill\n\n/**\n * Write a string terminated by a special byte sequence. This is not very performant and is\n * generally discouraged. However, the resulting byte arrays are lexiographically ordered which\n * makes this a nice feature for databases.\n *\n * The string will be encoded using utf8 and then terminated and escaped using writeTerminatingUint8Array.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\nexport const writeTerminatedString = (encoder, str) =>\n  writeTerminatedUint8Array(encoder, string.encodeUtf8(str))\n\n/**\n * Write a terminating Uint8Array. Note that this is not performant and is generally\n * discouraged. There are few situations when this is needed.\n *\n * We use 0x0 as a terminating character. 0x1 serves as an escape character for 0x0 and 0x1.\n *\n * Example: [0,1,2] is encoded to [1,0,1,1,2,0]. 0x0, and 0x1 needed to be escaped using 0x1. Then\n * the result is terminated using the 0x0 character.\n *\n * This is basically how many systems implement null terminated strings. However, we use an escape\n * character 0x1 to avoid issues and potenial attacks on our database (if this is used as a key\n * encoder for NoSql databases).\n *\n * @function\n * @param {Encoder} encoder\n * @param {Uint8Array} buf The string that is to be encoded.\n */\nexport const writeTerminatedUint8Array = (encoder, buf) => {\n  for (let i = 0; i < buf.length; i++) {\n    const b = buf[i]\n    if (b === 0 || b === 1) {\n      write(encoder, 1)\n    }\n    write(encoder, buf[i])\n  }\n  write(encoder, 0)\n}\n\n/**\n * Write the content of another Encoder.\n *\n * @TODO: can be improved!\n *        - Note: Should consider that when appending a lot of small Encoders, we should rather clone than referencing the old structure.\n *                Encoders start with a rather big initial buffer.\n *\n * @function\n * @param {Encoder} encoder The enUint8Arr\n * @param {Encoder} append The BinaryEncoder to be written.\n */\nexport const writeBinaryEncoder = (encoder, append) => writeUint8Array(encoder, toUint8Array(append))\n\n/**\n * Append fixed-length Uint8Array to the encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {Uint8Array} uint8Array\n */\nexport const writeUint8Array = (encoder, uint8Array) => {\n  const bufferLen = encoder.cbuf.length\n  const cpos = encoder.cpos\n  const leftCopyLen = math.min(bufferLen - cpos, uint8Array.length)\n  const rightCopyLen = uint8Array.length - leftCopyLen\n  encoder.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos)\n  encoder.cpos += leftCopyLen\n  if (rightCopyLen > 0) {\n    // Still something to write, write right half..\n    // Append new buffer\n    encoder.bufs.push(encoder.cbuf)\n    // must have at least size of remaining buffer\n    encoder.cbuf = new Uint8Array(math.max(bufferLen * 2, rightCopyLen))\n    // copy array\n    encoder.cbuf.set(uint8Array.subarray(leftCopyLen))\n    encoder.cpos = rightCopyLen\n  }\n}\n\n/**\n * Append an Uint8Array to Encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {Uint8Array} uint8Array\n */\nexport const writeVarUint8Array = (encoder, uint8Array) => {\n  writeVarUint(encoder, uint8Array.byteLength)\n  writeUint8Array(encoder, uint8Array)\n}\n\n/**\n * Create an DataView of the next `len` bytes. Use it to write data after\n * calling this function.\n *\n * ```js\n * // write float32 using DataView\n * const dv = writeOnDataView(encoder, 4)\n * dv.setFloat32(0, 1.1)\n * // read float32 using DataView\n * const dv = readFromDataView(encoder, 4)\n * dv.getFloat32(0) // => 1.100000023841858 (leaving it to the reader to find out why this is the correct result)\n * ```\n *\n * @param {Encoder} encoder\n * @param {number} len\n * @return {DataView}\n */\nexport const writeOnDataView = (encoder, len) => {\n  verifyLen(encoder, len)\n  const dview = new DataView(encoder.cbuf.buffer, encoder.cpos, len)\n  encoder.cpos += len\n  return dview\n}\n\n/**\n * @param {Encoder} encoder\n * @param {number} num\n */\nexport const writeFloat32 = (encoder, num) => writeOnDataView(encoder, 4).setFloat32(0, num, false)\n\n/**\n * @param {Encoder} encoder\n * @param {number} num\n */\nexport const writeFloat64 = (encoder, num) => writeOnDataView(encoder, 8).setFloat64(0, num, false)\n\n/**\n * @param {Encoder} encoder\n * @param {bigint} num\n */\nexport const writeBigInt64 = (encoder, num) => /** @type {any} */ (writeOnDataView(encoder, 8)).setBigInt64(0, num, false)\n\n/**\n * @param {Encoder} encoder\n * @param {bigint} num\n */\nexport const writeBigUint64 = (encoder, num) => /** @type {any} */ (writeOnDataView(encoder, 8)).setBigUint64(0, num, false)\n\nconst floatTestBed = new DataView(new ArrayBuffer(4))\n/**\n * Check if a number can be encoded as a 32 bit float.\n *\n * @param {number} num\n * @return {boolean}\n */\nconst isFloat32 = num => {\n  floatTestBed.setFloat32(0, num)\n  return floatTestBed.getFloat32(0) === num\n}\n\n/**\n * Encode data with efficient binary format.\n *\n * Differences to JSON:\n *  Transforms data to a binary format (not to a string)\n *  Encodes undefined, NaN, and ArrayBuffer (these can't be represented in JSON)\n *  Numbers are efficiently encoded either as a variable length integer, as a\n *   32 bit float, as a 64 bit float, or as a 64 bit bigint.\n *\n * Encoding table:\n *\n * | Data Type           | Prefix   | Encoding Method    | Comment |\n * | ------------------- | -------- | ------------------ | ------- |\n * | undefined           | 127      |                    | Functions, symbol, and everything that cannot be identified is encoded as undefined |\n * | null                | 126      |                    | |\n * | integer             | 125      | writeVarInt        | Only encodes 32 bit signed integers |\n * | float32             | 124      | writeFloat32       | |\n * | float64             | 123      | writeFloat64       | |\n * | bigint              | 122      | writeBigInt64      | |\n * | boolean (false)     | 121      |                    | True and false are different data types so we save the following byte |\n * | boolean (true)      | 120      |                    | - 0b01111000 so the last bit determines whether true or false |\n * | string              | 119      | writeVarString     | |\n * | object<string,any>  | 118      | custom             | Writes {length} then {length} key-value pairs |\n * | array<any>          | 117      | custom             | Writes {length} then {length} json values |\n * | Uint8Array          | 116      | writeVarUint8Array | We use Uint8Array for any kind of binary data |\n *\n * Reasons for the decreasing prefix:\n * We need the first bit for extendability (later we may want to encode the\n * prefix with writeVarUint). The remaining 7 bits are divided as follows:\n * [0-30]   the beginning of the data range is used for custom purposes\n *          (defined by the function that uses this library)\n * [31-127] the end of the data range is used for data encoding by\n *          lib0/encoding.js\n *\n * @param {Encoder} encoder\n * @param {undefined|null|number|bigint|boolean|string|Object<string,any>|Array<any>|Uint8Array} data\n */\nexport const writeAny = (encoder, data) => {\n  switch (typeof data) {\n    case 'string':\n      // TYPE 119: STRING\n      write(encoder, 119)\n      writeVarString(encoder, data)\n      break\n    case 'number':\n      if (number.isInteger(data) && math.abs(data) <= binary.BITS31) {\n        // TYPE 125: INTEGER\n        write(encoder, 125)\n        writeVarInt(encoder, data)\n      } else if (isFloat32(data)) {\n        // TYPE 124: FLOAT32\n        write(encoder, 124)\n        writeFloat32(encoder, data)\n      } else {\n        // TYPE 123: FLOAT64\n        write(encoder, 123)\n        writeFloat64(encoder, data)\n      }\n      break\n    case 'bigint':\n      // TYPE 122: BigInt\n      write(encoder, 122)\n      writeBigInt64(encoder, data)\n      break\n    case 'object':\n      if (data === null) {\n        // TYPE 126: null\n        write(encoder, 126)\n      } else if (array.isArray(data)) {\n        // TYPE 117: Array\n        write(encoder, 117)\n        writeVarUint(encoder, data.length)\n        for (let i = 0; i < data.length; i++) {\n          writeAny(encoder, data[i])\n        }\n      } else if (data instanceof Uint8Array) {\n        // TYPE 116: ArrayBuffer\n        write(encoder, 116)\n        writeVarUint8Array(encoder, data)\n      } else {\n        // TYPE 118: Object\n        write(encoder, 118)\n        const keys = Object.keys(data)\n        writeVarUint(encoder, keys.length)\n        for (let i = 0; i < keys.length; i++) {\n          const key = keys[i]\n          writeVarString(encoder, key)\n          writeAny(encoder, data[key])\n        }\n      }\n      break\n    case 'boolean':\n      // TYPE 120/121: boolean (true/false)\n      write(encoder, data ? 120 : 121)\n      break\n    default:\n      // TYPE 127: undefined\n      write(encoder, 127)\n  }\n}\n\n/**\n * Now come a few stateful encoder that have their own classes.\n */\n\n/**\n * Basic Run Length Encoder - a basic compression implementation.\n *\n * Encodes [1,1,1,7] to [1,3,7,1] (3 times 1, 1 time 7). This encoder might do more harm than good if there are a lot of values that are not repeated.\n *\n * It was originally used for image compression. Cool .. article http://csbruce.com/cbm/transactor/pdfs/trans_v7_i06.pdf\n *\n * @note T must not be null!\n *\n * @template T\n */\nexport class RleEncoder extends Encoder {\n  /**\n   * @param {function(Encoder, T):void} writer\n   */\n  constructor (writer) {\n    super()\n    /**\n     * The writer\n     */\n    this.w = writer\n    /**\n     * Current state\n     * @type {T|null}\n     */\n    this.s = null\n    this.count = 0\n  }\n\n  /**\n   * @param {T} v\n   */\n  write (v) {\n    if (this.s === v) {\n      this.count++\n    } else {\n      if (this.count > 0) {\n        // flush counter, unless this is the first value (count = 0)\n        writeVarUint(this, this.count - 1) // since count is always > 0, we can decrement by one. non-standard encoding ftw\n      }\n      this.count = 1\n      // write first value\n      this.w(this, v)\n      this.s = v\n    }\n  }\n}\n\n/**\n * Basic diff decoder using variable length encoding.\n *\n * Encodes the values [3, 1100, 1101, 1050, 0] to [3, 1097, 1, -51, -1050] using writeVarInt.\n */\nexport class IntDiffEncoder extends Encoder {\n  /**\n   * @param {number} start\n   */\n  constructor (start) {\n    super()\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    writeVarInt(this, v - this.s)\n    this.s = v\n  }\n}\n\n/**\n * A combination of IntDiffEncoder and RleEncoder.\n *\n * Basically first writes the IntDiffEncoder and then counts duplicate diffs using RleEncoding.\n *\n * Encodes the values [1,1,1,2,3,4,5,6] as [1,1,0,2,1,5] (RLE([1,0,0,1,1,1,1,1])  RleIntDiff[1,1,0,2,1,5])\n */\nexport class RleIntDiffEncoder extends Encoder {\n  /**\n   * @param {number} start\n   */\n  constructor (start) {\n    super()\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start\n    this.count = 0\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.s === v && this.count > 0) {\n      this.count++\n    } else {\n      if (this.count > 0) {\n        // flush counter, unless this is the first value (count = 0)\n        writeVarUint(this, this.count - 1) // since count is always > 0, we can decrement by one. non-standard encoding ftw\n      }\n      this.count = 1\n      // write first value\n      writeVarInt(this, v - this.s)\n      this.s = v\n    }\n  }\n}\n\n/**\n * @param {UintOptRleEncoder} encoder\n */\nconst flushUintOptRleEncoder = encoder => {\n  if (encoder.count > 0) {\n    // flush counter, unless this is the first value (count = 0)\n    // case 1: just a single value. set sign to positive\n    // case 2: write several values. set sign to negative to indicate that there is a length coming\n    writeVarInt(encoder.encoder, encoder.count === 1 ? encoder.s : -encoder.s)\n    if (encoder.count > 1) {\n      writeVarUint(encoder.encoder, encoder.count - 2) // since count is always > 1, we can decrement by one. non-standard encoding ftw\n    }\n  }\n}\n\n/**\n * Optimized Rle encoder that does not suffer from the mentioned problem of the basic Rle encoder.\n *\n * Internally uses VarInt encoder to write unsigned integers. If the input occurs multiple times, we write\n * write it as a negative number. The UintOptRleDecoder then understands that it needs to read a count.\n *\n * Encodes [1,2,3,3,3] as [1,2,-3,3] (once 1, once 2, three times 3)\n */\nexport class UintOptRleEncoder {\n  constructor () {\n    this.encoder = new Encoder()\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.s === v) {\n      this.count++\n    } else {\n      flushUintOptRleEncoder(this)\n      this.count = 1\n      this.s = v\n    }\n  }\n\n  /**\n   * Flush the encoded state and transform this to a Uint8Array.\n   *\n   * Note that this should only be called once.\n   */\n  toUint8Array () {\n    flushUintOptRleEncoder(this)\n    return toUint8Array(this.encoder)\n  }\n}\n\n/**\n * Increasing Uint Optimized RLE Encoder\n *\n * The RLE encoder counts the number of same occurences of the same value.\n * The IncUintOptRle encoder counts if the value increases.\n * I.e. 7, 8, 9, 10 will be encoded as [-7, 4]. 1, 3, 5 will be encoded\n * as [1, 3, 5].\n */\nexport class IncUintOptRleEncoder {\n  constructor () {\n    this.encoder = new Encoder()\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.s + this.count === v) {\n      this.count++\n    } else {\n      flushUintOptRleEncoder(this)\n      this.count = 1\n      this.s = v\n    }\n  }\n\n  /**\n   * Flush the encoded state and transform this to a Uint8Array.\n   *\n   * Note that this should only be called once.\n   */\n  toUint8Array () {\n    flushUintOptRleEncoder(this)\n    return toUint8Array(this.encoder)\n  }\n}\n\n/**\n * @param {IntDiffOptRleEncoder} encoder\n */\nconst flushIntDiffOptRleEncoder = encoder => {\n  if (encoder.count > 0) {\n    //          31 bit making up the diff | wether to write the counter\n    // const encodedDiff = encoder.diff << 1 | (encoder.count === 1 ? 0 : 1)\n    const encodedDiff = encoder.diff * 2 + (encoder.count === 1 ? 0 : 1)\n    // flush counter, unless this is the first value (count = 0)\n    // case 1: just a single value. set first bit to positive\n    // case 2: write several values. set first bit to negative to indicate that there is a length coming\n    writeVarInt(encoder.encoder, encodedDiff)\n    if (encoder.count > 1) {\n      writeVarUint(encoder.encoder, encoder.count - 2) // since count is always > 1, we can decrement by one. non-standard encoding ftw\n    }\n  }\n}\n\n/**\n * A combination of the IntDiffEncoder and the UintOptRleEncoder.\n *\n * The count approach is similar to the UintDiffOptRleEncoder, but instead of using the negative bitflag, it encodes\n * in the LSB whether a count is to be read. Therefore this Encoder only supports 31 bit integers!\n *\n * Encodes [1, 2, 3, 2] as [3, 1, 6, -1] (more specifically [(1 << 1) | 1, (3 << 0) | 0, -1])\n *\n * Internally uses variable length encoding. Contrary to normal UintVar encoding, the first byte contains:\n * * 1 bit that denotes whether the next value is a count (LSB)\n * * 1 bit that denotes whether this value is negative (MSB - 1)\n * * 1 bit that denotes whether to continue reading the variable length integer (MSB)\n *\n * Therefore, only five bits remain to encode diff ranges.\n *\n * Use this Encoder only when appropriate. In most cases, this is probably a bad idea.\n */\nexport class IntDiffOptRleEncoder {\n  constructor () {\n    this.encoder = new Encoder()\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n    this.diff = 0\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.diff === v - this.s) {\n      this.s = v\n      this.count++\n    } else {\n      flushIntDiffOptRleEncoder(this)\n      this.count = 1\n      this.diff = v - this.s\n      this.s = v\n    }\n  }\n\n  /**\n   * Flush the encoded state and transform this to a Uint8Array.\n   *\n   * Note that this should only be called once.\n   */\n  toUint8Array () {\n    flushIntDiffOptRleEncoder(this)\n    return toUint8Array(this.encoder)\n  }\n}\n\n/**\n * Optimized String Encoder.\n *\n * Encoding many small strings in a simple Encoder is not very efficient. The function call to decode a string takes some time and creates references that must be eventually deleted.\n * In practice, when decoding several million small strings, the GC will kick in more and more often to collect orphaned string objects (or maybe there is another reason?).\n *\n * This string encoder solves the above problem. All strings are concatenated and written as a single string using a single encoding call.\n *\n * The lengths are encoded using a UintOptRleEncoder.\n */\nexport class StringEncoder {\n  constructor () {\n    /**\n     * @type {Array<string>}\n     */\n    this.sarr = []\n    this.s = ''\n    this.lensE = new UintOptRleEncoder()\n  }\n\n  /**\n   * @param {string} string\n   */\n  write (string) {\n    this.s += string\n    if (this.s.length > 19) {\n      this.sarr.push(this.s)\n      this.s = ''\n    }\n    this.lensE.write(string.length)\n  }\n\n  toUint8Array () {\n    const encoder = new Encoder()\n    this.sarr.push(this.s)\n    this.s = ''\n    writeVarString(encoder, this.sarr.join(''))\n    writeUint8Array(encoder, this.lensE.toUint8Array())\n    return toUint8Array(encoder)\n  }\n}\n","/**\n * Utility helpers for working with numbers.\n *\n * @module number\n */\n\nimport * as math from './math.js'\nimport * as binary from './binary.js'\n\nexport const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER\nexport const MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER\n\nexport const LOWEST_INT32 = 1 << 31\nexport const HIGHEST_INT32 = binary.BITS31\nexport const HIGHEST_UINT32 = binary.BITS32\n\n/* c8 ignore next */\nexport const isInteger = Number.isInteger || (num => typeof num === 'number' && isFinite(num) && math.floor(num) === num)\nexport const isNaN = Number.isNaN\nexport const parseInt = Number.parseInt\n\n/**\n * Count the number of \"1\" bits in an unsigned 32bit number.\n *\n * Super fun bitcount algorithm by Brian Kernighan.\n *\n * @param {number} n\n */\nexport const countBits = n => {\n  n &= binary.BITS32\n  let count = 0\n  while (n) {\n    n &= (n - 1)\n    count++\n  }\n  return count\n}\n","/**\n * Error helpers.\n *\n * @module error\n */\n\n/**\n * @param {string} s\n * @return {Error}\n */\n/* c8 ignore next */\nexport const create = s => new Error(s)\n\n/**\n * @throws {Error}\n * @return {never}\n */\n/* c8 ignore next 3 */\nexport const methodUnimplemented = () => {\n  throw create('Method unimplemented')\n}\n\n/**\n * @throws {Error}\n * @return {never}\n */\n/* c8 ignore next 3 */\nexport const unexpectedCase = () => {\n  throw create('Unexpected case')\n}\n","/**\n * Efficient schema-less binary decoding with support for variable length encoding.\n *\n * Use [lib0/decoding] with [lib0/encoding]. Every encoding function has a corresponding decoding function.\n *\n * Encodes numbers in little-endian order (least to most significant byte order)\n * and is compatible with Golang's binary encoding (https://golang.org/pkg/encoding/binary/)\n * which is also used in Protocol Buffers.\n *\n * ```js\n * // encoding step\n * const encoder = encoding.createEncoder()\n * encoding.writeVarUint(encoder, 256)\n * encoding.writeVarString(encoder, 'Hello world!')\n * const buf = encoding.toUint8Array(encoder)\n * ```\n *\n * ```js\n * // decoding step\n * const decoder = decoding.createDecoder(buf)\n * decoding.readVarUint(decoder) // => 256\n * decoding.readVarString(decoder) // => 'Hello world!'\n * decoding.hasContent(decoder) // => false - all data is read\n * ```\n *\n * @module decoding\n */\n\nimport * as binary from './binary.js'\nimport * as math from './math.js'\nimport * as number from './number.js'\nimport * as string from './string.js'\nimport * as error from './error.js'\nimport * as encoding from './encoding.js'\n\nconst errorUnexpectedEndOfArray = error.create('Unexpected end of array')\nconst errorIntegerOutOfRange = error.create('Integer out of Range')\n\n/**\n * A Decoder handles the decoding of an Uint8Array.\n */\nexport class Decoder {\n  /**\n   * @param {Uint8Array} uint8Array Binary data to decode\n   */\n  constructor (uint8Array) {\n    /**\n     * Decoding target.\n     *\n     * @type {Uint8Array}\n     */\n    this.arr = uint8Array\n    /**\n     * Current decoding position.\n     *\n     * @type {number}\n     */\n    this.pos = 0\n  }\n}\n\n/**\n * @function\n * @param {Uint8Array} uint8Array\n * @return {Decoder}\n */\nexport const createDecoder = uint8Array => new Decoder(uint8Array)\n\n/**\n * @function\n * @param {Decoder} decoder\n * @return {boolean}\n */\nexport const hasContent = decoder => decoder.pos !== decoder.arr.length\n\n/**\n * Clone a decoder instance.\n * Optionally set a new position parameter.\n *\n * @function\n * @param {Decoder} decoder The decoder instance\n * @param {number} [newPos] Defaults to current position\n * @return {Decoder} A clone of `decoder`\n */\nexport const clone = (decoder, newPos = decoder.pos) => {\n  const _decoder = createDecoder(decoder.arr)\n  _decoder.pos = newPos\n  return _decoder\n}\n\n/**\n * Create an Uint8Array view of the next `len` bytes and advance the position by `len`.\n *\n * Important: The Uint8Array still points to the underlying ArrayBuffer. Make sure to discard the result as soon as possible to prevent any memory leaks.\n *            Use `buffer.copyUint8Array` to copy the result into a new Uint8Array.\n *\n * @function\n * @param {Decoder} decoder The decoder instance\n * @param {number} len The length of bytes to read\n * @return {Uint8Array}\n */\nexport const readUint8Array = (decoder, len) => {\n  const view = new Uint8Array(decoder.arr.buffer, decoder.pos + decoder.arr.byteOffset, len)\n  decoder.pos += len\n  return view\n}\n\n/**\n * Read variable length Uint8Array.\n *\n * Important: The Uint8Array still points to the underlying ArrayBuffer. Make sure to discard the result as soon as possible to prevent any memory leaks.\n *            Use `buffer.copyUint8Array` to copy the result into a new Uint8Array.\n *\n * @function\n * @param {Decoder} decoder\n * @return {Uint8Array}\n */\nexport const readVarUint8Array = decoder => readUint8Array(decoder, readVarUint(decoder))\n\n/**\n * Read the rest of the content as an ArrayBuffer\n * @function\n * @param {Decoder} decoder\n * @return {Uint8Array}\n */\nexport const readTailAsUint8Array = decoder => readUint8Array(decoder, decoder.arr.length - decoder.pos)\n\n/**\n * Skip one byte, jump to the next position.\n * @function\n * @param {Decoder} decoder The decoder instance\n * @return {number} The next position\n */\nexport const skip8 = decoder => decoder.pos++\n\n/**\n * Read one byte as unsigned integer.\n * @function\n * @param {Decoder} decoder The decoder instance\n * @return {number} Unsigned 8-bit integer\n */\nexport const readUint8 = decoder => decoder.arr[decoder.pos++]\n\n/**\n * Read 2 bytes as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const readUint16 = decoder => {\n  const uint =\n    decoder.arr[decoder.pos] +\n    (decoder.arr[decoder.pos + 1] << 8)\n  decoder.pos += 2\n  return uint\n}\n\n/**\n * Read 4 bytes as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const readUint32 = decoder => {\n  const uint =\n    (decoder.arr[decoder.pos] +\n    (decoder.arr[decoder.pos + 1] << 8) +\n    (decoder.arr[decoder.pos + 2] << 16) +\n    (decoder.arr[decoder.pos + 3] << 24)) >>> 0\n  decoder.pos += 4\n  return uint\n}\n\n/**\n * Read 4 bytes as unsigned integer in big endian order.\n * (most significant byte first)\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const readUint32BigEndian = decoder => {\n  const uint =\n    (decoder.arr[decoder.pos + 3] +\n    (decoder.arr[decoder.pos + 2] << 8) +\n    (decoder.arr[decoder.pos + 1] << 16) +\n    (decoder.arr[decoder.pos] << 24)) >>> 0\n  decoder.pos += 4\n  return uint\n}\n\n/**\n * Look ahead without incrementing the position\n * to the next byte and read it as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const peekUint8 = decoder => decoder.arr[decoder.pos]\n\n/**\n * Look ahead without incrementing the position\n * to the next byte and read it as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const peekUint16 = decoder =>\n  decoder.arr[decoder.pos] +\n  (decoder.arr[decoder.pos + 1] << 8)\n\n/**\n * Look ahead without incrementing the position\n * to the next byte and read it as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const peekUint32 = decoder => (\n  decoder.arr[decoder.pos] +\n  (decoder.arr[decoder.pos + 1] << 8) +\n  (decoder.arr[decoder.pos + 2] << 16) +\n  (decoder.arr[decoder.pos + 3] << 24)\n) >>> 0\n\n/**\n * Read unsigned integer (32bit) with variable length.\n * 1/8th of the storage is used as encoding overhead.\n *  * numbers < 2^7 is stored in one bytlength\n *  * numbers < 2^14 is stored in two bylength\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.length\n */\nexport const readVarUint = decoder => {\n  let num = 0\n  let mult = 1\n  const len = decoder.arr.length\n  while (decoder.pos < len) {\n    const r = decoder.arr[decoder.pos++]\n    // num = num | ((r & binary.BITS7) << len)\n    num = num + (r & binary.BITS7) * mult // shift $r << (7*#iterations) and add it to num\n    mult *= 128 // next iteration, shift 7 \"more\" to the left\n    if (r < binary.BIT8) {\n      return num\n    }\n    /* c8 ignore start */\n    if (num > number.MAX_SAFE_INTEGER) {\n      throw errorIntegerOutOfRange\n    }\n    /* c8 ignore stop */\n  }\n  throw errorUnexpectedEndOfArray\n}\n\n/**\n * Read signed integer (32bit) with variable length.\n * 1/8th of the storage is used as encoding overhead.\n *  * numbers < 2^7 is stored in one bytlength\n *  * numbers < 2^14 is stored in two bylength\n * @todo This should probably create the inverse ~num if number is negative - but this would be a breaking change.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.length\n */\nexport const readVarInt = decoder => {\n  let r = decoder.arr[decoder.pos++]\n  let num = r & binary.BITS6\n  let mult = 64\n  const sign = (r & binary.BIT7) > 0 ? -1 : 1\n  if ((r & binary.BIT8) === 0) {\n    // don't continue reading\n    return sign * num\n  }\n  const len = decoder.arr.length\n  while (decoder.pos < len) {\n    r = decoder.arr[decoder.pos++]\n    // num = num | ((r & binary.BITS7) << len)\n    num = num + (r & binary.BITS7) * mult\n    mult *= 128\n    if (r < binary.BIT8) {\n      return sign * num\n    }\n    /* c8 ignore start */\n    if (num > number.MAX_SAFE_INTEGER) {\n      throw errorIntegerOutOfRange\n    }\n    /* c8 ignore stop */\n  }\n  throw errorUnexpectedEndOfArray\n}\n\n/**\n * Look ahead and read varUint without incrementing position\n *\n * @function\n * @param {Decoder} decoder\n * @return {number}\n */\nexport const peekVarUint = decoder => {\n  const pos = decoder.pos\n  const s = readVarUint(decoder)\n  decoder.pos = pos\n  return s\n}\n\n/**\n * Look ahead and read varUint without incrementing position\n *\n * @function\n * @param {Decoder} decoder\n * @return {number}\n */\nexport const peekVarInt = decoder => {\n  const pos = decoder.pos\n  const s = readVarInt(decoder)\n  decoder.pos = pos\n  return s\n}\n\n/**\n * We don't test this function anymore as we use native decoding/encoding by default now.\n * Better not modify this anymore..\n *\n * Transforming utf8 to a string is pretty expensive. The code performs 10x better\n * when String.fromCodePoint is fed with all characters as arguments.\n * But most environments have a maximum number of arguments per functions.\n * For effiency reasons we apply a maximum of 10000 characters at once.\n *\n * @function\n * @param {Decoder} decoder\n * @return {String} The read String.\n */\n/* c8 ignore start */\nexport const _readVarStringPolyfill = decoder => {\n  let remainingLen = readVarUint(decoder)\n  if (remainingLen === 0) {\n    return ''\n  } else {\n    let encodedString = String.fromCodePoint(readUint8(decoder)) // remember to decrease remainingLen\n    if (--remainingLen < 100) { // do not create a Uint8Array for small strings\n      while (remainingLen--) {\n        encodedString += String.fromCodePoint(readUint8(decoder))\n      }\n    } else {\n      while (remainingLen > 0) {\n        const nextLen = remainingLen < 10000 ? remainingLen : 10000\n        // this is dangerous, we create a fresh array view from the existing buffer\n        const bytes = decoder.arr.subarray(decoder.pos, decoder.pos + nextLen)\n        decoder.pos += nextLen\n        // Starting with ES5.1 we can supply a generic array-like object as arguments\n        encodedString += String.fromCodePoint.apply(null, /** @type {any} */ (bytes))\n        remainingLen -= nextLen\n      }\n    }\n    return decodeURIComponent(escape(encodedString))\n  }\n}\n/* c8 ignore stop */\n\n/**\n * @function\n * @param {Decoder} decoder\n * @return {String} The read String\n */\nexport const _readVarStringNative = decoder =>\n  /** @type any */ (string.utf8TextDecoder).decode(readVarUint8Array(decoder))\n\n/**\n * Read string of variable length\n * * varUint is used to store the length of the string\n *\n * @function\n * @param {Decoder} decoder\n * @return {String} The read String\n *\n */\n/* c8 ignore next */\nexport const readVarString = string.utf8TextDecoder ? _readVarStringNative : _readVarStringPolyfill\n\n/**\n * @param {Decoder} decoder\n * @return {Uint8Array}\n */\nexport const readTerminatedUint8Array = decoder => {\n  const encoder = encoding.createEncoder()\n  let b\n  while (true) {\n    b = readUint8(decoder)\n    if (b === 0) {\n      return encoding.toUint8Array(encoder)\n    }\n    if (b === 1) {\n      b = readUint8(decoder)\n    }\n    encoding.write(encoder, b)\n  }\n}\n\n/**\n * @param {Decoder} decoder\n * @return {string}\n */\nexport const readTerminatedString = decoder => string.decodeUtf8(readTerminatedUint8Array(decoder))\n\n/**\n * Look ahead and read varString without incrementing position\n *\n * @function\n * @param {Decoder} decoder\n * @return {string}\n */\nexport const peekVarString = decoder => {\n  const pos = decoder.pos\n  const s = readVarString(decoder)\n  decoder.pos = pos\n  return s\n}\n\n/**\n * @param {Decoder} decoder\n * @param {number} len\n * @return {DataView}\n */\nexport const readFromDataView = (decoder, len) => {\n  const dv = new DataView(decoder.arr.buffer, decoder.arr.byteOffset + decoder.pos, len)\n  decoder.pos += len\n  return dv\n}\n\n/**\n * @param {Decoder} decoder\n */\nexport const readFloat32 = decoder => readFromDataView(decoder, 4).getFloat32(0, false)\n\n/**\n * @param {Decoder} decoder\n */\nexport const readFloat64 = decoder => readFromDataView(decoder, 8).getFloat64(0, false)\n\n/**\n * @param {Decoder} decoder\n */\nexport const readBigInt64 = decoder => /** @type {any} */ (readFromDataView(decoder, 8)).getBigInt64(0, false)\n\n/**\n * @param {Decoder} decoder\n */\nexport const readBigUint64 = decoder => /** @type {any} */ (readFromDataView(decoder, 8)).getBigUint64(0, false)\n\n/**\n * @type {Array<function(Decoder):any>}\n */\nconst readAnyLookupTable = [\n  decoder => undefined, // CASE 127: undefined\n  decoder => null, // CASE 126: null\n  readVarInt, // CASE 125: integer\n  readFloat32, // CASE 124: float32\n  readFloat64, // CASE 123: float64\n  readBigInt64, // CASE 122: bigint\n  decoder => false, // CASE 121: boolean (false)\n  decoder => true, // CASE 120: boolean (true)\n  readVarString, // CASE 119: string\n  decoder => { // CASE 118: object<string,any>\n    const len = readVarUint(decoder)\n    /**\n     * @type {Object<string,any>}\n     */\n    const obj = {}\n    for (let i = 0; i < len; i++) {\n      const key = readVarString(decoder)\n      obj[key] = readAny(decoder)\n    }\n    return obj\n  },\n  decoder => { // CASE 117: array<any>\n    const len = readVarUint(decoder)\n    const arr = []\n    for (let i = 0; i < len; i++) {\n      arr.push(readAny(decoder))\n    }\n    return arr\n  },\n  readVarUint8Array // CASE 116: Uint8Array\n]\n\n/**\n * @param {Decoder} decoder\n */\nexport const readAny = decoder => readAnyLookupTable[127 - readUint8(decoder)](decoder)\n\n/**\n * T must not be null.\n *\n * @template T\n */\nexport class RleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   * @param {function(Decoder):T} reader\n   */\n  constructor (uint8Array, reader) {\n    super(uint8Array)\n    /**\n     * The reader\n     */\n    this.reader = reader\n    /**\n     * Current state\n     * @type {T|null}\n     */\n    this.s = null\n    this.count = 0\n  }\n\n  read () {\n    if (this.count === 0) {\n      this.s = this.reader(this)\n      if (hasContent(this)) {\n        this.count = readVarUint(this) + 1 // see encoder implementation for the reason why this is incremented\n      } else {\n        this.count = -1 // read the current value forever\n      }\n    }\n    this.count--\n    return /** @type {T} */ (this.s)\n  }\n}\n\nexport class IntDiffDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   * @param {number} start\n   */\n  constructor (uint8Array, start) {\n    super(uint8Array)\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start\n  }\n\n  /**\n   * @return {number}\n   */\n  read () {\n    this.s += readVarInt(this)\n    return this.s\n  }\n}\n\nexport class RleIntDiffDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   * @param {number} start\n   */\n  constructor (uint8Array, start) {\n    super(uint8Array)\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start\n    this.count = 0\n  }\n\n  /**\n   * @return {number}\n   */\n  read () {\n    if (this.count === 0) {\n      this.s += readVarInt(this)\n      if (hasContent(this)) {\n        this.count = readVarUint(this) + 1 // see encoder implementation for the reason why this is incremented\n      } else {\n        this.count = -1 // read the current value forever\n      }\n    }\n    this.count--\n    return /** @type {number} */ (this.s)\n  }\n}\n\nexport class UintOptRleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    super(uint8Array)\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n  }\n\n  read () {\n    if (this.count === 0) {\n      this.s = readVarInt(this)\n      // if the sign is negative, we read the count too, otherwise count is 1\n      const isNegative = math.isNegativeZero(this.s)\n      this.count = 1\n      if (isNegative) {\n        this.s = -this.s\n        this.count = readVarUint(this) + 2\n      }\n    }\n    this.count--\n    return /** @type {number} */ (this.s)\n  }\n}\n\nexport class IncUintOptRleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    super(uint8Array)\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n  }\n\n  read () {\n    if (this.count === 0) {\n      this.s = readVarInt(this)\n      // if the sign is negative, we read the count too, otherwise count is 1\n      const isNegative = math.isNegativeZero(this.s)\n      this.count = 1\n      if (isNegative) {\n        this.s = -this.s\n        this.count = readVarUint(this) + 2\n      }\n    }\n    this.count--\n    return /** @type {number} */ (this.s++)\n  }\n}\n\nexport class IntDiffOptRleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    super(uint8Array)\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n    this.diff = 0\n  }\n\n  /**\n   * @return {number}\n   */\n  read () {\n    if (this.count === 0) {\n      const diff = readVarInt(this)\n      // if the first bit is set, we read more data\n      const hasCount = diff & 1\n      this.diff = math.floor(diff / 2) // shift >> 1\n      this.count = 1\n      if (hasCount) {\n        this.count = readVarUint(this) + 2\n      }\n    }\n    this.s += this.diff\n    this.count--\n    return this.s\n  }\n}\n\nexport class StringDecoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    this.decoder = new UintOptRleDecoder(uint8Array)\n    this.str = readVarString(this.decoder)\n    /**\n     * @type {number}\n     */\n    this.spos = 0\n  }\n\n  /**\n   * @return {string}\n   */\n  read () {\n    const end = this.spos + this.decoder.read()\n    const res = this.str.slice(this.spos, end)\n    this.spos = end\n    return res\n  }\n}\n","/**\n * @module sync-protocol\n */\n\nimport * as encoding from 'lib0/encoding'\nimport * as decoding from 'lib0/decoding'\nimport * as Y from 'yjs'\n\n/**\n * @typedef {Map<number, number>} StateMap\n */\n\n/**\n * Core Yjs defines two message types:\n *  YjsSyncStep1: Includes the State Set of the sending client. When received, the client should reply with YjsSyncStep2.\n *  YjsSyncStep2: Includes all missing structs and the complete delete set. When received, the client is assured that it\n *   received all information from the remote client.\n *\n * In a peer-to-peer network, you may want to introduce a SyncDone message type. Both parties should initiate the connection\n * with SyncStep1. When a client received SyncStep2, it should reply with SyncDone. When the local client received both\n * SyncStep2 and SyncDone, it is assured that it is synced to the remote client.\n *\n * In a client-server model, you want to handle this differently: The client should initiate the connection with SyncStep1.\n * When the server receives SyncStep1, it should reply with SyncStep2 immediately followed by SyncStep1. The client replies\n * with SyncStep2 when it receives SyncStep1. Optionally the server may send a SyncDone after it received SyncStep2, so the\n * client knows that the sync is finished.  There are two reasons for this more elaborated sync model: 1. This protocol can\n * easily be implemented on top of http and websockets. 2. The server should only reply to requests, and not initiate them.\n * Therefore it is necessary that the client initiates the sync.\n *\n * Construction of a message:\n * [messageType : varUint, message definition..]\n *\n * Note: A message does not include information about the room name. This must to be handled by the upper layer protocol!\n *\n * stringify[messageType] stringifies a message definition (messageType is already read from the bufffer)\n */\n\nexport const messageYjsSyncStep1 = 0\nexport const messageYjsSyncStep2 = 1\nexport const messageYjsUpdate = 2\n\n/**\n * Create a sync step 1 message based on the state of the current shared document.\n *\n * @param {encoding.Encoder} encoder\n * @param {Y.Doc} doc\n */\nexport const writeSyncStep1 = (encoder, doc) => {\n  encoding.writeVarUint(encoder, messageYjsSyncStep1)\n  const sv = Y.encodeStateVector(doc)\n  encoding.writeVarUint8Array(encoder, sv)\n}\n\n/**\n * @param {encoding.Encoder} encoder\n * @param {Y.Doc} doc\n * @param {Uint8Array} [encodedStateVector]\n */\nexport const writeSyncStep2 = (encoder, doc, encodedStateVector) => {\n  encoding.writeVarUint(encoder, messageYjsSyncStep2)\n  encoding.writeVarUint8Array(encoder, Y.encodeStateAsUpdate(doc, encodedStateVector))\n}\n\n/**\n * Read SyncStep1 message and reply with SyncStep2.\n *\n * @param {decoding.Decoder} decoder The reply to the received message\n * @param {encoding.Encoder} encoder The received message\n * @param {Y.Doc} doc\n */\nexport const readSyncStep1 = (decoder, encoder, doc) =>\n  writeSyncStep2(encoder, doc, decoding.readVarUint8Array(decoder))\n\n/**\n * Read and apply Structs and then DeleteStore to a y instance.\n *\n * @param {decoding.Decoder} decoder\n * @param {Y.Doc} doc\n * @param {any} transactionOrigin\n */\nexport const readSyncStep2 = (decoder, doc, transactionOrigin) => {\n  try {\n    Y.applyUpdate(doc, decoding.readVarUint8Array(decoder), transactionOrigin)\n  } catch (error) {\n    // This catches errors that are thrown by event handlers\n    console.error('Caught error while handling a Yjs update', error)\n  }\n}\n\n/**\n * @param {encoding.Encoder} encoder\n * @param {Uint8Array} update\n */\nexport const writeUpdate = (encoder, update) => {\n  encoding.writeVarUint(encoder, messageYjsUpdate)\n  encoding.writeVarUint8Array(encoder, update)\n}\n\n/**\n * Read and apply Structs and then DeleteStore to a y instance.\n *\n * @param {decoding.Decoder} decoder\n * @param {Y.Doc} doc\n * @param {any} transactionOrigin\n */\nexport const readUpdate = readSyncStep2\n\n/**\n * @param {decoding.Decoder} decoder A message received from another client\n * @param {encoding.Encoder} encoder The reply message. Does not need to be sent if empty.\n * @param {Y.Doc} doc\n * @param {any} transactionOrigin\n */\nexport const readSyncMessage = (decoder, encoder, doc, transactionOrigin) => {\n  const messageType = decoding.readVarUint(decoder)\n  switch (messageType) {\n    case messageYjsSyncStep1:\n      readSyncStep1(decoder, encoder, doc)\n      break\n    case messageYjsSyncStep2:\n      readSyncStep2(decoder, doc, transactionOrigin)\n      break\n    case messageYjsUpdate:\n      readUpdate(decoder, doc, transactionOrigin)\n      break\n    default:\n      throw new Error('Unknown message type')\n  }\n  return messageType\n}\n","/**\n * Utility module to work with time.\n *\n * @module time\n */\n\nimport * as metric from './metric.js'\nimport * as math from './math.js'\n\n/**\n * Return current time.\n *\n * @return {Date}\n */\nexport const getDate = () => new Date()\n\n/**\n * Return current unix time.\n *\n * @return {number}\n */\nexport const getUnixTime = Date.now\n\n/**\n * Transform time (in ms) to a human readable format. E.g. 1100 => 1.1s. 60s => 1min. .001 => 10s.\n *\n * @param {number} d duration in milliseconds\n * @return {string} humanized approximation of time\n */\nexport const humanizeDuration = d => {\n  if (d < 60000) {\n    const p = metric.prefix(d, -1)\n    return math.round(p.n * 100) / 100 + p.prefix + 's'\n  }\n  d = math.floor(d / 1000)\n  const seconds = d % 60\n  const minutes = math.floor(d / 60) % 60\n  const hours = math.floor(d / 3600) % 24\n  const days = math.floor(d / 86400)\n  if (days > 0) {\n    return days + 'd' + ((hours > 0 || minutes > 30) ? ' ' + (minutes > 30 ? hours + 1 : hours) + 'h' : '')\n  }\n  if (hours > 0) {\n    /* c8 ignore next */\n    return hours + 'h' + ((minutes > 0 || seconds > 30) ? ' ' + (seconds > 30 ? minutes + 1 : minutes) + 'min' : '')\n  }\n  return minutes + 'min' + (seconds > 0 ? ' ' + seconds + 's' : '')\n}\n","/**\n * Utility module to work with key-value stores.\n *\n * @module map\n */\n\n/**\n * Creates a new Map instance.\n *\n * @function\n * @return {Map<any, any>}\n *\n * @function\n */\nexport const create = () => new Map()\n\n/**\n * Copy a Map object into a fresh Map object.\n *\n * @function\n * @template K,V\n * @param {Map<K,V>} m\n * @return {Map<K,V>}\n */\nexport const copy = m => {\n  const r = create()\n  m.forEach((v, k) => { r.set(k, v) })\n  return r\n}\n\n/**\n * Get map property. Create T if property is undefined and set T on map.\n *\n * ```js\n * const listeners = map.setIfUndefined(events, 'eventName', set.create)\n * listeners.add(listener)\n * ```\n *\n * @function\n * @template {Map<any, any>} MAP\n * @template {MAP extends Map<any,infer V> ? function():V : unknown} CF\n * @param {MAP} map\n * @param {MAP extends Map<infer K,any> ? K : unknown} key\n * @param {CF} createT\n * @return {ReturnType<CF>}\n */\nexport const setIfUndefined = (map, key, createT) => {\n  let set = map.get(key)\n  if (set === undefined) {\n    map.set(key, set = createT())\n  }\n  return set\n}\n\n/**\n * Creates an Array and populates it with the content of all key-value pairs using the `f(value, key)` function.\n *\n * @function\n * @template K\n * @template V\n * @template R\n * @param {Map<K,V>} m\n * @param {function(V,K):R} f\n * @return {Array<R>}\n */\nexport const map = (m, f) => {\n  const res = []\n  for (const [key, value] of m) {\n    res.push(f(value, key))\n  }\n  return res\n}\n\n/**\n * Tests whether any key-value pairs pass the test implemented by `f(value, key)`.\n *\n * @todo should rename to some - similarly to Array.some\n *\n * @function\n * @template K\n * @template V\n * @param {Map<K,V>} m\n * @param {function(V,K):boolean} f\n * @return {boolean}\n */\nexport const any = (m, f) => {\n  for (const [key, value] of m) {\n    if (f(value, key)) {\n      return true\n    }\n  }\n  return false\n}\n\n/**\n * Tests whether all key-value pairs pass the test implemented by `f(value, key)`.\n *\n * @function\n * @template K\n * @template V\n * @param {Map<K,V>} m\n * @param {function(V,K):boolean} f\n * @return {boolean}\n */\nexport const all = (m, f) => {\n  for (const [key, value] of m) {\n    if (!f(value, key)) {\n      return false\n    }\n  }\n  return true\n}\n","/**\n * Utility module to work with sets.\n *\n * @module set\n */\n\nexport const create = () => new Set()\n\n/**\n * @template T\n * @param {Set<T>} set\n * @return {Array<T>}\n */\nexport const toArray = set => Array.from(set)\n\n/**\n * @template T\n * @param {Set<T>} set\n * @return {T|undefined}\n */\nexport const first = set => set.values().next().value\n\n/**\n * @template T\n * @param {Iterable<T>} entries\n * @return {Set<T>}\n */\nexport const from = entries => new Set(entries)\n","/**\n * Utility module to work with Arrays.\n *\n * @module array\n */\n\nimport * as set from './set.js'\n\n/**\n * Return the last element of an array. The element must exist\n *\n * @template L\n * @param {ArrayLike<L>} arr\n * @return {L}\n */\nexport const last = arr => arr[arr.length - 1]\n\n/**\n * @template C\n * @return {Array<C>}\n */\nexport const create = () => /** @type {Array<C>} */ ([])\n\n/**\n * @template D\n * @param {Array<D>} a\n * @return {Array<D>}\n */\nexport const copy = a => /** @type {Array<D>} */ (a.slice())\n\n/**\n * Append elements from src to dest\n *\n * @template M\n * @param {Array<M>} dest\n * @param {Array<M>} src\n */\nexport const appendTo = (dest, src) => {\n  for (let i = 0; i < src.length; i++) {\n    dest.push(src[i])\n  }\n}\n\n/**\n * Transforms something array-like to an actual Array.\n *\n * @function\n * @template T\n * @param {ArrayLike<T>|Iterable<T>} arraylike\n * @return {T}\n */\nexport const from = Array.from\n\n/**\n * True iff condition holds on every element in the Array.\n *\n * @function\n * @template {ArrayLike<any>} ARR\n *\n * @param {ARR} arr\n * @param {ARR extends ArrayLike<infer S> ? ((value:S, index:number, arr:ARR) => boolean) : any} f\n * @return {boolean}\n */\nexport const every = (arr, f) => {\n  for (let i = 0; i < arr.length; i++) {\n    if (!f(arr[i], i, arr)) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * True iff condition holds on some element in the Array.\n *\n * @function\n * @template {ArrayLike<any>} ARR\n *\n * @param {ARR} arr\n * @param {ARR extends ArrayLike<infer S> ? ((value:S, index:number, arr:ARR) => boolean) : never} f\n * @return {boolean}\n */\nexport const some = (arr, f) => {\n  for (let i = 0; i < arr.length; i++) {\n    if (f(arr[i], i, arr)) {\n      return true\n    }\n  }\n  return false\n}\n\n/**\n * @template ELEM\n *\n * @param {ArrayLike<ELEM>} a\n * @param {ArrayLike<ELEM>} b\n * @return {boolean}\n */\nexport const equalFlat = (a, b) => a.length === b.length && every(a, (item, index) => item === b[index])\n\n/**\n * @template ELEM\n * @param {Array<Array<ELEM>>} arr\n * @return {Array<ELEM>}\n */\nexport const flatten = arr => fold(arr, /** @type {Array<ELEM>} */ ([]), (acc, val) => acc.concat(val))\n\n/**\n * @template T\n * @param {number} len\n * @param {function(number, Array<T>):T} f\n * @return {Array<T>}\n */\nexport const unfold = (len, f) => {\n  const array = new Array(len)\n  for (let i = 0; i < len; i++) {\n    array[i] = f(i, array)\n  }\n  return array\n}\n\n/**\n * @template T\n * @template RESULT\n * @param {Array<T>} arr\n * @param {RESULT} seed\n * @param {function(RESULT, T, number):RESULT} folder\n */\nexport const fold = (arr, seed, folder) => arr.reduce(folder, seed)\n\nexport const isArray = Array.isArray\n\n/**\n * @template T\n * @param {Array<T>} arr\n * @return {Array<T>}\n */\nexport const unique = arr => from(set.from(arr))\n\n/**\n * @template T\n * @template M\n * @param {ArrayLike<T>} arr\n * @param {function(T):M} mapper\n * @return {Array<T>}\n */\nexport const uniqueBy = (arr, mapper) => {\n  /**\n   * @type {Set<M>}\n   */\n  const happened = set.create()\n  /**\n   * @type {Array<T>}\n   */\n  const result = []\n  for (let i = 0; i < arr.length; i++) {\n    const el = arr[i]\n    const mapped = mapper(el)\n    if (!happened.has(mapped)) {\n      happened.add(mapped)\n      result.push(el)\n    }\n  }\n  return result\n}\n\n/**\n * @template {ArrayLike<any>} ARR\n * @template {function(ARR extends ArrayLike<infer T> ? T : never, number, ARR):any} MAPPER\n * @param {ARR} arr\n * @param {MAPPER} mapper\n * @return {Array<MAPPER extends function(...any): infer M ? M : never>}\n */\nexport const map = (arr, mapper) => {\n  /**\n   * @type {Array<any>}\n   */\n  const res = Array(arr.length)\n  for (let i = 0; i < arr.length; i++) {\n    res[i] = mapper(/** @type {any} */ (arr[i]), i, /** @type {any} */ (arr))\n  }\n  return /** @type {any} */ (res)\n}\n\n/**\n * This function bubble-sorts a single item to the correct position. The sort happens in-place and\n * might be useful to ensure that a single item is at the correct position in an otherwise sorted\n * array.\n *\n * @example\n *  const arr = [3, 2, 5]\n *  arr.sort((a, b) => a - b)\n *  arr // => [2, 3, 5]\n *  arr.splice(1, 0, 7)\n *  array.bubbleSortItem(arr, 1, (a, b) => a - b)\n *  arr // => [2, 3, 5, 7]\n *\n * @template T\n * @param {Array<T>} arr\n * @param {number} i\n * @param {(a:T,b:T) => number} compareFn\n */\nexport const bubblesortItem = (arr, i, compareFn) => {\n  const n = arr[i]\n  let j = i\n  // try to sort to the right\n  while (j + 1 < arr.length && compareFn(n, arr[j + 1]) > 0) {\n    arr[j] = arr[j + 1]\n    arr[++j] = n\n  }\n  if (i === j && j > 0) { // no change yet\n    // sort to the left\n    while (j > 0 && compareFn(arr[j - 1], n) > 0) {\n      arr[j] = arr[j - 1]\n      arr[--j] = n\n    }\n  }\n  return j\n}\n","/**\n * Observable class prototype.\n *\n * @module observable\n */\n\nimport * as map from './map.js'\nimport * as set from './set.js'\nimport * as array from './array.js'\n\n/**\n * Handles named events.\n * @experimental\n *\n * This is basically a (better typed) duplicate of Observable, which will replace Observable in the\n * next release.\n *\n * @template {{[key in keyof EVENTS]: function(...any):void}} EVENTS\n */\nexport class ObservableV2 {\n  constructor () {\n    /**\n     * Some desc.\n     * @type {Map<string, Set<any>>}\n     */\n    this._observers = map.create()\n  }\n\n  /**\n   * @template {keyof EVENTS & string} NAME\n   * @param {NAME} name\n   * @param {EVENTS[NAME]} f\n   */\n  on (name, f) {\n    map.setIfUndefined(this._observers, /** @type {string} */ (name), set.create).add(f)\n    return f\n  }\n\n  /**\n   * @template {keyof EVENTS & string} NAME\n   * @param {NAME} name\n   * @param {EVENTS[NAME]} f\n   */\n  once (name, f) {\n    /**\n     * @param  {...any} args\n     */\n    const _f = (...args) => {\n      this.off(name, /** @type {any} */ (_f))\n      f(...args)\n    }\n    this.on(name, /** @type {any} */ (_f))\n  }\n\n  /**\n   * @template {keyof EVENTS & string} NAME\n   * @param {NAME} name\n   * @param {EVENTS[NAME]} f\n   */\n  off (name, f) {\n    const observers = this._observers.get(name)\n    if (observers !== undefined) {\n      observers.delete(f)\n      if (observers.size === 0) {\n        this._observers.delete(name)\n      }\n    }\n  }\n\n  /**\n   * Emit a named event. All registered event listeners that listen to the\n   * specified name will receive the event.\n   *\n   * @todo This should catch exceptions\n   *\n   * @template {keyof EVENTS & string} NAME\n   * @param {NAME} name The event name.\n   * @param {Parameters<EVENTS[NAME]>} args The arguments that are applied to the event listener.\n   */\n  emit (name, args) {\n    // copy all listeners to an array first to make sure that no event is emitted to listeners that are subscribed while the event handler is called.\n    return array.from((this._observers.get(name) || map.create()).values()).forEach(f => f(...args))\n  }\n\n  destroy () {\n    this._observers = map.create()\n  }\n}\n\n/* c8 ignore start */\n/**\n * Handles named events.\n *\n * @deprecated\n * @template N\n */\nexport class Observable {\n  constructor () {\n    /**\n     * Some desc.\n     * @type {Map<N, any>}\n     */\n    this._observers = map.create()\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  on (name, f) {\n    map.setIfUndefined(this._observers, name, set.create).add(f)\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  once (name, f) {\n    /**\n     * @param  {...any} args\n     */\n    const _f = (...args) => {\n      this.off(name, _f)\n      f(...args)\n    }\n    this.on(name, _f)\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  off (name, f) {\n    const observers = this._observers.get(name)\n    if (observers !== undefined) {\n      observers.delete(f)\n      if (observers.size === 0) {\n        this._observers.delete(name)\n      }\n    }\n  }\n\n  /**\n   * Emit a named event. All registered event listeners that listen to the\n   * specified name will receive the event.\n   *\n   * @todo This should catch exceptions\n   *\n   * @param {N} name The event name.\n   * @param {Array<any>} args The arguments that are applied to the event listener.\n   */\n  emit (name, args) {\n    // copy all listeners to an array first to make sure that no event is emitted to listeners that are subscribed while the event handler is called.\n    return array.from((this._observers.get(name) || map.create()).values()).forEach(f => f(...args))\n  }\n\n  destroy () {\n    this._observers = map.create()\n  }\n}\n/* c8 ignore end */\n","/**\n * Utility functions for working with EcmaScript objects.\n *\n * @module object\n */\n\n/**\n * @return {Object<string,any>} obj\n */\nexport const create = () => Object.create(null)\n\n/**\n * Object.assign\n */\nexport const assign = Object.assign\n\n/**\n * @param {Object<string,any>} obj\n */\nexport const keys = Object.keys\n\n/**\n * @template V\n * @param {{[key:string]: V}} obj\n * @return {Array<V>}\n */\nexport const values = Object.values\n\n/**\n * @template V\n * @param {{[k:string]:V}} obj\n * @param {function(V,string):any} f\n */\nexport const forEach = (obj, f) => {\n  for (const key in obj) {\n    f(obj[key], key)\n  }\n}\n\n/**\n * @todo implement mapToArray & map\n *\n * @template R\n * @param {Object<string,any>} obj\n * @param {function(any,string):R} f\n * @return {Array<R>}\n */\nexport const map = (obj, f) => {\n  const results = []\n  for (const key in obj) {\n    results.push(f(obj[key], key))\n  }\n  return results\n}\n\n/**\n * @deprecated use object.size instead\n * @param {Object<string,any>} obj\n * @return {number}\n */\nexport const length = obj => keys(obj).length\n\n/**\n * @param {Object<string,any>} obj\n * @return {number}\n */\nexport const size = obj => keys(obj).length\n\n/**\n * @template {{ [key:string|number|symbol]: any }} T\n * @param {T} obj\n * @param {(v:T[keyof T],k:keyof T)=>boolean} f\n * @return {boolean}\n */\nexport const some = (obj, f) => {\n  for (const key in obj) {\n    if (f(obj[key], key)) {\n      return true\n    }\n  }\n  return false\n}\n\n/**\n * @param {Object|null|undefined} obj\n */\nexport const isEmpty = obj => {\n  // eslint-disable-next-line no-unreachable-loop\n  for (const _k in obj) {\n    return false\n  }\n  return true\n}\n\n/**\n * @template {{ [key:string|number|symbol]: any }} T\n * @param {T} obj\n * @param {(v:T[keyof T],k:keyof T)=>boolean} f\n * @return {boolean}\n */\nexport const every = (obj, f) => {\n  for (const key in obj) {\n    if (!f(obj[key], key)) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * Calls `Object.prototype.hasOwnProperty`.\n *\n * @param {any} obj\n * @param {string|number|symbol} key\n * @return {boolean}\n */\nexport const hasProperty = (obj, key) => Object.prototype.hasOwnProperty.call(obj, key)\n\n/**\n * @param {Object<string,any>} a\n * @param {Object<string,any>} b\n * @return {boolean}\n */\nexport const equalFlat = (a, b) => a === b || (size(a) === size(b) && every(a, (val, key) => (val !== undefined || hasProperty(b, key)) && b[key] === val))\n\n/**\n * Make an object immutable. This hurts performance and is usually not needed if you perform good\n * coding practices.\n */\nexport const freeze = Object.freeze\n\n/**\n * Make an object and all its children immutable.\n * This *really* hurts performance and is usually not needed if you perform good coding practices.\n *\n * @template {any} T\n * @param {T} o\n * @return {Readonly<T>}\n */\nexport const deepFreeze = (o) => {\n  for (const key in o) {\n    const c = o[key]\n    if (typeof c === 'object' || typeof c === 'function') {\n      deepFreeze(o[key])\n    }\n  }\n  return freeze(o)\n}\n\n/**\n * Get object property. Create T if property is undefined and set T on object.\n *\n * @function\n * @template {object} KV\n * @template {keyof KV} [K=keyof KV]\n * @param {KV} o\n * @param {K} key\n * @param {() => KV[K]} createT\n * @return {KV[K]}\n */\nexport const setIfUndefined = (o, key, createT) => hasProperty(o, key) ? o[key] : (o[key] = createT())\n","export const EqualityTraitSymbol = Symbol('Equality')\n\n/**\n * @typedef {{ [EqualityTraitSymbol]:(other:EqualityTrait)=>boolean }} EqualityTrait\n */\n","/**\n * Common functions and function call helpers.\n *\n * @module function\n */\n\nimport * as array from './array.js'\nimport * as object from './object.js'\nimport * as traits from './traits.js'\n\n/**\n * Calls all functions in `fs` with args. Only throws after all functions were called.\n *\n * @param {Array<function>} fs\n * @param {Array<any>} args\n */\nexport const callAll = (fs, args, i = 0) => {\n  try {\n    for (; i < fs.length; i++) {\n      fs[i](...args)\n    }\n  } finally {\n    if (i < fs.length) {\n      callAll(fs, args, i + 1)\n    }\n  }\n}\n\nexport const nop = () => {}\n\n/**\n * @template T\n * @param {function():T} f\n * @return {T}\n */\nexport const apply = f => f()\n\n/**\n * @template A\n *\n * @param {A} a\n * @return {A}\n */\nexport const id = a => a\n\n/**\n * @template T\n *\n * @param {T} a\n * @param {T} b\n * @return {boolean}\n */\nexport const equalityStrict = (a, b) => a === b\n\n/**\n * @template T\n *\n * @param {Array<T>|object} a\n * @param {Array<T>|object} b\n * @return {boolean}\n */\nexport const equalityFlat = (a, b) => a === b || (a != null && b != null && a.constructor === b.constructor && ((array.isArray(a) && array.equalFlat(a, /** @type {Array<T>} */ (b))) || (typeof a === 'object' && object.equalFlat(a, b))))\n\n/* c8 ignore start */\n\n/**\n * @param {any} a\n * @param {any} b\n * @return {boolean}\n */\nexport const equalityDeep = (a, b) => {\n  if (a === b) {\n    return true\n  }\n  if (a == null || b == null || a.constructor !== b.constructor) {\n    return false\n  }\n  if (a[traits.EqualityTraitSymbol] != null) {\n    return a[traits.EqualityTraitSymbol](b)\n  }\n  switch (a.constructor) {\n    case ArrayBuffer:\n      a = new Uint8Array(a)\n      b = new Uint8Array(b)\n    // eslint-disable-next-line no-fallthrough\n    case Uint8Array: {\n      if (a.byteLength !== b.byteLength) {\n        return false\n      }\n      for (let i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) {\n          return false\n        }\n      }\n      break\n    }\n    case Set: {\n      if (a.size !== b.size) {\n        return false\n      }\n      for (const value of a) {\n        if (!b.has(value)) {\n          return false\n        }\n      }\n      break\n    }\n    case Map: {\n      if (a.size !== b.size) {\n        return false\n      }\n      for (const key of a.keys()) {\n        if (!b.has(key) || !equalityDeep(a.get(key), b.get(key))) {\n          return false\n        }\n      }\n      break\n    }\n    case Object:\n      if (object.length(a) !== object.length(b)) {\n        return false\n      }\n      for (const key in a) {\n        if (!object.hasProperty(a, key) || !equalityDeep(a[key], b[key])) {\n          return false\n        }\n      }\n      break\n    case Array:\n      if (a.length !== b.length) {\n        return false\n      }\n      for (let i = 0; i < a.length; i++) {\n        if (!equalityDeep(a[i], b[i])) {\n          return false\n        }\n      }\n      break\n    default:\n      return false\n  }\n  return true\n}\n\n/**\n * @template V\n * @template {V} OPTS\n *\n * @param {V} value\n * @param {Array<OPTS>} options\n */\n// @ts-ignore\nexport const isOneOf = (value, options) => options.includes(value)\n/* c8 ignore stop */\n\nexport const isArray = array.isArray\n\n/**\n * @param {any} s\n * @return {s is String}\n */\nexport const isString = (s) => s && s.constructor === String\n\n/**\n * @param {any} n\n * @return {n is Number}\n */\nexport const isNumber = n => n != null && n.constructor === Number\n\n/**\n * @template {abstract new (...args: any) => any} TYPE\n * @param {any} n\n * @param {TYPE} T\n * @return {n is InstanceType<TYPE>}\n */\nexport const is = (n, T) => n && n.constructor === T\n\n/**\n * @template {abstract new (...args: any) => any} TYPE\n * @param {TYPE} T\n */\nexport const isTemplate = (T) =>\n  /**\n   * @param {any} n\n   * @return {n is InstanceType<TYPE>}\n   **/\n  n => n && n.constructor === T\n","/**\n * @module awareness-protocol\n */\n\nimport * as encoding from 'lib0/encoding'\nimport * as decoding from 'lib0/decoding'\nimport * as time from 'lib0/time'\nimport * as math from 'lib0/math'\nimport { Observable } from 'lib0/observable'\nimport * as f from 'lib0/function'\nimport * as Y from 'yjs' // eslint-disable-line\n\nexport const outdatedTimeout = 30000\n\n/**\n * @typedef {Object} MetaClientState\n * @property {number} MetaClientState.clock\n * @property {number} MetaClientState.lastUpdated unix timestamp\n */\n\n/**\n * The Awareness class implements a simple shared state protocol that can be used for non-persistent data like awareness information\n * (cursor, username, status, ..). Each client can update its own local state and listen to state changes of\n * remote clients. Every client may set a state of a remote peer to `null` to mark the client as offline.\n *\n * Each client is identified by a unique client id (something we borrow from `doc.clientID`). A client can override\n * its own state by propagating a message with an increasing timestamp (`clock`). If such a message is received, it is\n * applied if the known state of that client is older than the new state (`clock < newClock`). If a client thinks that\n * a remote client is offline, it may propagate a message with\n * `{ clock: currentClientClock, state: null, client: remoteClient }`. If such a\n * message is received, and the known clock of that client equals the received clock, it will override the state with `null`.\n *\n * Before a client disconnects, it should propagate a `null` state with an updated clock.\n *\n * Awareness states must be updated every 30 seconds. Otherwise the Awareness instance will delete the client state.\n *\n * @extends {Observable<string>}\n */\nexport class Awareness extends Observable {\n  /**\n   * @param {Y.Doc} doc\n   */\n  constructor (doc) {\n    super()\n    this.doc = doc\n    /**\n     * @type {number}\n     */\n    this.clientID = doc.clientID\n    /**\n     * Maps from client id to client state\n     * @type {Map<number, Object<string, any>>}\n     */\n    this.states = new Map()\n    /**\n     * @type {Map<number, MetaClientState>}\n     */\n    this.meta = new Map()\n    this._checkInterval = /** @type {any} */ (setInterval(() => {\n      const now = time.getUnixTime()\n      if (this.getLocalState() !== null && (outdatedTimeout / 2 <= now - /** @type {{lastUpdated:number}} */ (this.meta.get(this.clientID)).lastUpdated)) {\n        // renew local clock\n        this.setLocalState(this.getLocalState())\n      }\n      /**\n       * @type {Array<number>}\n       */\n      const remove = []\n      this.meta.forEach((meta, clientid) => {\n        if (clientid !== this.clientID && outdatedTimeout <= now - meta.lastUpdated && this.states.has(clientid)) {\n          remove.push(clientid)\n        }\n      })\n      if (remove.length > 0) {\n        removeAwarenessStates(this, remove, 'timeout')\n      }\n    }, math.floor(outdatedTimeout / 10)))\n    doc.on('destroy', () => {\n      this.destroy()\n    })\n    this.setLocalState({})\n  }\n\n  destroy () {\n    this.emit('destroy', [this])\n    this.setLocalState(null)\n    super.destroy()\n    clearInterval(this._checkInterval)\n  }\n\n  /**\n   * @return {Object<string,any>|null}\n   */\n  getLocalState () {\n    return this.states.get(this.clientID) || null\n  }\n\n  /**\n   * @param {Object<string,any>|null} state\n   */\n  setLocalState (state) {\n    const clientID = this.clientID\n    const currLocalMeta = this.meta.get(clientID)\n    const clock = currLocalMeta === undefined ? 0 : currLocalMeta.clock + 1\n    const prevState = this.states.get(clientID)\n    if (state === null) {\n      this.states.delete(clientID)\n    } else {\n      this.states.set(clientID, state)\n    }\n    this.meta.set(clientID, {\n      clock,\n      lastUpdated: time.getUnixTime()\n    })\n    const added = []\n    const updated = []\n    const filteredUpdated = []\n    const removed = []\n    if (state === null) {\n      removed.push(clientID)\n    } else if (prevState == null) {\n      if (state != null) {\n        added.push(clientID)\n      }\n    } else {\n      updated.push(clientID)\n      if (!f.equalityDeep(prevState, state)) {\n        filteredUpdated.push(clientID)\n      }\n    }\n    if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {\n      this.emit('change', [{ added, updated: filteredUpdated, removed }, 'local'])\n    }\n    this.emit('update', [{ added, updated, removed }, 'local'])\n  }\n\n  /**\n   * @param {string} field\n   * @param {any} value\n   */\n  setLocalStateField (field, value) {\n    const state = this.getLocalState()\n    if (state !== null) {\n      this.setLocalState({\n        ...state,\n        [field]: value\n      })\n    }\n  }\n\n  /**\n   * @return {Map<number,Object<string,any>>}\n   */\n  getStates () {\n    return this.states\n  }\n}\n\n/**\n * Mark (remote) clients as inactive and remove them from the list of active peers.\n * This change will be propagated to remote clients.\n *\n * @param {Awareness} awareness\n * @param {Array<number>} clients\n * @param {any} origin\n */\nexport const removeAwarenessStates = (awareness, clients, origin) => {\n  const removed = []\n  for (let i = 0; i < clients.length; i++) {\n    const clientID = clients[i]\n    if (awareness.states.has(clientID)) {\n      awareness.states.delete(clientID)\n      if (clientID === awareness.clientID) {\n        const curMeta = /** @type {MetaClientState} */ (awareness.meta.get(clientID))\n        awareness.meta.set(clientID, {\n          clock: curMeta.clock + 1,\n          lastUpdated: time.getUnixTime()\n        })\n      }\n      removed.push(clientID)\n    }\n  }\n  if (removed.length > 0) {\n    awareness.emit('change', [{ added: [], updated: [], removed }, origin])\n    awareness.emit('update', [{ added: [], updated: [], removed }, origin])\n  }\n}\n\n/**\n * @param {Awareness} awareness\n * @param {Array<number>} clients\n * @return {Uint8Array}\n */\nexport const encodeAwarenessUpdate = (awareness, clients, states = awareness.states) => {\n  const len = clients.length\n  const encoder = encoding.createEncoder()\n  encoding.writeVarUint(encoder, len)\n  for (let i = 0; i < len; i++) {\n    const clientID = clients[i]\n    const state = states.get(clientID) || null\n    const clock = /** @type {MetaClientState} */ (awareness.meta.get(clientID)).clock\n    encoding.writeVarUint(encoder, clientID)\n    encoding.writeVarUint(encoder, clock)\n    encoding.writeVarString(encoder, JSON.stringify(state))\n  }\n  return encoding.toUint8Array(encoder)\n}\n\n/**\n * Modify the content of an awareness update before re-encoding it to an awareness update.\n *\n * This might be useful when you have a central server that wants to ensure that clients\n * cant hijack somebody elses identity.\n *\n * @param {Uint8Array} update\n * @param {function(any):any} modify\n * @return {Uint8Array}\n */\nexport const modifyAwarenessUpdate = (update, modify) => {\n  const decoder = decoding.createDecoder(update)\n  const encoder = encoding.createEncoder()\n  const len = decoding.readVarUint(decoder)\n  encoding.writeVarUint(encoder, len)\n  for (let i = 0; i < len; i++) {\n    const clientID = decoding.readVarUint(decoder)\n    const clock = decoding.readVarUint(decoder)\n    const state = JSON.parse(decoding.readVarString(decoder))\n    const modifiedState = modify(state)\n    encoding.writeVarUint(encoder, clientID)\n    encoding.writeVarUint(encoder, clock)\n    encoding.writeVarString(encoder, JSON.stringify(modifiedState))\n  }\n  return encoding.toUint8Array(encoder)\n}\n\n/**\n * @param {Awareness} awareness\n * @param {Uint8Array} update\n * @param {any} origin This will be added to the emitted change event\n */\nexport const applyAwarenessUpdate = (awareness, update, origin) => {\n  const decoder = decoding.createDecoder(update)\n  const timestamp = time.getUnixTime()\n  const added = []\n  const updated = []\n  const filteredUpdated = []\n  const removed = []\n  const len = decoding.readVarUint(decoder)\n  for (let i = 0; i < len; i++) {\n    const clientID = decoding.readVarUint(decoder)\n    let clock = decoding.readVarUint(decoder)\n    const state = JSON.parse(decoding.readVarString(decoder))\n    const clientMeta = awareness.meta.get(clientID)\n    const prevState = awareness.states.get(clientID)\n    const currClock = clientMeta === undefined ? 0 : clientMeta.clock\n    if (currClock < clock || (currClock === clock && state === null && awareness.states.has(clientID))) {\n      if (state === null) {\n        // never let a remote client remove this local state\n        if (clientID === awareness.clientID && awareness.getLocalState() != null) {\n          // remote client removed the local state. Do not remote state. Broadcast a message indicating\n          // that this client still exists by increasing the clock\n          clock++\n        } else {\n          awareness.states.delete(clientID)\n        }\n      } else {\n        awareness.states.set(clientID, state)\n      }\n      awareness.meta.set(clientID, {\n        clock,\n        lastUpdated: timestamp\n      })\n      if (clientMeta === undefined && state !== null) {\n        added.push(clientID)\n      } else if (clientMeta !== undefined && state === null) {\n        removed.push(clientID)\n      } else if (state !== null) {\n        if (!f.equalityDeep(state, prevState)) {\n          filteredUpdated.push(clientID)\n        }\n        updated.push(clientID)\n      }\n    }\n  }\n  if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {\n    awareness.emit('change', [{\n      added, updated: filteredUpdated, removed\n    }, origin])\n  }\n  if (added.length > 0 || updated.length > 0 || removed.length > 0) {\n    awareness.emit('update', [{\n      added, updated, removed\n    }, origin])\n  }\n}\n","/**\n * Observable class prototype.\n *\n * @module observable\n */\n\nimport * as map from './map.js'\nimport * as set from './set.js'\nimport * as array from './array.js'\n\n/**\n * Handles named events.\n * @experimental\n *\n * This is basically a (better typed) duplicate of Observable, which will replace Observable in the\n * next release.\n *\n * @template {{[key in keyof EVENTS]: function(...any):void}} EVENTS\n */\nexport class ObservableV2 {\n  constructor () {\n    /**\n     * Some desc.\n     * @type {Map<string, Set<any>>}\n     */\n    this._observers = map.create()\n  }\n\n  /**\n   * @template {keyof EVENTS & string} NAME\n   * @param {NAME} name\n   * @param {EVENTS[NAME]} f\n   */\n  on (name, f) {\n    map.setIfUndefined(this._observers, /** @type {string} */ (name), set.create).add(f)\n    return f\n  }\n\n  /**\n   * @template {keyof EVENTS & string} NAME\n   * @param {NAME} name\n   * @param {EVENTS[NAME]} f\n   */\n  once (name, f) {\n    /**\n     * @param  {...any} args\n     */\n    const _f = (...args) => {\n      this.off(name, /** @type {any} */ (_f))\n      f(...args)\n    }\n    this.on(name, /** @type {any} */ (_f))\n  }\n\n  /**\n   * @template {keyof EVENTS & string} NAME\n   * @param {NAME} name\n   * @param {EVENTS[NAME]} f\n   */\n  off (name, f) {\n    const observers = this._observers.get(name)\n    if (observers !== undefined) {\n      observers.delete(f)\n      if (observers.size === 0) {\n        this._observers.delete(name)\n      }\n    }\n  }\n\n  /**\n   * Emit a named event. All registered event listeners that listen to the\n   * specified name will receive the event.\n   *\n   * @todo This should catch exceptions\n   *\n   * @template {keyof EVENTS & string} NAME\n   * @param {NAME} name The event name.\n   * @param {Parameters<EVENTS[NAME]>} args The arguments that are applied to the event listener.\n   */\n  emit (name, args) {\n    // copy all listeners to an array first to make sure that no event is emitted to listeners that are subscribed while the event handler is called.\n    return array.from((this._observers.get(name) || map.create()).values()).forEach(f => f(...args))\n  }\n\n  destroy () {\n    this._observers = map.create()\n  }\n}\n\n/* c8 ignore start */\n/**\n * Handles named events.\n *\n * @deprecated\n * @template N\n */\nexport class Observable {\n  constructor () {\n    /**\n     * Some desc.\n     * @type {Map<N, any>}\n     */\n    this._observers = map.create()\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  on (name, f) {\n    map.setIfUndefined(this._observers, name, set.create).add(f)\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  once (name, f) {\n    /**\n     * @param  {...any} args\n     */\n    const _f = (...args) => {\n      this.off(name, _f)\n      f(...args)\n    }\n    this.on(name, _f)\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  off (name, f) {\n    const observers = this._observers.get(name)\n    if (observers !== undefined) {\n      observers.delete(f)\n      if (observers.size === 0) {\n        this._observers.delete(name)\n      }\n    }\n  }\n\n  /**\n   * Emit a named event. All registered event listeners that listen to the\n   * specified name will receive the event.\n   *\n   * @todo This should catch exceptions\n   *\n   * @param {N} name The event name.\n   * @param {Array<any>} args The arguments that are applied to the event listener.\n   */\n  emit (name, args) {\n    // copy all listeners to an array first to make sure that no event is emitted to listeners that are subscribed while the event handler is called.\n    return array.from((this._observers.get(name) || map.create()).values()).forEach(f => f(...args))\n  }\n\n  destroy () {\n    this._observers = map.create()\n  }\n}\n/* c8 ignore end */\n","/**\n * Utility functions for working with EcmaScript objects.\n *\n * @module object\n */\n\n/**\n * @return {Object<string,any>} obj\n */\nexport const create = () => Object.create(null)\n\n/**\n * Object.assign\n */\nexport const assign = Object.assign\n\n/**\n * @param {Object<string,any>} obj\n */\nexport const keys = Object.keys\n\n/**\n * @template V\n * @param {{[key:string]: V}} obj\n * @return {Array<V>}\n */\nexport const values = Object.values\n\n/**\n * @template V\n * @param {{[k:string]:V}} obj\n * @param {function(V,string):any} f\n */\nexport const forEach = (obj, f) => {\n  for (const key in obj) {\n    f(obj[key], key)\n  }\n}\n\n/**\n * @todo implement mapToArray & map\n *\n * @template R\n * @param {Object<string,any>} obj\n * @param {function(any,string):R} f\n * @return {Array<R>}\n */\nexport const map = (obj, f) => {\n  const results = []\n  for (const key in obj) {\n    results.push(f(obj[key], key))\n  }\n  return results\n}\n\n/**\n * @deprecated use object.size instead\n * @param {Object<string,any>} obj\n * @return {number}\n */\nexport const length = obj => keys(obj).length\n\n/**\n * @param {Object<string,any>} obj\n * @return {number}\n */\nexport const size = obj => keys(obj).length\n\n/**\n * @template {{ [key:string|number|symbol]: any }} T\n * @param {T} obj\n * @param {(v:T[keyof T],k:keyof T)=>boolean} f\n * @return {boolean}\n */\nexport const some = (obj, f) => {\n  for (const key in obj) {\n    if (f(obj[key], key)) {\n      return true\n    }\n  }\n  return false\n}\n\n/**\n * @param {Object|null|undefined} obj\n */\nexport const isEmpty = obj => {\n  // eslint-disable-next-line no-unreachable-loop\n  for (const _k in obj) {\n    return false\n  }\n  return true\n}\n\n/**\n * @template {{ [key:string|number|symbol]: any }} T\n * @param {T} obj\n * @param {(v:T[keyof T],k:keyof T)=>boolean} f\n * @return {boolean}\n */\nexport const every = (obj, f) => {\n  for (const key in obj) {\n    if (!f(obj[key], key)) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * Calls `Object.prototype.hasOwnProperty`.\n *\n * @param {any} obj\n * @param {string|number|symbol} key\n * @return {boolean}\n */\nexport const hasProperty = (obj, key) => Object.prototype.hasOwnProperty.call(obj, key)\n\n/**\n * @param {Object<string,any>} a\n * @param {Object<string,any>} b\n * @return {boolean}\n */\nexport const equalFlat = (a, b) => a === b || (size(a) === size(b) && every(a, (val, key) => (val !== undefined || hasProperty(b, key)) && b[key] === val))\n\n/**\n * Make an object immutable. This hurts performance and is usually not needed if you perform good\n * coding practices.\n */\nexport const freeze = Object.freeze\n\n/**\n * Make an object and all its children immutable.\n * This *really* hurts performance and is usually not needed if you perform good coding practices.\n *\n * @template {any} T\n * @param {T} o\n * @return {Readonly<T>}\n */\nexport const deepFreeze = (o) => {\n  for (const key in o) {\n    const c = o[key]\n    if (typeof c === 'object' || typeof c === 'function') {\n      deepFreeze(o[key])\n    }\n  }\n  return freeze(o)\n}\n\n/**\n * Get object property. Create T if property is undefined and set T on object.\n *\n * @function\n * @template {object} KV\n * @template {keyof KV} [K=keyof KV]\n * @param {KV} o\n * @param {K} key\n * @param {() => KV[K]} createT\n * @return {KV[K]}\n */\nexport const setIfUndefined = (o, key, createT) => hasProperty(o, key) ? o[key] : (o[key] = createT())\n","/**\n * @module provider/websocket\n */\n\n/* eslint-env browser */\n\nimport * as Y from 'yjs' // eslint-disable-line\nimport * as bc from 'lib0/broadcastchannel'\nimport * as time from 'lib0/time'\nimport * as encoding from 'lib0/encoding'\nimport * as decoding from 'lib0/decoding'\nimport * as syncProtocol from 'y-protocols/sync'\nimport * as authProtocol from 'y-protocols/auth'\nimport * as awarenessProtocol from 'y-protocols/awareness'\nimport { ObservableV2 } from 'lib0/observable'\nimport * as math from 'lib0/math'\nimport * as url from 'lib0/url'\nimport * as env from 'lib0/environment'\n\nexport const messageSync = 0\nexport const messageQueryAwareness = 3\nexport const messageAwareness = 1\nexport const messageAuth = 2\n\n/**\n *                       encoder,          decoder,          provider,          emitSynced, messageType\n * @type {Array<function(encoding.Encoder, decoding.Decoder, WebsocketProvider, boolean,    number):void>}\n */\nconst messageHandlers = []\n\nmessageHandlers[messageSync] = (\n  encoder,\n  decoder,\n  provider,\n  emitSynced,\n  _messageType\n) => {\n  encoding.writeVarUint(encoder, messageSync)\n  const syncMessageType = syncProtocol.readSyncMessage(\n    decoder,\n    encoder,\n    provider.doc,\n    provider\n  )\n  if (\n    emitSynced && syncMessageType === syncProtocol.messageYjsSyncStep2 &&\n    !provider.synced\n  ) {\n    provider.synced = true\n  }\n}\n\nmessageHandlers[messageQueryAwareness] = (\n  encoder,\n  _decoder,\n  provider,\n  _emitSynced,\n  _messageType\n) => {\n  encoding.writeVarUint(encoder, messageAwareness)\n  encoding.writeVarUint8Array(\n    encoder,\n    awarenessProtocol.encodeAwarenessUpdate(\n      provider.awareness,\n      Array.from(provider.awareness.getStates().keys())\n    )\n  )\n}\n\nmessageHandlers[messageAwareness] = (\n  _encoder,\n  decoder,\n  provider,\n  _emitSynced,\n  _messageType\n) => {\n  awarenessProtocol.applyAwarenessUpdate(\n    provider.awareness,\n    decoding.readVarUint8Array(decoder),\n    provider\n  )\n}\n\nmessageHandlers[messageAuth] = (\n  _encoder,\n  decoder,\n  provider,\n  _emitSynced,\n  _messageType\n) => {\n  authProtocol.readAuthMessage(\n    decoder,\n    provider.doc,\n    (_ydoc, reason) => permissionDeniedHandler(provider, reason)\n  )\n}\n\n// @todo - this should depend on awareness.outdatedTime\nconst messageReconnectTimeout = 30000\n\n/**\n * @param {WebsocketProvider} provider\n * @param {string} reason\n */\nconst permissionDeniedHandler = (provider, reason) =>\n  console.warn(`Permission denied to access ${provider.url}.\\n${reason}`)\n\n/**\n * @param {WebsocketProvider} provider\n * @param {Uint8Array} buf\n * @param {boolean} emitSynced\n * @return {encoding.Encoder}\n */\nconst readMessage = (provider, buf, emitSynced) => {\n  const decoder = decoding.createDecoder(buf)\n  const encoder = encoding.createEncoder()\n  const messageType = decoding.readVarUint(decoder)\n  const messageHandler = provider.messageHandlers[messageType]\n  if (/** @type {any} */ (messageHandler)) {\n    messageHandler(encoder, decoder, provider, emitSynced, messageType)\n  } else {\n    console.error('Unable to compute message')\n  }\n  return encoder\n}\n\n/**\n * Outsource this function so that a new websocket connection is created immediately.\n * I suspect that the `ws.onclose` event is not always fired if there are network issues.\n *\n * @param {WebsocketProvider} provider\n * @param {WebSocket} ws\n * @param {CloseEvent | null} event\n */\nconst closeWebsocketConnection = (provider, ws, event) => {\n  if (ws === provider.ws) {\n    provider.emit('connection-close', [event, provider])\n    provider.ws = null\n    ws.close()\n    provider.wsconnecting = false\n    if (provider.wsconnected) {\n      provider.wsconnected = false\n      provider.synced = false\n      // update awareness (all users except local left)\n      awarenessProtocol.removeAwarenessStates(\n        provider.awareness,\n        Array.from(provider.awareness.getStates().keys()).filter((client) =>\n          client !== provider.doc.clientID\n        ),\n        provider\n      )\n      provider.emit('status', [{\n        status: 'disconnected'\n      }])\n    } else {\n      provider.wsUnsuccessfulReconnects++\n    }\n    // Start with no reconnect timeout and increase timeout by\n    // using exponential backoff starting with 100ms\n    setTimeout(\n      setupWS,\n      math.min(\n        math.pow(2, provider.wsUnsuccessfulReconnects) * 100,\n        provider.maxBackoffTime\n      ),\n      provider\n    )\n  }\n}\n\n/**\n * @param {WebsocketProvider} provider\n */\nconst setupWS = (provider) => {\n  if (provider.shouldConnect && provider.ws === null) {\n    const websocket = new provider._WS(provider.url, provider.protocols)\n    websocket.binaryType = 'arraybuffer'\n    provider.ws = websocket\n    provider.wsconnecting = true\n    provider.wsconnected = false\n    provider.synced = false\n\n    websocket.onmessage = (event) => {\n      provider.wsLastMessageReceived = time.getUnixTime()\n      const encoder = readMessage(provider, new Uint8Array(event.data), true)\n      if (encoding.length(encoder) > 1) {\n        websocket.send(encoding.toUint8Array(encoder))\n      }\n    }\n    websocket.onerror = (event) => {\n      provider.emit('connection-error', [event, provider])\n    }\n    websocket.onclose = (event) => {\n      closeWebsocketConnection(provider, websocket, event)\n    }\n    websocket.onopen = () => {\n      provider.wsLastMessageReceived = time.getUnixTime()\n      provider.wsconnecting = false\n      provider.wsconnected = true\n      provider.wsUnsuccessfulReconnects = 0\n      provider.emit('status', [{\n        status: 'connected'\n      }])\n      // always send sync step 1 when connected\n      const encoder = encoding.createEncoder()\n      encoding.writeVarUint(encoder, messageSync)\n      syncProtocol.writeSyncStep1(encoder, provider.doc)\n      websocket.send(encoding.toUint8Array(encoder))\n      // broadcast local awareness state\n      if (provider.awareness.getLocalState() !== null) {\n        const encoderAwarenessState = encoding.createEncoder()\n        encoding.writeVarUint(encoderAwarenessState, messageAwareness)\n        encoding.writeVarUint8Array(\n          encoderAwarenessState,\n          awarenessProtocol.encodeAwarenessUpdate(provider.awareness, [\n            provider.doc.clientID\n          ])\n        )\n        websocket.send(encoding.toUint8Array(encoderAwarenessState))\n      }\n    }\n    provider.emit('status', [{\n      status: 'connecting'\n    }])\n  }\n}\n\n/**\n * @param {WebsocketProvider} provider\n * @param {ArrayBuffer} buf\n */\nconst broadcastMessage = (provider, buf) => {\n  const ws = provider.ws\n  if (provider.wsconnected && ws && ws.readyState === ws.OPEN) {\n    ws.send(buf)\n  }\n  if (provider.bcconnected) {\n    bc.publish(provider.bcChannel, buf, provider)\n  }\n}\n\n/**\n * Websocket Provider for Yjs. Creates a websocket connection to sync the shared document.\n * The document name is attached to the provided url. I.e. the following example\n * creates a websocket connection to http://localhost:1234/my-document-name\n *\n * @example\n *   import * as Y from 'yjs'\n *   import { WebsocketProvider } from 'y-websocket'\n *   const doc = new Y.Doc()\n *   const provider = new WebsocketProvider('http://localhost:1234', 'my-document-name', doc)\n *\n * @extends {ObservableV2<{ 'connection-close': (event: CloseEvent | null,  provider: WebsocketProvider) => any, 'status': (event: { status: 'connected' | 'disconnected' | 'connecting' }) => any, 'connection-error': (event: Event, provider: WebsocketProvider) => any, 'sync': (state: boolean) => any }>}\n */\nexport class WebsocketProvider extends ObservableV2 {\n  /**\n   * @param {string} serverUrl\n   * @param {string} roomname\n   * @param {Y.Doc} doc\n   * @param {object} opts\n   * @param {boolean} [opts.connect]\n   * @param {awarenessProtocol.Awareness} [opts.awareness]\n   * @param {Object<string,string>} [opts.params] specify url parameters\n   * @param {Array<string>} [opts.protocols] specify websocket protocols\n   * @param {typeof WebSocket} [opts.WebSocketPolyfill] Optionall provide a WebSocket polyfill\n   * @param {number} [opts.resyncInterval] Request server state every `resyncInterval` milliseconds\n   * @param {number} [opts.maxBackoffTime] Maximum amount of time to wait before trying to reconnect (we try to reconnect using exponential backoff)\n   * @param {boolean} [opts.disableBc] Disable cross-tab BroadcastChannel communication\n   */\n  constructor (serverUrl, roomname, doc, {\n    connect = true,\n    awareness = new awarenessProtocol.Awareness(doc),\n    params = {},\n    protocols = [],\n    WebSocketPolyfill = WebSocket,\n    resyncInterval = -1,\n    maxBackoffTime = 2500,\n    disableBc = false\n  } = {}) {\n    super()\n    // ensure that serverUrl does not end with /\n    while (serverUrl[serverUrl.length - 1] === '/') {\n      serverUrl = serverUrl.slice(0, serverUrl.length - 1)\n    }\n    this.serverUrl = serverUrl\n    this.bcChannel = serverUrl + '/' + roomname\n    this.maxBackoffTime = maxBackoffTime\n    /**\n     * The specified url parameters. This can be safely updated. The changed parameters will be used\n     * when a new connection is established.\n     * @type {Object<string,string>}\n     */\n    this.params = params\n    this.protocols = protocols\n    this.roomname = roomname\n    this.doc = doc\n    this._WS = WebSocketPolyfill\n    this.awareness = awareness\n    this.wsconnected = false\n    this.wsconnecting = false\n    this.bcconnected = false\n    this.disableBc = disableBc\n    this.wsUnsuccessfulReconnects = 0\n    this.messageHandlers = messageHandlers.slice()\n    /**\n     * @type {boolean}\n     */\n    this._synced = false\n    /**\n     * @type {WebSocket?}\n     */\n    this.ws = null\n    this.wsLastMessageReceived = 0\n    /**\n     * Whether to connect to other peers or not\n     * @type {boolean}\n     */\n    this.shouldConnect = connect\n\n    /**\n     * @type {number}\n     */\n    this._resyncInterval = 0\n    if (resyncInterval > 0) {\n      this._resyncInterval = /** @type {any} */ (setInterval(() => {\n        if (this.ws && this.ws.readyState === WebSocket.OPEN) {\n          // resend sync step 1\n          const encoder = encoding.createEncoder()\n          encoding.writeVarUint(encoder, messageSync)\n          syncProtocol.writeSyncStep1(encoder, doc)\n          this.ws.send(encoding.toUint8Array(encoder))\n        }\n      }, resyncInterval))\n    }\n\n    /**\n     * @param {ArrayBuffer} data\n     * @param {any} origin\n     */\n    this._bcSubscriber = (data, origin) => {\n      if (origin !== this) {\n        const encoder = readMessage(this, new Uint8Array(data), false)\n        if (encoding.length(encoder) > 1) {\n          bc.publish(this.bcChannel, encoding.toUint8Array(encoder), this)\n        }\n      }\n    }\n    /**\n     * Listens to Yjs updates and sends them to remote peers (ws and broadcastchannel)\n     * @param {Uint8Array} update\n     * @param {any} origin\n     */\n    this._updateHandler = (update, origin) => {\n      if (origin !== this) {\n        const encoder = encoding.createEncoder()\n        encoding.writeVarUint(encoder, messageSync)\n        syncProtocol.writeUpdate(encoder, update)\n        broadcastMessage(this, encoding.toUint8Array(encoder))\n      }\n    }\n    this.doc.on('update', this._updateHandler)\n    /**\n     * @param {any} changed\n     * @param {any} _origin\n     */\n    this._awarenessUpdateHandler = ({ added, updated, removed }, _origin) => {\n      const changedClients = added.concat(updated).concat(removed)\n      const encoder = encoding.createEncoder()\n      encoding.writeVarUint(encoder, messageAwareness)\n      encoding.writeVarUint8Array(\n        encoder,\n        awarenessProtocol.encodeAwarenessUpdate(awareness, changedClients)\n      )\n      broadcastMessage(this, encoding.toUint8Array(encoder))\n    }\n    this._exitHandler = () => {\n      awarenessProtocol.removeAwarenessStates(\n        this.awareness,\n        [doc.clientID],\n        'app closed'\n      )\n    }\n    if (env.isNode && typeof process !== 'undefined') {\n      process.on('exit', this._exitHandler)\n    }\n    awareness.on('update', this._awarenessUpdateHandler)\n    this._checkInterval = /** @type {any} */ (setInterval(() => {\n      if (\n        this.wsconnected &&\n        messageReconnectTimeout <\n          time.getUnixTime() - this.wsLastMessageReceived\n      ) {\n        // no message received in a long time - not even your own awareness\n        // updates (which are updated every 15 seconds)\n        closeWebsocketConnection(this, /** @type {WebSocket} */ (this.ws), null)\n      }\n    }, messageReconnectTimeout / 10))\n    if (connect) {\n      this.connect()\n    }\n  }\n\n  get url () {\n    const encodedParams = url.encodeQueryParams(this.params)\n    return this.serverUrl + '/' + this.roomname +\n      (encodedParams.length === 0 ? '' : '?' + encodedParams)\n  }\n\n  /**\n   * @type {boolean}\n   */\n  get synced () {\n    return this._synced\n  }\n\n  set synced (state) {\n    if (this._synced !== state) {\n      this._synced = state\n      // @ts-ignore\n      this.emit('synced', [state])\n      this.emit('sync', [state])\n    }\n  }\n\n  destroy () {\n    if (this._resyncInterval !== 0) {\n      clearInterval(this._resyncInterval)\n    }\n    clearInterval(this._checkInterval)\n    this.disconnect()\n    if (env.isNode && typeof process !== 'undefined') {\n      process.off('exit', this._exitHandler)\n    }\n    this.awareness.off('update', this._awarenessUpdateHandler)\n    this.doc.off('update', this._updateHandler)\n    super.destroy()\n  }\n\n  connectBc () {\n    if (this.disableBc) {\n      return\n    }\n    if (!this.bcconnected) {\n      bc.subscribe(this.bcChannel, this._bcSubscriber)\n      this.bcconnected = true\n    }\n    // send sync step1 to bc\n    // write sync step 1\n    const encoderSync = encoding.createEncoder()\n    encoding.writeVarUint(encoderSync, messageSync)\n    syncProtocol.writeSyncStep1(encoderSync, this.doc)\n    bc.publish(this.bcChannel, encoding.toUint8Array(encoderSync), this)\n    // broadcast local state\n    const encoderState = encoding.createEncoder()\n    encoding.writeVarUint(encoderState, messageSync)\n    syncProtocol.writeSyncStep2(encoderState, this.doc)\n    bc.publish(this.bcChannel, encoding.toUint8Array(encoderState), this)\n    // write queryAwareness\n    const encoderAwarenessQuery = encoding.createEncoder()\n    encoding.writeVarUint(encoderAwarenessQuery, messageQueryAwareness)\n    bc.publish(\n      this.bcChannel,\n      encoding.toUint8Array(encoderAwarenessQuery),\n      this\n    )\n    // broadcast local awareness state\n    const encoderAwarenessState = encoding.createEncoder()\n    encoding.writeVarUint(encoderAwarenessState, messageAwareness)\n    encoding.writeVarUint8Array(\n      encoderAwarenessState,\n      awarenessProtocol.encodeAwarenessUpdate(this.awareness, [\n        this.doc.clientID\n      ])\n    )\n    bc.publish(\n      this.bcChannel,\n      encoding.toUint8Array(encoderAwarenessState),\n      this\n    )\n  }\n\n  disconnectBc () {\n    // broadcast message with local awareness state set to null (indicating disconnect)\n    const encoder = encoding.createEncoder()\n    encoding.writeVarUint(encoder, messageAwareness)\n    encoding.writeVarUint8Array(\n      encoder,\n      awarenessProtocol.encodeAwarenessUpdate(this.awareness, [\n        this.doc.clientID\n      ], new Map())\n    )\n    broadcastMessage(this, encoding.toUint8Array(encoder))\n    if (this.bcconnected) {\n      bc.unsubscribe(this.bcChannel, this._bcSubscriber)\n      this.bcconnected = false\n    }\n  }\n\n  disconnect () {\n    this.shouldConnect = false\n    this.disconnectBc()\n    if (this.ws !== null) {\n      closeWebsocketConnection(this, this.ws, null)\n    }\n  }\n\n  connect () {\n    this.shouldConnect = true\n    if (!this.wsconnected && this.ws === null) {\n      setupWS(this)\n      this.connectBc()\n    }\n  }\n}\n","\nimport * as Y from 'yjs' // eslint-disable-line\nimport * as encoding from 'lib0/encoding'\nimport * as decoding from 'lib0/decoding'\n\nexport const messagePermissionDenied = 0\n\n/**\n * @param {encoding.Encoder} encoder\n * @param {string} reason\n */\nexport const writePermissionDenied = (encoder, reason) => {\n  encoding.writeVarUint(encoder, messagePermissionDenied)\n  encoding.writeVarString(encoder, reason)\n}\n\n/**\n * @callback PermissionDeniedHandler\n * @param {any} y\n * @param {string} reason\n */\n\n/**\n *\n * @param {decoding.Decoder} decoder\n * @param {Y.Doc} y\n * @param {PermissionDeniedHandler} permissionDeniedHandler\n */\nexport const readAuthMessage = (decoder, y, permissionDeniedHandler) => {\n  switch (decoding.readVarUint(decoder)) {\n    case messagePermissionDenied: permissionDeniedHandler(y, decoding.readVarString(decoder))\n  }\n}\n","/**\n * Utility module to work with urls.\n *\n * @module url\n */\n\nimport * as object from './object.js'\n\n/**\n * Parse query parameters from an url.\n *\n * @param {string} url\n * @return {Object<string,string>}\n */\nexport const decodeQueryParams = url => {\n  /**\n   * @type {Object<string,string>}\n   */\n  const query = {}\n  const urlQuerySplit = url.split('?')\n  const pairs = urlQuerySplit[urlQuerySplit.length - 1].split('&')\n  for (let i = 0; i < pairs.length; i++) {\n    const item = pairs[i]\n    if (item.length > 0) {\n      const pair = item.split('=')\n      query[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1] || '')\n    }\n  }\n  return query\n}\n\n/**\n * @param {Object<string,string>} params\n * @return {string}\n */\nexport const encodeQueryParams = params =>\n  object.map(params, (val, key) => `${encodeURIComponent(key)}=${encodeURIComponent(val)}`).join('&')\n","import { __ } from '@wordpress/i18n';\nimport { ConnectionError } from '@wordpress/sync';\n\nexport function getErrorMessage( error: unknown, defaultMessage?: string ): string {\n\tif ( error instanceof Error ) {\n\t\treturn error.message;\n\t}\n\n\t// First look for a .data.error string (as returned by the REST API).\n\tif (\n\t\terror &&\n\t\ttypeof error === 'object' &&\n\t\t'data' in error &&\n\t\terror.data &&\n\t\ttypeof error.data === 'object' &&\n\t\t'error' in error.data\n\t) {\n\t\treturn getErrorMessage( error.data.error, defaultMessage );\n\t}\n\n\t// Next look for an error-like object with a message string.\n\tif (\n\t\terror &&\n\t\ttypeof error === 'object' &&\n\t\t'message' in error &&\n\t\ttypeof error.message === 'string'\n\t) {\n\t\treturn error.message;\n\t}\n\n\treturn defaultMessage ?? __( 'Unknown error', 'vip-real-time-collaboration' );\n}\n\nexport class WebSocketError extends Error implements ConnectionError {\n\tpublic name = 'WebSocketError';\n\n\tconstructor(\n\t\tpublic code: ConnectionError[ 'code' ],\n\t\tmessage?: string\n\t) {\n\t\tsuper( message );\n\t}\n}\n","import { isDevelopment } from '@/utilities/config';\nimport { Logger } from '@/utilities/logger';\n\nconst logger = new Logger( 'crypto' );\n\n/**\n * Generate a UUID.\n *\n * Uses window.crypto.randomUUID if available, otherwise falls back to a\n * custom implementation.\n *\n * @returns A UUID.\n */\nexport function generateUUID(): string {\n\tif ( window.isSecureContext ) {\n\t\treturn window.crypto.randomUUID();\n\t}\n\n\t// Fallback for when crypto.randomUUID is not available.\n\tif ( isDevelopment() ) {\n\t\tlogger.warn( 'Using fallback UUID function in non-secure context.' );\n\n\t\treturn 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace( /[xy]/g, function ( char ) {\n\t\t\t// eslint-disable-next-line no-bitwise\n\t\t\tconst randomValue = ( Math.random() * 16 ) | 0;\n\t\t\t// eslint-disable-next-line no-bitwise\n\t\t\tconst value = char === 'x' ? randomValue : ( randomValue & 0x3 ) | 0x8;\n\t\t\treturn value.toString( 16 );\n\t\t} );\n\t}\n\n\tthrow new Error( 'Unable to generate UUID outside of secure context in non-development mode!' );\n}\n","/**\n * External dependencies\n */\nimport type { ConnectionStatus } from '@wordpress/sync';\n\ntype ConnectionStatusCallback = ( state: ConnectionStatus ) => void;\n\n/**\n * A simple typed event emitter for sync connection status events.\n *\n * This provides a clean, type-safe way to handle the 'sync-connection-status' event\n * without relying on type assertions or extending the WebsocketProvider's event system.\n */\nexport class SyncConnectionStatusEmitter {\n\tprivate listeners: Set< ConnectionStatusCallback > = new Set();\n\n\tpublic emit( status: ConnectionStatus ): void {\n\t\tthis.listeners.forEach( listener => listener( status ) );\n\t}\n\n\tpublic on( callback: ConnectionStatusCallback ): void {\n\t\tthis.listeners.add( callback );\n\t}\n\n\tpublic off( callback: ConnectionStatusCallback ): void {\n\t\tthis.listeners.delete( callback );\n\t}\n\n\tpublic destroy(): void {\n\t\tthis.listeners.clear();\n\t}\n}\n","/**\n * External dependencies\n */\nimport apiFetch from '@wordpress/api-fetch';\nimport { __ } from '@wordpress/i18n';\nimport { WebsocketProvider, type WebsocketProviderOptions } from 'y-websocket';\n\nimport {\n\tisDevelopment,\n\tBLOG_ID,\n\tWEBSOCKET_PROVIDER_MAX_BACKOFF_IN_MS,\n\tWEBSOCKET_URL,\n} from '@/utilities/config';\nimport { generateUUID } from '@/utilities/crypto';\nimport { WebSocketError, getErrorMessage } from '@/utilities/error';\nimport { memoizeFn } from '@/utilities/function';\nimport { Logger } from '@/utilities/logger';\nimport { SyncConnectionStatusEmitter } from '@/utilities/sync-event-emitter';\n\nimport type {\n\tConnectionError,\n\tConnectionStatus,\n\tProviderCreator,\n\tProviderCreatorOptions,\n\tProviderCreatorResult,\n\tProviderEventMap,\n} from '@wordpress/sync';\n\nexport interface WebSocketConnectionConfig {\n\toptions?: WebsocketProviderOptions;\n\tserverUrl: string;\n}\n\nconst defaultResult: ProviderCreatorResult = {\n\tdestroy: () => {},\n\ton: () => {},\n};\n\n/**\n * Creates a client ID generator with in-memory storage\n */\nconst getWpClientId = memoizeFn( (): string => generateUUID() );\n\nconst logger = new Logger( 'websocket-client' );\n\n/**\n * Fetch a fresh authentication token from the REST API.\n */\nasync function fetchAuthToken( syncObjectType: string, syncObjectId: string ): Promise< string > {\n\tconst data = await apiFetch< { token: string } >( {\n\t\tpath: '/vip-rtc/v1/websocket/auth',\n\t\tmethod: 'POST',\n\t\tdata: {\n\t\t\tsyncObjectType,\n\t\t\tsyncObjectId,\n\t\t\twpClientId: getWpClientId(),\n\t\t},\n\t} );\n\n\tif ( ! data.token ) {\n\t\tthrow new Error( __( 'No auth token returned', 'vip-real-time-collaboration' ) );\n\t}\n\n\treturn data.token;\n}\n\n/**\n * Log a link to inspect the Yjs provider using Yjs inspector.\n */\nfunction logInspectUrl( provider: WebsocketProvider ): void {\n\tconst connectionConfig = {\n\t\tcreateNewDoc: false,\n\t\troom: `${ provider.roomname }?auth=${ provider.params?.auth }`,\n\t\tprovider: 'y-websocket',\n\t\turl: WEBSOCKET_URL,\n\t};\n\n\t// The inspect URL always targets a local Yjs inspector.\n\tconst inspectUrl = `http://localhost:5173/#/connection=${ encodeURIComponent(\n\t\tJSON.stringify( connectionConfig )\n\t) }`;\n\n\tlogger.info( `Yjs inspector for ${ provider.roomname }: ${ inspectUrl }` );\n}\n\n/**\n * Map WebSocket close codes to Gutenberg sync error types.\n *\n * @param {number} code - WebSocket close code\n * @return {ConnectionError} Error for known error codes\n */\nfunction getErrorFromCloseCode( code?: number ): ConnectionError {\n\tswitch ( code ) {\n\t\tcase 4001:\n\t\t\t// Connection timeout - server forces reconnect after configured duration\n\t\t\treturn new WebSocketError( 'connection-expired' );\n\t\tcase 4002:\n\t\t\t// Server reached maximum connection limit\n\t\t\treturn new WebSocketError( 'connection-limit-exceeded' );\n\t\tdefault:\n\t\t\t// Generic disconnection, no specific error\n\t\t\treturn new WebSocketError( 'unknown-error' );\n\t}\n}\n\n/**\n * Configure the websocket provider to use auth token for websocket connection.\n * Implement exponential backoff for reconnect attempts since we are opting out\n * of the built-in reconnect logic by disabling `provider.shouldConnect`.\n */\nfunction createConnect(\n\tprovider: WebsocketProvider,\n\tsyncObjectType: string,\n\tsyncObjectId: string\n): () => Promise< void > {\n\tlet reconnectAttempts = 0;\n\n\treturn async function (): Promise< void > {\n\t\tif ( reconnectAttempts > 0 ) {\n\t\t\tconst backoffDelayInMs = Math.min(\n\t\t\t\t1000 * 2 ** reconnectAttempts,\n\t\t\t\tWEBSOCKET_PROVIDER_MAX_BACKOFF_IN_MS\n\t\t\t);\n\n\t\t\tlogger.warn(\n\t\t\t\t`Attempting to reconnect to WebSocket in ${ Math.floor( backoffDelayInMs / 1000 ) }s...`\n\t\t\t);\n\n\t\t\tawait new Promise( resolve => setTimeout( resolve, backoffDelayInMs ) );\n\t\t}\n\n\t\treconnectAttempts += 1;\n\n\t\ttry {\n\t\t\tconst authToken = await fetchAuthToken( syncObjectType, syncObjectId );\n\n\t\t\tprovider.params = {\n\t\t\t\tauth: authToken,\n\t\t\t};\n\t\t\tprovider.connect();\n\n\t\t\t// Disable provider#shouldConnect to prevent websocket from attempting to\n\t\t\t// reconnect before the new auth token is fetched (they are short-lived).\n\t\t\t// When provider.connect() runs it updates provider#shouldConnect to true.\n\t\t\tprovider.shouldConnect = false;\n\n\t\t\tlogInspectUrl( provider );\n\t\t} catch ( error: unknown ) {\n\t\t\tlogger.error(\n\t\t\t\t`${ __(\n\t\t\t\t\t'Failed to fetch auth token and connect to WebSocket',\n\t\t\t\t\t'vip-real-time-collaboration'\n\t\t\t\t) }: ${ getErrorMessage( error ) }`\n\t\t\t);\n\t\t}\n\t};\n}\n\n/**\n * Function that creates a new WebSocket Connection.\n *\n * @param {string} serverUrl The WebSocket server URL.\n * @return {ProviderCreator} A function that connects a Y.Doc to a WebSocket server.\n */\nexport function createWebSocketConnection( serverUrl: string ): ProviderCreator {\n\tconst config: WebSocketConnectionConfig = {\n\t\tserverUrl,\n\t\toptions: {\n\t\t\t/**\n\t\t\t * Disable automatic connection to prevent websocket from attempting to connect\n\t\t\t * before the auth token is fetched.\n\t\t\t */\n\t\t\tconnect: false,\n\t\t},\n\t};\n\n\treturn async function ( {\n\t\tawareness,\n\t\tobjectType,\n\t\tobjectId,\n\t\tydoc,\n\t}: ProviderCreatorOptions ): Promise< ProviderCreatorResult > {\n\t\ttry {\n\t\t\t// For now, we only support collections and traditional post types.\n\t\t\tconst isUnsupportedObjectType =\n\t\t\t\tnull !== objectId &&\n\t\t\t\t( ! objectType.startsWith( 'postType/' ) || ! parseInt( objectId, 10 ) );\n\n\t\t\tif ( isUnsupportedObjectType ) {\n\t\t\t\tlogger.debug( 'WebSocket connection skipped for unsupported object', {\n\t\t\t\t\tobjectType,\n\t\t\t\t\tobjectId,\n\t\t\t\t} );\n\t\t\t\treturn defaultResult;\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Some entities like posts aren't unique across all sites in a multisite setup.\n\t\t\t * To avoid conflicts, we add the blog ID to the room name.\n\t\t\t *\n\t\t\t * This might not be desired for entities like sites which are unique across the\n\t\t\t * multisite. We don't sync entities like those yet. When we do, we'll need to revisit\n\t\t\t * adding the blog ID to the room name as that won't be needed.\n\t\t\t */\n\t\t\tconst roomName = `site-${ BLOG_ID ?? 1 }/${ objectType }-${ objectId ?? 'collection' }`;\n\t\t\tconst options = {\n\t\t\t\t...config.options,\n\t\t\t\tawareness,\n\t\t\t};\n\t\t\tconst provider = new WebsocketProvider( config.serverUrl, roomName, ydoc, options );\n\t\t\tconst connect = createConnect( provider, objectType, objectId ?? 'collection' );\n\n\t\t\t// Create a typed event emitter for our custom sync-connection-status event.\n\t\t\tconst syncStatusEmitter = new SyncConnectionStatusEmitter();\n\n\t\t\tconst handleConnectionClose = ( event: CloseEvent | null ): void => {\n\t\t\t\t// Emit custom sync-connection-status event\n\t\t\t\tsyncStatusEmitter.emit( {\n\t\t\t\t\tstatus: 'disconnected',\n\t\t\t\t\terror: getErrorFromCloseCode( event?.code ),\n\t\t\t\t} );\n\n\t\t\t\tvoid connect();\n\t\t\t};\n\n\t\t\tprovider.on( 'connection-close', handleConnectionClose );\n\n\t\t\t// Listen to y-websocket's status event for connecting/connected states\n\t\t\tprovider.on( 'status', ( event: ConnectionStatus ) => {\n\t\t\t\t/*\n\t\t\t\t * Skip 'disconnected' status - handled in connection-close above to preserve error details.\n\t\t\t\t * y-websocket emits 'connection-close' (with error code) then 'status: disconnected' (no error).\n\t\t\t\t */\n\t\t\t\tif ( event.status !== 'disconnected' ) {\n\t\t\t\t\tsyncStatusEmitter.emit( { status: event.status } );\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\t// Provide some debugging functions in development mode.\n\t\t\tif ( isDevelopment() ) {\n\t\t\t\t// Because there are multiple providers, disconnectWebSocket() and\n\t\t\t\t// reconnectWebSocket() will be overridden by the last entity or collection\n\t\t\t\t// provider created. Call the previous function if present.\n\n\t\t\t\tconst previousDisconnectFunction = window.VIP_RTC.debug.disconnectWebSocket;\n\t\t\t\twindow.VIP_RTC.debug.disconnectWebSocket = () => {\n\t\t\t\t\tif ( previousDisconnectFunction ) {\n\t\t\t\t\t\tpreviousDisconnectFunction();\n\t\t\t\t\t}\n\n\t\t\t\t\tprovider.disconnect();\n\t\t\t\t};\n\n\t\t\t\tconst previousReconnectFunction = window.VIP_RTC.debug.reconnectWebSocket;\n\t\t\t\twindow.VIP_RTC.debug.reconnectWebSocket = () => {\n\t\t\t\t\tif ( previousReconnectFunction ) {\n\t\t\t\t\t\tpreviousReconnectFunction();\n\t\t\t\t\t}\n\n\t\t\t\t\tvoid connect();\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tawait connect();\n\n\t\t\treturn {\n\t\t\t\tdestroy: () => {\n\t\t\t\t\tsyncStatusEmitter.destroy();\n\t\t\t\t\tprovider.destroy();\n\t\t\t\t},\n\t\t\t\ton: < K extends keyof ProviderEventMap >(\n\t\t\t\t\tevent: K,\n\t\t\t\t\tcallback: ( data: ProviderEventMap[ K ] ) => void\n\t\t\t\t) => {\n\t\t\t\t\tif ( 'status' === event ) {\n\t\t\t\t\t\tsyncStatusEmitter.on( callback );\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t};\n\t\t} catch ( err ) {\n\t\t\tlogger.critical( 'Failed to create WebSocket connection', { error: err } );\n\t\t}\n\n\t\treturn defaultResult;\n\t};\n}\n","export function memoizeFn< T extends ( ...args: unknown[] ) => unknown >( fn: T ): T {\n\tconst cache = new Map< string, ReturnType< T > >();\n\n\treturn ( ( ...args: Parameters< T > ) => {\n\t\tconst key = JSON.stringify( args );\n\t\tif ( cache.has( key ) ) {\n\t\t\treturn cache.get( key );\n\t\t}\n\n\t\tconst result = fn( ...args ) as ReturnType< T >;\n\t\tcache.set( key, result );\n\t\treturn result;\n\t} ) as T;\n}\n","import { addFilter } from '@wordpress/hooks';\n\nimport { WEBSOCKET_URL } from '@/utilities/config';\nimport { Logger } from '@/utilities/logger';\nimport { createWebSocketConnection } from '@/websocket-client';\n\naddFilter( 'sync.providers', 'vip-rtc', () => {\n\t// We already error check for the WebSocket URL in the main plugin file,\n\t// so this is here for safety.\n\tif ( ! WEBSOCKET_URL ) {\n\t\tnew Logger().critical(\n\t\t\t'VIP Real-Time Collaboration WebSocket URL has not been configured. The plugin will not be functional without it.'\n\t\t);\n\t\treturn [];\n\t}\n\n\treturn [ createWebSocketConnection( WEBSOCKET_URL ) ];\n} );\n"],"names":["__webpack_require__","module","getter","__esModule","d","a","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","window","WEBSOCKET_URL","getVipConfigFromWindow","BLOG_ID","VIP_RTC","LogLevel","DEFAULT_LOG_THRESHOLD","WARNING","Logger","constructor","localNamespace","threshold","this","namespace","log","level","args","levelStr","console","debug","DEBUG","info","INFO","warn","error","ERROR","critical","CRITICAL","wp","sync","Y","create","Map","setIfUndefined","map","createT","set","undefined","Set","fromCharCode","String","trimLeftRegex","fromCodePoint","fromCamelCaseRegex","fromCamelCase","s","separator","replace","trimLeft","match","toLowerCase","utf8TextEncoder","TextEncoder","utf8TextDecoder","TextDecoder","fatal","ignoreBOM","decode","Uint8Array","length","_localStorage","setItem","newValue","getItem","usePolyfill","localStorage","e","varStorage","Array","from","isNode","isArray","process","release","test","name","toString","isBrowser","document","params","navigator","platform","hasParam","pargs","argv","currParamName","i","parg","push","location","search","slice","split","forEach","kv","value","computeParams","has","getVariable","v","env","toUpperCase","replaceAll","hasConf","FORCE_COLOR","includes","stdout","isTTY","toBase64","bytes","byteLength","btoa","Buffer","buffer","byteOffset","fromBase64","atob","len","charCodeAt","buf","channels","BC","BroadcastChannel","room","eventHandler","onmessage","_onChange","data","addEventListener","postMessage","close","removeEventListener","getChannel","subs","bc","sub","publish","origin","c","getUnixTime","Date","now","floor","Math","min","ceil","abs","imul","round","log10","log2","sqrt","b","pow","Number","isNaN","BIT8","sign","BITS7","Encoder","cpos","cbuf","bufs","createEncoder","encoder","toUint8Array","uint8arr","curPos","write","num","bufferLen","writeVarUint","writeUint8Array","encodeInto","uint8Array","leftCopyLen","rightCopyLen","subarray","writeVarUint8Array","DataView","ArrayBuffer","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","isInteger","parseInt","Error","errorUnexpectedEndOfArray","errorIntegerOutOfRange","Decoder","arr","pos","readVarUint8Array","decoder","view","readUint8Array","readVarUint","mult","r","str","encode","encodedString","unescape","encodeURIComponent","codePointAt","written","remainingLen","nextLen","apply","decodeURIComponent","escape","writeSyncStep1","doc","sv","writeSyncStep2","encodedStateVector","readSyncStep2","transactionOrigin","readUpdate","Observable","_observers","on","f","add","once","_f","off","observers","delete","size","emit","values","destroy","assign","keys","hasProperty","EqualityTraitSymbol","freeze","Symbol","Awareness","super","clientID","states","meta","_checkInterval","setInterval","getLocalState","outdatedTimeout","lastUpdated","setLocalState","remove","clientid","removeAwarenessStates","clearInterval","state","currLocalMeta","clock","prevState","added","updated","filteredUpdated","removed","setLocalStateField","field","getStates","awareness","clients","curMeta","encodeAwarenessUpdate","JSON","stringify","messageHandlers","provider","emitSynced","_messageType","syncMessageType","messageType","readSyncStep1","synced","_decoder","_emitSynced","_encoder","update","timestamp","parse","clientMeta","currClock","y","permissionDeniedHandler","_ydoc","reason","url","readMessage","messageHandler","closeWebsocketConnection","ws","event","wsconnecting","wsconnected","filter","client","status","wsUnsuccessfulReconnects","setTimeout","setupWS","maxBackoffTime","shouldConnect","websocket","_WS","protocols","binaryType","wsLastMessageReceived","send","onerror","onclose","onopen","encoderAwarenessState","broadcastMessage","readyState","OPEN","bcconnected","bcChannel","WebsocketProvider","serverUrl","roomname","connect","WebSocketPolyfill","WebSocket","resyncInterval","disableBc","_synced","_resyncInterval","_bcSubscriber","_updateHandler","_awarenessUpdateHandler","_origin","changedClients","concat","_exitHandler","messageReconnectTimeout","encodedParams","results","val","join","disconnect","connectBc","encoderSync","encoderState","encoderAwarenessQuery","disconnectBc","channel","getErrorMessage","defaultMessage","message","__","WebSocketError","code","SyncConnectionStatusEmitter","listeners","listener","callback","clear","defaultResult","getWpClientId","cache","result","isSecureContext","crypto","randomUUID","generateUUID","fn","memoizeFn","logger","getErrorFromCloseCode","createConnect","syncObjectType","syncObjectId","reconnectAttempts","backoffDelayInMs","Promise","resolve","authToken","apiFetch","path","method","wpClientId","token","fetchAuthToken","auth","connectionConfig","createNewDoc","_a","inspectUrl","logInspectUrl","createWebSocketConnection","config","options","objectType","objectId","ydoc","startsWith","roomName","syncStatusEmitter","handleConnectionClose","err","addFilter"],"sourceRoot":""}